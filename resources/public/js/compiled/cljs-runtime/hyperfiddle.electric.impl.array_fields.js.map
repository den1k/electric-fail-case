{"version":3,"sources":["hyperfiddle/electric/impl/array_fields.cljc"],"mappings":";AAoCA,AAAA;;;;;;;AAAA;AAAA,CAAA,oDAAA,pDAASI;AAAT,AAAA,AAAA;;;AAAA,CAAA,0DAAA,1DAASA;;AAAT,CAAA,6DAAA,7DAASA;;AAAT,CAAA,kEAAA,WAAAJ,mBAAAC,qBAAAC,rHAASE;AAAT,AAAA,OAAAD,iBAAAF,qBAAA;;;AAAA;;;gDAAA,hDAASI,wGAAGC;AAAZ,AAAA,YAAAF,yCAAYE;;;AAAHF,AACT","names":["this__5330__auto__","writer__5331__auto__","opt__5332__auto__","cljs.core/-write","hyperfiddle.electric.impl.array-fields/P","hyperfiddle.electric.impl.array-fields/->P","state-"],"sourcesContent":["(ns hyperfiddle.electric.impl.array-fields\n  (:refer-clojure :exclude [get set])\n  #?(:cljs (:require-macros hyperfiddle.electric.impl.array-fields))\n  (:require [hyperfiddle.rcf :as rcf :refer [tests]]))\n;; #?(:clj (set! *warn-on-reflection* true))\n(defmacro deffields [& fields]\n  `(do ~@(for [[fld idx] (mapv vector fields (range))]\n           `(def ~fld (int ~idx)))))\n(defmacro swap [arr k f & args]\n  (let [ar (with-meta (gensym \"arr\") {:tag 'objects})]\n    `(let [~ar ~arr, k# ~k, f# ~f]\n       (aset ~ar k# (f# (aget ~ar k#) ~@args)))))\n(defmacro fswap [O k f & args] `(swap (.-state- ~O) ~k ~f ~@args))\n(defmacro get [arr k]\n  (let [ar (with-meta (gensym \"arr\") {:tag 'objects})]\n    `(let [~ar ~arr] (aget ~ar ~k))))\n(defmacro fget [O k] `(get (.-state- ~O) ~k))\n(defmacro set [arr & kvs]\n  (let [ar (with-meta (gensym \"arr\") {:tag 'objects})]\n    `(let [~ar ~arr]\n       ~@(for [[k v] (partition 2 kvs)]\n           ;; FIXME better way to fix reflection warning than call `identity`?\n           `(aset ~ar ~k (identity ~v))))))\n(defmacro fset [O & kvs] `(set (.-state- ~O) ~@kvs))\n(defmacro fgetset [O k v] `(getset (.-state- ~O) ~k ~v))\n(defmacro getset [arr k v]\n  (let [ar (with-meta (gensym \"arr\") {:tag 'objects})]\n    `(let [~ar ~arr, k# ~k, ret# (get ~ar k#)]\n       (set ~ar k# ~v)\n       ret#)))\n(defmacro getswap [arr k f]\n  (let [ar (with-meta (gensym \"arr\") {:tag 'objects})]\n    `(let [~ar ~arr, k# ~k, v# (get ~ar k#)]\n       (aset ~ar k# (~f v#))  v#)))\n\n;;; TESTS ;;;\n(deftype P [state-])\n(tests\n  (deffields x y)\n  (def aP (->P (object-array 2)))\n  (let [^P aP aP]\n    (fset aP x 1 y 2)            := 2\n    [(fget aP x) (fget aP y)]    := [1 2]\n    (fswap aP x inc)             := 2\n    (swap (.-state- aP) x inc)   := 3\n    (fgetset aP x 0)             := 3\n    (getset (.-state- aP) x 100) := 0\n    (fget aP x)                  := 100\n    (getswap (.-state- aP) x inc) := 100\n    (fget aP x)                   := 101\n    ))\n"]}