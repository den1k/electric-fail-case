{"version":3,"sources":["hyperfiddle/electric/impl/yield2.cljc"],"mappings":"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","names":["hyperfiddle.electric.impl.yield2/input","hyperfiddle.electric.impl.yield2/recover","hyperfiddle.electric.impl.yield2/children","hyperfiddle.electric.impl.yield2/last-in","hyperfiddle.electric.impl.yield2/last-out","unused__11803__auto__","self__","G__33581","js/Error","args33570","cljs.core/aclone","this__5330__auto__","writer__5331__auto__","opt__5332__auto__","cljs.core/-write","hyperfiddle.electric.impl.yield2/Yield","hyperfiddle.electric.impl.yield2/->Yield","checker","notifier","terminator","state-","this","hyperfiddle.electric.impl.yield2/cancel","hyperfiddle.electric.impl.yield2/transfer","hyperfiddle.electric.impl.yield2/iterator","hyperfiddle.electric.impl.yield2/notified?","hyperfiddle.electric.impl.yield2/on-notify","hyperfiddle.electric.impl.yield2/input-notified","Y","or__5045__auto__","arr33598","k__29338__auto__","ret__29339__auto__","arr33602","arr33603","cljs.core/identity","arr33599","G__33606","arr33607","arr33608","fexpr__33614","hyperfiddle.electric.impl.yield2/recover-notified","arr33622","arr33628","arr33632","arr33623","arr33636","arr33637","fexpr__33639","hyperfiddle.electric.impl.yield2/terminated","arr33644","k__29281__auto__","f__29282__auto__","G__33645","cljs.core/dec","fexpr__33646","hyperfiddle.electric.impl.yield2/swallow","o","cljs.core/deref","e33651","arr33652","_","hyperfiddle.electric.impl.yield2/trash","arr33657","fexpr__33659","arr33660","arr33661","arr33663","arr33665","fexpr__33671","arr33672","arr33673","temp__5808__auto__","rec","arr33676","hyperfiddle.electric.impl.yield2/create-recover",">r","arr33684","arr33686","G__33689","cljs.core/inc","me","arr33690","cljs.core.object_array","arr33694","G__33697","G__33698","fexpr__33700","arr33701","hyperfiddle.electric.impl.yield2/transfer-recover","arr33714","arr33715","arr33717","arr33720","hyperfiddle.electric.impl.yield2/transfer-input","arr33729","arr33730","in","arr33732","arr33734","cljs.core._EQ_","arr33736","arr33737","temp__5806__auto__",">recover","fexpr__33738","out","arr33746","arr33748","arr33752","arr33740","arr33742","e33756","arr33760","arr33761","arr33762","arr33763","cljs.core.ex_info","e","arr33757","arr33758","hyperfiddle.electric.impl.yield2/yield",">input","n","t","arr33772","arr33775","G__33779","G__33780","fexpr__33782","arr33783"],"sourcesContent":["(ns hyperfiddle.electric.impl.yield2\n  #?(:cljs (:require-macros hyperfiddle.electric.impl.yield2))\n  (:import [missionary Cancelled]\n           #?(:clj [clojure.lang IFn IDeref ExceptionInfo]))\n  (:require [hyperfiddle.rcf :as rcf :refer [tests tap %]]\n            [hyperfiddle.electric.impl.array-fields :as a]\n            [missionary.core :as m]))\n;; #?(:clj (set! *warn-on-reflection* true))\n(declare cancel transfer)\n(a/deffields input recover children last-in last-out) ; Yield's array fields\n(deftype Yield [checker notifier terminator state-]\n  IFn (#?(:clj invoke :cljs -invoke) [this] (locking this (cancel this)))\n  IDeref (#?(:clj deref :cljs -deref) [this] (locking this (transfer this))))\n(a/deffields iterator notified? on-notify) ; a child's array fields\n(defn input-notified [^Yield Y]\n  (when-not (or (a/getset (a/fget Y input) notified? true) (some-> (a/fget Y recover) (a/get notified?)))\n    ((.-notifier Y))))\n(defn recover-notified [^Yield Y]\n  (when-not (or (a/getset (a/fget Y recover) notified? true) (a/get (a/fget Y input) notified?))\n    ((.-notifier Y))))\n(defn terminated [^Yield Y] (when (zero? (a/fswap Y children dec)) ((.-terminator Y))))\n(defn swallow [o] (try @(a/get o iterator) (catch #?(:clj Throwable :cljs :default) _)))\n(defn trash [o] (a/set o on-notify #(swallow o)) ((a/get o iterator)) (when (a/getset o notified? false) (swallow o)))\n(defn cancel [^Yield Y] ((a/get (a/fget Y input) iterator)) (when-some [rec (a/fget Y recover)] (trash rec)))\n(defn create-recover [^Yield Y >r]\n  (when-some [rec (a/fget Y recover)] (trash rec))\n  (a/fswap Y children inc)\n  (let [me (a/fset Y recover (object-array 3))]\n    (a/set me on-notify #(do), iterator (>r #((a/get me on-notify)) #(terminated Y)))))\n(defn transfer-recover [^Yield Y] (a/set (a/fget Y recover) notified? false) @(a/get (a/fget Y recover) iterator))\n(defn transfer-input [^Yield Y]\n  (a/set (a/fget Y input) notified? false)\n  (let [in @(a/get (a/fget Y input) iterator)]\n    (if (= in (a/fget Y last-in))\n      (a/fget Y last-out)\n      (if-some [>recover ((.-checker Y) in)]\n        (let [out (do (create-recover Y >recover) (transfer-recover Y))]\n          (a/set (a/fget Y recover) on-notify #(recover-notified Y))\n          (a/fset Y last-in in, last-out out))\n        (do (a/fset Y last-in ::none) (when-some [rec (a/fget Y recover)] (trash rec))  in)))))\n(defn transfer [^Yield Y]\n  (try (cond (a/get (a/fget Y input)   notified?) (transfer-input Y)\n             (a/get (a/fget Y recover) notified?) (transfer-recover Y)\n             :else (throw (ex-info \"You cannot transfer a value if I haven't notified you\" {})))\n       (catch #?(:clj Throwable :cljs :default) e\n         (trash (a/fget Y input)) (when-some [rec (a/fget Y recover)] (trash rec)) (throw e))))\n(defn yield [checker >input]\n  (fn [n t]\n    (let [^Yield Y (->Yield checker n t (object-array 5))\n          me (a/fset Y children 1, last-in ::none, input (object-array 3))]\n      (a/set me on-notify #(input-notified Y), iterator (>input #((a/get me on-notify)) #(terminated Y)))\n      Y)))\n;;; TESTS ;;;\n(tests \"input flow with nil checker is noop\"\n  (def !x (atom 0))\n  (def it ((yield (constantly nil) (m/watch !x))\n           #(tap :notified) #(tap :terminated)))\n  #_start         % := :notified, @it := 0\n  (swap! !x inc)  % := :notified, @it := 1\n  (swap! !x inc)  % := :notified, @it := 2\n  (it)            % := :notified, @it :throws Cancelled, % := :terminated)\n(tests \"input flow runs recovery\"\n  (def !x (atom 0))\n  (def !recover (atom 10))\n  (def it ((yield (constantly (m/watch !recover)) (m/watch !x))  #(tap :notified) #(tap :terminated)))\n  #_start               % := :notified, @it := 10\n  (swap! !x inc)        % := :notified, @it := 10\n  (swap! !recover inc)  % := :notified, @it := 11\n  (it)                  % := :notified, @it :throws Cancelled, % := :terminated)\n(tests \"oscillate\"\n  (def !e (atom \"odd\"))\n  (def !x (atom 0))\n  (def it ((yield (fn [x] (when (odd? x) (m/watch !e))) (m/watch !x))  #(do) #(do)))\n  #_start            @it := 0\n  (swap! !x inc)     @it := \"odd\"\n  (reset! !e \"ODD\")  @it := \"ODD\"\n  (swap! !x inc)     @it := 2\n  (it))\n(tests \"work skipping\"\n  (def !e (atom \"odd\"))\n  (def !x (atom 0))\n  (def it ((yield (fn [x] (tap x) (when (odd? x) (m/watch !e))) (m/watch !x))  #(do) #(do)))\n  #_start             @it := 0,     % := 0\n  (swap! !x inc)      @it := \"odd\", % := 1\n  (swap! !x identity) @it := \"odd\"    ; nothing tapped, work skipped\n  (reset! !e \"ODD\")   @it := \"ODD\"    ; recovery flow is still alive\n  (swap! !x inc)      @it := 2,     % := 2\n  (it))\n(tests \"work skipping, initially in recovery\"\n  (def !e (atom \"odd\"))\n  (def !x (atom 1))\n  (def it ((yield (fn [x] (tap x) (when (odd? x) (m/watch !e))) (m/watch !x))  #(do) #(do)))\n  #_start             @it := \"odd\", % := 1\n  (swap! !x identity) @it := \"odd\"    ; nothing tapped, work skipped\n  (reset! !e \"ODD\")   @it := \"ODD\"    ; recovery flow is still alive\n  (swap! !x inc)      @it := 2,     % := 2\n  (it))\n(tests \"work skipping m/cp\"\n  (def !x (atom 1))\n  (def it ((yield (fn [x] (tap x) (when (odd? x) (m/cp \"odd\"))) (m/watch !x))  #(do) #(do)))\n  #_start             @it := \"odd\", % := 1\n  (swap! !x identity) @it := \"odd\"    ; nothing tapped, work skipped\n  (swap! !x inc)      @it := 2,     % := 2\n  (it))\n(tests \"recovery flows are cleaned up\"\n  (def !x (atom 0))\n  (let [->recover (m/observe (fn [!] (! :init) #(tap :unmounted)))]\n    (def it ((yield (fn [x] (when (pos? x) ->recover)) (m/watch !x))  #(do) #(tap :terminated))))\n  #_start         @it := 0\n  (swap! !x inc)  @it := :init                           ; first recovery starts\n  (swap! !x inc)  @it := :init, % := :unmounted          ; second starts, first unmounts\n  (it)            @it :throws Cancelled, % := :unmounted, % := :terminated)\n(tests \"an immediately ready input works\"\n  (def it ((yield (fn [x] (when (pos? x) (m/cp :recover))) (m/seed [0 1 2]))  #(do) #(tap :terminated)))\n  @it := 0, @it := :recover, @it := :recover, (it), % := :terminated)\n(tests \"input throws\"\n  (def !x (atom 0))\n  (def it ((yield (constantly nil) (m/latest #(if (pos? %) (throw (ex-info \"pos\" {})) %) (m/watch !x)))\n           #(tap :notified) #(tap :terminated)))\n                 % := :notified, @it := 0\n  (swap! !x inc) % := :notified, @it :throws ExceptionInfo, % := :terminated)\n(tests \"recovery throws\"\n  (def !x (atom 0))\n  (def it ((yield (fn [x] (when (pos? x) (m/cp (throw (ex-info \"boom\" {}))))) (m/watch !x))\n           #(tap :notified) #(tap :terminated)))\n  #_start         % := :notified, @it := 0\n  (swap! !x inc), % := :notified, @it :throws ExceptionInfo, % := :terminated)\n(tests \"recovery unmounts when we switch back to input\"\n  (def !x (atom 0))\n  (let [->recover (m/observe (fn [!] (! :init) #(tap :unmounted)))]\n    (def it ((yield (fn [x] (when (odd? x) ->recover)) (m/watch !x))  #(do) #(tap :terminated))))\n  #_start         @it := 0\n  (swap! !x inc)  @it := :init              ; recovery starts\n  (swap! !x inc)  @it := 2, % := :unmounted ; back to input, recovery stops\n  (it)            @it :throws Cancelled, % := :terminated)\n(tests \"work skipping is invalidated after successful input\"\n  (def !x (atom 0))\n  (def it ((yield (fn [x] (when (odd? x) (tap :recover) (m/cp :recover))) (m/watch !x))  #(do) #(tap :terminated)))\n  #_start         @it := 0\n  (swap! !x inc)  @it := :recover, % := :recover\n  (swap! !x inc)  @it := 2\n  \"same input but good input in between, so won't work skip\"\n  (swap! !x dec)  @it := :recover, % := :recover\n  (it)            @it :throws Cancelled, % := :terminated)\n(tests \"initial nil isn't work skipped\"\n  (def it ((yield (fn [_] (tap :recover) nil) (m/cp nil))  #(do) #(do)))\n  @it := nil, % := :recover)\n"]}