{"version":3,"sources":["hyperfiddle/electric_dom2.cljc"],"mappings":"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","names":["hyperfiddle.electric-dom2/nil-subject","!","var_args","args__5775__auto__","len__5769__auto__","i__5770__auto__","argseq__5776__auto__","cljs.core/IndexedSeq","hyperfiddle.electric-dom2/unsupported","seq45634","self__5755__auto__","cljs.core/seq","_","cljs.core.ex_info","hyperfiddle.electric-dom2/hook","x","y","hyperfiddle.electric-dom2/by-id","id","js/document.getElementById","hyperfiddle.electric-dom2/new-node","parent","type","el","G__45635","cljs.core/Keyword","js/document","goog.dom/createTextNode","goog.dom/createElement","hyperfiddle.electric-dom2/-googDomSetTextContentNoWarn","node","str","goog.dom/setTextContent","hyperfiddle.electric-dom2/class-str","v","cljs.core/name","clojure.string.join","cljs.core.eduction","cljs.core.remove","cljs.core/nil?","cljs.core.map","hyperfiddle.electric-dom2/SVG-NS","G__45637","hyperfiddle.electric-dom2/set-property!","js/Error","k","hyperfiddle.electric_dom2.set_property_BANG_","ns","cljs.core/clj->js","and__5043__auto__","G__45638","goog.style/setStyle","temp__5802__auto__","hyperfiddle.electric_dom2.goog$module$goog$object.get","goog.dom/DIRECT_ATTRIBUTE_MAP_","cljs.core._EQ_","hyperfiddle.electric_dom2.goog$module$goog$object.containsKey","hyperfiddle.electric_dom2.goog$module$goog$object.set","hyperfiddle.electric-dom2/unmount-prop","missionary.core/observe","G__45642","hyperfiddle.electric-dom2/event*","dom-node","event-name","callback","hyperfiddle.electric_dom2.event_STAR_","options","hyperfiddle.electric-dom2/happen","s","e","G__45643","hyperfiddle.electric-dom2/set-val"],"sourcesContent":["(ns hyperfiddle.electric-dom2\n  (:refer-clojure :exclude [time])\n  (:require #?(:cljs goog.dom)\n            #?(:cljs goog.object)\n            #?(:cljs goog.style)\n            [hyperfiddle.electric :as e]\n            [missionary.core :as m])\n  (:import [hyperfiddle.electric Pending])\n  #?(:cljs (:require-macros [hyperfiddle.electric-dom2 :refer [with]])))\n\n(e/def node)\n(def nil-subject (fn [!] (! nil) #()))\n(e/def keepalive (new (m/observe nil-subject)))\n\n(defn unsupported [& _]\n  (throw (ex-info (str \"Not available on this peer.\") {})))\n\n(def hook \"See `with`\"\n  #?(:clj  unsupported\n     :cljs (fn ([x] (.removeChild (.-parentNode x) x)) ; unmount\n             ([x y] (.insertBefore (.-parentNode x) x y))))) ; rotate siblings\n\n(defmacro with\n  \"Attach `body` to a dom node, which will be moved in the DOM when body moves in the DAG.\n  Given p/for semantics, `body` can only move sideways or be cancelled. If body is cancelled,\n  the node will be unmounted. If body moves, the node will rotate with its siblings.\"\n  [dom-node & body]\n  `(binding [node ~dom-node]\n     ; wrap body in a constant frame, so it can be moved as a block\n     (new (e/hook hook node (e/fn [] keepalive ~@body))))) ; todo remove\n\n#?(:cljs (defn by-id [id] (js/document.getElementById id)))\n\n#?(:cljs\n   (defn new-node [parent type]\n     (let [el (case type\n                :comment (.createComment js/document \"\")\n                :text (goog.dom/createTextNode \"\")\n                (goog.dom/createElement type))]\n       (.appendChild parent el)\n       el)))\n\n(defmacro element [t & body]\n  `(with (new-node node ~(name t))\n     ; hack: speed up streamy unmount by removing from layout first\n     ; it also feels faster visually\n     (e/on-unmount #(set! (.. node -style -display) \"none\")) ; hack\n     ~@body))\n\n#?(:cljs (defn -googDomSetTextContentNoWarn [node str]\n           ; Electric says :infer-warning Cannot infer target type in expression, fixme\n           (goog.dom/setTextContent node str)))\n\n(defmacro text [& strs]\n  `(do (assert (not= (.-nodeType node) (.-TEXT_NODE node))\n               \"userland directed dom/text inside dom/text, which is illegal\")\n       ~@(map (fn [str]\n                `(with (new-node node :text)\n                   (-googDomSetTextContentNoWarn node ~str)))\n           strs)))\n\n(defmacro comment_ [& strs]\n  (cons `do\n    (map (fn [str] `(with (new-node node :comment)\n                      (-googDomSetTextContentNoWarn node ~str)))\n      strs)))\n\n(defn class-str [v]\n  (cond\n    (or (string? v) (keyword? v)) (name v)\n    (seq v) (clojure.string/join \" \" (eduction (remove nil?) (map name) v))\n    :else \"\"))\n\n(def ^:const SVG-NS \"http://www.w3.org/2000/svg\")\n\n#?(:cljs\n   (defn set-property!\n     ([node k v] (set-property! node (.-namespaceURI node) k v))\n     ([node ns k v]\n      (let [k (name k)\n            v (clj->js v)]\n        (if (and (nil? v) (.hasAttributeNS node nil k))\n          (.removeAttributeNS node nil k)\n          (case k\n            \"style\" (goog.style/setStyle node v)\n            \"class\" (set! (.-className node) (class-str v))\n            \"for\"   (set! (.-htmlFor node) v)\n            \"list\"  (.setAttributeNS node nil k v) ; corner case, list (datalist) is setted by attribute and readonly as a prop.\n            (if-let [k (goog.object/get goog.dom/DIRECT_ATTRIBUTE_MAP_ k)]\n              (.setAttributeNS node nil k v)\n              (if (= SVG-NS ns)\n                (.setAttributeNS node nil k v)\n                (if (goog.object/containsKey node k) ; is there an object property for this key?\n                  (goog.object/set node k v)\n                  (.setAttributeNS node nil k v))))))))))\n\n#?(:cljs (defn unmount-prop [node k v]\n           (m/observe (fn [!] (! nil) #(set-property! node k v)))))\n\n(defmacro style [m]\n  (if (map? m)\n    `(do ~@(mapcat (fn [[k v]] [`(set-property! node \"style\" {~k ~v})\n                                `(new (unmount-prop node \"style\" {~k nil}))]) m)\n         nil) ; static keyset\n    `(e/for-by first [sty# (vec ~m)]\n       (set-property! node \"style\" {(key sty#) (val sty#)})\n       (new (unmount-prop node {(key sty#) nil}))\n       nil)))\n\n;; TODO JS runtimes intern litteral strings, so call `name` on keywords at\n;; macroexpension.\n(defmacro props [m]\n  (let [style? #{:style ::style}]       ; TODO disambiguate\n    (if (map? m)\n      `(do ~@(mapcat (fn [[k v]] (if (style? k) ; static keyset\n                                   [`(style ~v)]\n                                   [`(set-property! node ~k ~v)\n                                    `(new (unmount-prop node ~k nil))]))\n                     m)\n           nil)\n      `(e/for-by key [prop# (vec ~m)]\n         (if (~style? (key prop#))\n           (style (val prop#))\n           (do (set-property! node (key prop#) (val prop#))\n               (new (unmount-prop node (key prop#) nil))\n               nil))))))\n\n(defn event*\n  ([dom-node event-name callback] (event* dom-node event-name callback {}))\n  ([dom-node event-name callback options]\n   (m/observe (fn [!]\n                (! nil)\n                (.addEventListener dom-node event-name callback #?(:cljs (clj->js options)))\n                #(.removeEventListener dom-node event-name callback)))))\n\n(defmacro on!\n  \"Call the `callback` clojure function on event.\n   (on! \\\"click\\\" (fn [event] ...)) \"\n  ([event-name callback] `(new (event* node ~event-name ~callback)))\n  ([dom-node event-name callback] `(new (event* ~dom-node ~event-name ~callback)))\n  ([dom-node event-name callback options] `(new (event* ~dom-node ~event-name ~callback ~options))))\n\n(defmacro ^:deprecated ^:no-doc event \"Deprecated, please use `on!`\" [& args] `(on! ~@args))\n\n(defn happen [s e]\n  ; Todo, we need a buffer to force a nil in between events to fix race\n  (case (:status s)\n    :idle {:status :impulse :event e} ; rising edge\n    :pending {:status :impulse :event e} ; supersede the outstanding event with a new event\n    :impulse (assert false \"two events in the same frame? that's weird and wrong\")))\n\n; data EventState = Idle | Impulse event | Pending event\n(e/defn Event [type busy]\n  (:event\n    (let [!state (atom {:status :idle})\n          state (e/watch !state)]\n\n      ; rising edge happens once, even if busy state (prevent infinite loop) -- [DJG] I don't understand\n      (event type (partial swap! !state happen)) ; discrete rising edge\n\n      (reset! !state\n              (case (:status state)\n                :idle state\n                :impulse (assoc state :status :pending) ; impulse is seen for 1 frame and then cleared\n                :pending (if busy state {:status :idle}))))))\n\n(e/def ^:deprecated system-time-ms e/system-time-ms)\n(e/def ^:deprecated system-time-secs e/system-time-secs)\n\n(defmacro on\n  \"Run the given electric function on event.\n  (on \\\"click\\\" (e/fn [event] ...))\"\n  ;; TODO add support of event options (see `event*`)\n  ([typ]   `(new Event ~typ false))\n  ([typ F] `(on node ~typ ~F))\n  ([node typ F] `(binding [node ~node]\n                   (let [x# (e/with-cycle [?v# nil]\n                              (let [busy# (= ?v# ::e/pending)]\n                                (when-some [evt# (new Event ~typ busy#)]\n                                  (try (new ~F evt#)\n                                       (catch Pending e# ::e/pending)\n                                       (catch :default e# [::err e#])))))]\n                     (cond (= ::e/pending x#) (throw (Pending.))\n                           (and (vector? x#) (= ::err (first x#))) (throw (second x#))\n                           :else x#)))))\n\n(defmacro on-pending [pending-body & body] `(try (do ~@body) (catch Pending e# ~pending-body (throw e#))))\n\n(e/defn Focused? []\n  (e/with-cycle [focused false]\n    (if focused (nil? (on \"blur\")) (some? (on \"focus\")))))\n\n#?(:cljs (defn set-val [node v] (set! (.-value node) (str v))))\n\n(defmacro bind-value\n  ([v]        `(bind-value ~v set-val))\n  ([v setter] `(let [v# ~v]\n                 (when-not (new Focused?)\n                   (~setter node v#)))))\n\n(defmacro a [& body] `(element :a ~@body))\n(defmacro abbr [& body] `(element :abbr ~@body))\n(defmacro address [& body] `(element :address ~@body))\n(defmacro area [& body] `(element :area ~@body))\n(defmacro article [& body] `(element :article ~@body))\n(defmacro aside [& body] `(element :aside ~@body))\n(defmacro audio [& body] `(element :audio ~@body))\n(defmacro b [& body] `(element :b ~@body))\n(defmacro bdi [& body] `(element :bdi ~@body))\n(defmacro bdo [& body] `(element :bdo ~@body))\n(defmacro blockquote [& body] `(element :blockquote ~@body))\n(defmacro br [& body] `(element :br ~@body))\n(defmacro button [& body] `(element :button ~@body))\n(defmacro canvas [& body] `(element :canvas ~@body))\n(defmacro cite [& body] `(element :cite ~@body))\n(defmacro code [& body] `(element :code ~@body))\n(defmacro data [& body] `(element :data ~@body))\n(defmacro datalist [& body] `(element :datalist ~@body))\n(defmacro del [& body] `(element :del ~@body))\n(defmacro details [& body] `(element :details ~@body))\n(defmacro dfn [& body] `(element :dfn ~@body))\n(defmacro dialog [& body] `(element :dialog ~@body))\n(defmacro div [& body] `(element :div ~@body))\n(defmacro dl \"The <dl> HTML element represents a description list. The element encloses a list of groups of terms (specified using the <dt> element) and descriptions (provided by <dd> elements). Common uses for this element are to implement a glossary or to display metadata (a list of key-value pairs).\" [& body] `(element :dl ~@body))\n(defmacro dt \"The <dt> HTML element specifies a term in a description or definition list, and as such must be used inside a <dl> element. It is usually followed by a <dd> element; however, multiple <dt> elements in a row indicate several terms that are all defined by the immediate next <dd> element.\" [& body] `(element :dt ~@body))\n(defmacro dd \"The <dd> HTML element provides the description, definition, or value for the preceding term (<dt>) in a description list (<dl>).\" [& body] `(element :dd ~@body))\n(defmacro em [& body] `(element :em ~@body))\n(defmacro embed [& body] `(element :embed ~@body))\n(defmacro fieldset [& body] `(element :fieldset ~@body))\n(defmacro figure [& body] `(element :figure ~@body))\n(defmacro footer [& body] `(element :footer ~@body))\n(defmacro form [& body] `(element :form ~@body))\n(defmacro h1 [& body] `(element :h1 ~@body))\n(defmacro h2 [& body] `(element :h2 ~@body))\n(defmacro h3 [& body] `(element :h3 ~@body))\n(defmacro h4 [& body] `(element :h4 ~@body))\n(defmacro h5 [& body] `(element :h5 ~@body))\n(defmacro h6 [& body] `(element :h6 ~@body))\n(defmacro header [& body] `(element :header ~@body))\n(defmacro hgroup [& body] `(element :hgroup ~@body))\n(defmacro hr [& body] `(element :hr ~@body))\n(defmacro i [& body] `(element :i ~@body))\n(defmacro iframe [& body] `(element :iframe ~@body))\n(defmacro img [& body] `(element :img ~@body))\n(defmacro input [& body] `(element :input ~@body))\n(defmacro ins [& body] `(element :ins ~@body))\n(defmacro kbd [& body] `(element :kbd ~@body))\n(defmacro label [& body] `(element :label ~@body))\n(defmacro legend [& body] `(element :legend ~@body))\n(defmacro li [& body] `(element :li ~@body))\n(defmacro link [& body] `(element :link ~@body))\n(defmacro main [& body] `(element :main ~@body))\n#_(defmacro map [& body] `(element :map ~@body))\n(defmacro mark [& body] `(element :mark ~@body))\n(defmacro math [& body] `(element :math ~@body))\n(defmacro menu [& body] `(element :menu ~@body))\n(defmacro itemprop [& body] `(element :itemprop ~@body))\n(defmacro meter [& body] `(element :meter ~@body))\n(defmacro nav [& body] `(element :nav ~@body))\n(defmacro noscript [& body] `(element :noscript ~@body))\n(defmacro object [& body] `(element :object ~@body))\n(defmacro ol [& body] `(element :ol ~@body))\n(defmacro option [& body] `(element :option ~@body))\n(defmacro output [& body] `(element :output ~@body))\n(defmacro p [& body] `(element :p ~@body))\n(defmacro picture [& body] `(element :picture ~@body))\n(defmacro pre [& body] `(element :pre ~@body))\n(defmacro progress [& body] `(element :progress ~@body))\n(defmacro q [& body] `(element :q ~@body))\n(defmacro ruby [& body] `(element :ruby ~@body))\n(defmacro s [& body] `(element :s ~@body))\n(defmacro samp [& body] `(element :samp ~@body))\n(defmacro script [& body] `(element :script ~@body))\n(defmacro section [& body] `(element :section ~@body))\n(defmacro select [& body] `(element :select ~@body))\n(defmacro slot [& body] `(element :slot ~@body))\n(defmacro small [& body] `(element :small ~@body))\n(defmacro span [& body] `(element :span ~@body))\n(defmacro strong [& body] `(element :strong ~@body))\n(defmacro sub [& body] `(element :sub ~@body))\n(defmacro sup [& body] `(element :sup ~@body))\n(defmacro table [& body] `(element :table ~@body))\n(defmacro tbody [& body] `(element :tbody ~@body))\n(defmacro td [& body] `(element :td ~@body))\n(defmacro th [& body] `(element :th ~@body))\n(defmacro thead [& body] `(element :thead ~@body))\n(defmacro tr [& body] `(element :tr ~@body))\n(defmacro template [& body] `(element :template ~@body))\n(defmacro textarea [& body] `(element :textarea ~@body))\n(defmacro time [& body] `(element :time ~@body))\n(defmacro u [& body] `(element :u ~@body))\n(defmacro ul [& body] `(element :ul ~@body))\n(defmacro var [& body] `(element :var ~@body))\n(defmacro video [& body] `(element :video ~@body))\n(defmacro wbr [& body] `(element :wbr ~@body))\n"]}