shadow$provide.module$node_modules$vega_hierarchy$build$vega_hierarchy=function(global$jscomp$0,require,module,exports$jscomp$0){(function(global,factory){"object"===typeof exports$jscomp$0&&"undefined"!==typeof module?factory(exports$jscomp$0,require("module$node_modules$vega_dataflow$build$vega_dataflow"),require("module$node_modules$vega_util$build$vega_util")):"function"===typeof define&&define.amd?define(["exports","vega-dataflow","vega-util"],factory):(global="undefined"!==typeof globalThis?
globalThis:global||self,factory(global.vega={},global.vega,global.vega))})(this,function(exports,vegaDataflow,vegaUtil){function lookup(tree,key,filter){const map={};tree.each(node=>{const t=node.data;filter(t)&&(map[key(t)]=node)});tree.lookup=map;return tree}function defaultSeparation$2(a,b){return a.parent===b.parent?1:2}function meanXReduce(x,c){return x+c.x}function maxYReduce(y,c){return Math.max(y,c.y)}function leafLeft(node){for(var children;children=node.children;)node=children[0];return node}
function leafRight(node){for(var children;children=node.children;)node=children[children.length-1];return node}function count(node){var sum=0,children=node.children,i=children&&children.length;if(i)for(;0<=--i;)sum+=children[i].value;else sum=1;node.value=sum}function hierarchy(data,children){data instanceof Map?(data=[void 0,data],void 0===children&&(children=mapChildren)):void 0===children&&(children=objectChildren);data=new Node$1(data);for(var node,nodes=[data],child,childs,i,n;node=nodes.pop();)if((childs=
children(node.data))&&(n=(childs=Array.from(childs)).length))for(node.children=childs,i=n-1;0<=i;--i)nodes.push(child=childs[i]=new Node$1(childs[i])),child.parent=node,child.depth=node.depth+1;return data.eachBefore(computeHeight)}function objectChildren(d){return d.children}function mapChildren(d){return Array.isArray(d)?d[1]:null}function copyData(node){void 0!==node.data.value&&(node.value=node.data.value);node.data=node.data.data}function computeHeight(node){var height=0;do node.height=height;
while((node=node.parent)&&node.height<++height)}function Node$1(data){this.data=data;this.depth=this.height=0;this.parent=null}function enclosesNot(a,b){var dr=a.r-b.r,dx=b.x-a.x;a=b.y-a.y;return 0>dr||dr*dr<dx*dx+a*a}function enclosesWeak(a,b){var dr=a.r-b.r+1E-9*Math.max(a.r,b.r,1),dx=b.x-a.x;a=b.y-a.y;return 0<dr&&dr*dr>dx*dx+a*a}function enclosesWeakAll(a,B){for(var i=0;i<B.length;++i)if(!enclosesWeak(a,B[i]))return!1;return!0}function encloseBasis2(a,b){var x1=a.x,y1=a.y;a=a.r;var x2=b.x,y2=
b.y;b=b.r;var x21=x2-x1,y21=y2-y1,r21=b-a,l=Math.sqrt(x21*x21+y21*y21);return{x:(x1+x2+x21/l*r21)/2,y:(y1+y2+y21/l*r21)/2,r:(l+a+b)/2}}function encloseBasis3(a,b,c){var x1=a.x,y1=a.y;a=a.r;var x2=b.x,y2=b.y,r2=b.r,x3=c.x,y3=c.y,r3=c.r;c=x1-x2;b=x1-x3;var b2=y1-y2,b3=y1-y3,c2=r2-a,c3=r3-a,d1=x1*x1+y1*y1-a*a;y2=d1-x2*x2-y2*y2+r2*r2;y3=d1-x3*x3-y3*y3+r3*r3;x3=b*b2-c*b3;x2=(b2*y3-b3*y2)/(2*x3)-x1;b2=(b3*c2-b2*c3)/x3;b3=(b*y2-c*y3)/(2*x3)-y1;c=(c*c3-b*c2)/x3;b=b2*b2+c*c-1;c2=2*(a+x2*b2+b3*c);a=x2*x2+b3*
b3-a*a;a=-(b?(c2+Math.sqrt(c2*c2-4*b*a))/(2*b):a/c2);return{x:x1+x2+b2*a,y:y1+b3+c*a,r:a}}function place(b,a,c){var dx=b.x-a.x,dy=b.y-a.y,d2=dx*dx+dy*dy;if(d2){var a2=a.r+c.r;a2*=a2;var b2=b.r+c.r;b2*=b2;if(a2>b2){var x=(d2+b2-a2)/(2*d2);a2=Math.sqrt(Math.max(0,b2/d2-x*x));c.x=b.x-x*dx-a2*dy;c.y=b.y-x*dy+a2*dx}else x=(d2+a2-b2)/(2*d2),a2=Math.sqrt(Math.max(0,a2/d2-x*x)),c.x=a.x+x*dx-a2*dy,c.y=a.y+x*dy+a2*dx}else c.x=a.x+c.r,c.y=a.y}function intersects(a,b){var dr=a.r+b.r-1E-6,dx=b.x-a.x;a=b.y-a.y;
return 0<dr&&dr*dr>dx*dx+a*a}function score(node){var a=node._,b=node.next._,ab=a.r+b.r;node=(a.x*b.r+b.x*a.r)/ab;a=(a.y*b.r+b.y*a.r)/ab;return node*node+a*a}function Node(circle){this._=circle;this.previous=this.next=null}function packEnclose(circles){if(!(n=(circles="object"===typeof circles&&"length"in circles?circles:Array.from(circles)).length))return 0;var c,n;var a=circles[0];a.x=0;a.y=0;if(!(1<n))return a.r;var b=circles[1];a.x=-b.r;b.x=a.r;b.y=0;if(!(2<n))return a.r+b.r;place(b,a,c=circles[2]);
a=new Node(a);b=new Node(b);c=new Node(c);a.next=c.previous=b;b.next=a.previous=c;c.next=b.previous=a;var i=3;a:for(;i<n;++i){place(a._,b._,c=circles[i]);c=new Node(c);var aa=b.next;var ca=a.previous;var sj=b._.r;var sk=a._.r;do if(sj<=sk){if(intersects(aa._,c._)){b=aa;a.next=b;b.previous=a;--i;continue a}sj+=aa._.r;aa=aa.next}else{if(intersects(ca._,c._)){a=ca;a.next=b;b.previous=a;--i;continue a}sk+=ca._.r;ca=ca.previous}while(aa!==ca.next);c.previous=a;c.next=b;a.next=b.previous=b=c;for(aa=score(a);(c=
c.next)!==b;)(ca=score(c))<aa&&(a=c,aa=ca);b=a.next}a=[b._];for(c=b;(c=c.next)!==b;)a.push(c._);c=0;a=Array.from(a);for(b=a.length;b;)aa=Math.random()*b--|0,i=a[b],a[b]=a[aa],a[aa]=i;b=a.length;i=[];for(var e;c<b;)if(aa=a[c],e&&enclosesWeak(e,aa))++c;else{a:if(e=i,enclosesWeakAll(aa,e))e=[aa];else{for(i=0;i<e.length;++i)if(enclosesNot(aa,e[i])&&enclosesWeakAll(encloseBasis2(e[i],aa),e)){e=[e[i],aa];break a}for(i=0;i<e.length-1;++i)for(c=i+1;c<e.length;++c)if(enclosesNot(encloseBasis2(e[i],e[c]),aa)&&
enclosesNot(encloseBasis2(e[i],aa),e[c])&&enclosesNot(encloseBasis2(e[c],aa),e[i])&&enclosesWeakAll(encloseBasis3(e[i],e[c],aa),e)){e=[e[i],e[c],aa];break a}throw Error();}a:{e=i=e;switch(e.length){case 1:e=e[0];e={x:e.x,y:e.y,r:e.r};break a;case 2:e=encloseBasis2(e[0],e[1]);break a;case 3:e=encloseBasis3(e[0],e[1],e[2]);break a}e=void 0}c=0}c=e;for(i=0;i<n;++i)a=circles[i],a.x-=c.x,a.y-=c.y;return c.r}function required(f){if("function"!==typeof f)throw Error();return f}function constantZero(){return 0}
function constant(x){return function(){return x}}function defaultRadius(d){return Math.sqrt(d.value)}function radiusLeaf(radius){return function(node){node.children||(node.r=Math.max(0,+radius(node)||0))}}function packChildren(padding,k){return function(node){if(children=node.children){var children,i,n=children.length,r=padding(node)*k||0;if(r)for(i=0;i<n;++i)children[i].r+=r;var e=packEnclose(children);if(r)for(i=0;i<n;++i)children[i].r-=r;node.r=e+r}}}function translateChild(k){return function(node){var parent=
node.parent;node.r*=k;parent&&(node.x=parent.x+k*node.x,node.y=parent.y+k*node.y)}}function roundNode(node){node.x0=Math.round(node.x0);node.y0=Math.round(node.y0);node.x1=Math.round(node.x1);node.y1=Math.round(node.y1)}function treemapDice(parent,x0,y0,x1,y1){var nodes=parent.children,i=-1,n=nodes.length;for(x1=parent.value&&(x1-x0)/parent.value;++i<n;)parent=nodes[i],parent.y0=y0,parent.y1=y1,parent.x0=x0,parent.x1=x0+=parent.value*x1}function defaultId(d){return d.id}function defaultParentId(d){return d.parentId}
function stratify(){function stratify(data){var nodes=Array.from(data),currentId=id,currentParentId=parentId,n,nodeId,nodeByKey=new Map;if(null!=path){const I=nodes.map((d,i)=>{d=path(d,i,data);d=`${d}`;i=d.length;slash(d,i-1)&&!slash(d,i-2)&&(d=d.slice(0,-1));return"/"===d[0]?d:`/${d}`}),P=I.map(parentof);currentId=(new Set(I)).add("");for(node$jscomp$0 of P)currentId.has(node$jscomp$0)||(currentId.add(node$jscomp$0),I.push(node$jscomp$0),P.push(parentof(node$jscomp$0)),nodes.push(imputed));currentId=
(_,i)=>I[i];currentParentId=(_,i)=>P[i]}var i$jscomp$0=0;for(n=nodes.length;i$jscomp$0<n;++i$jscomp$0){var d$jscomp$0=nodes[i$jscomp$0];var node$jscomp$0=nodes[i$jscomp$0]=new Node$1(d$jscomp$0);if(null!=(nodeId=currentId(d$jscomp$0,i$jscomp$0,data))&&(nodeId+="")){var nodeKey=node$jscomp$0.id=nodeId;nodeByKey.set(nodeKey,nodeByKey.has(nodeKey)?ambiguous:node$jscomp$0)}null!=(nodeId=currentParentId(d$jscomp$0,i$jscomp$0,data))&&(nodeId+="")&&(node$jscomp$0.parent=nodeId)}for(i$jscomp$0=0;i$jscomp$0<
n;++i$jscomp$0)if(node$jscomp$0=nodes[i$jscomp$0],nodeId=node$jscomp$0.parent){currentId=nodeByKey.get(nodeId);if(!currentId)throw Error("missing: "+nodeId);if(currentId===ambiguous)throw Error("ambiguous: "+nodeId);currentId.children?currentId.children.push(node$jscomp$0):currentId.children=[node$jscomp$0];node$jscomp$0.parent=currentId}else{if(root)throw Error("multiple roots");var root=node$jscomp$0}if(!root)throw Error("no root");if(null!=path){for(;root.data===imputed&&1===root.children.length;)root=
root.children[0],--n;for(nodeId=nodes.length-1;0<=nodeId;--nodeId){node$jscomp$0=nodes[nodeId];if(node$jscomp$0.data!==imputed)break;node$jscomp$0.data=null}}root.parent=preroot;root.eachBefore(function(node){node.depth=node.parent.depth+1;--n}).eachBefore(computeHeight);root.parent=null;if(0<n)throw Error("cycle");return root}var id=defaultId,parentId=defaultParentId,path;stratify.id=function(x){return arguments.length?(id=null==x?null:required(x),stratify):id};stratify.parentId=function(x){return arguments.length?
(parentId=null==x?null:required(x),stratify):parentId};stratify.path=function(x){return arguments.length?(path=null==x?null:required(x),stratify):path};return stratify}function parentof(path){let i=path.length;if(2>i)return"";for(;1<--i&&!slash(path,i););return path.slice(0,i)}function slash(path,i){if("/"===path[i]){let k=0;for(;0<i&&"\\"===path[--i];)++k;if(0===(k&1))return!0}return!1}function defaultSeparation$1(a,b){return a.parent===b.parent?1:2}function nextLeft(v){var children=v.children;return children?
children[0]:v.t}function nextRight(v){var children=v.children;return children?children[children.length-1]:v.t}function TreeNode(node,i){this._=node;this.A=this.children=this.parent=null;this.a=this;this.s=this.c=this.m=this.z=0;this.t=null;this.i=i}function treeRoot(root){root=new TreeNode(root,0);for(var node,nodes=[root],child,children,i;node=nodes.pop();)if(children=node._.children)for(node.children=Array(child=children.length),i=child-1;0<=i;--i)nodes.push(child=node.children[i]=new TreeNode(children[i],
i)),child.parent=node;(root.parent=new TreeNode(null,0)).children=[root];return root}function treemapSlice(parent,x0,y0,x1,y1){var nodes=parent.children,i=-1,n=nodes.length;for(y1=parent.value&&(y1-y0)/parent.value;++i<n;)parent=nodes[i],parent.x0=x0,parent.x1=x1,parent.y0=y0,parent.y1=y0+=parent.value*y1}function squarifyRatio(ratio,parent,x0,y0,x1,y1){for(var rows=[],nodes=parent.children,row,nodeValue,i1=row=0,n=nodes.length,dy,value=parent.value,sumValue,minValue,maxValue,newRatio,minRatio,alpha;row<
n;){parent=x1-x0;dy=y1-y0;do sumValue=nodes[i1++].value;while(!sumValue&&i1<n);minValue=maxValue=sumValue;alpha=Math.max(dy/parent,parent/dy)/(value*ratio);newRatio=sumValue*sumValue*alpha;for(minRatio=Math.max(maxValue/newRatio,newRatio/minValue);i1<n;++i1){sumValue+=nodeValue=nodes[i1].value;nodeValue<minValue&&(minValue=nodeValue);nodeValue>maxValue&&(maxValue=nodeValue);newRatio=sumValue*sumValue*alpha;newRatio=Math.max(maxValue/newRatio,newRatio/minValue);if(newRatio>minRatio){sumValue-=nodeValue;
break}minRatio=newRatio}rows.push(row={value:sumValue,dice:parent<dy,children:nodes.slice(row,i1)});row.dice?treemapDice(row,x0,y0,x1,value?y0+=dy*sumValue/value:y1):treemapSlice(row,x0,y0,value?x0+=parent*sumValue/value:x1,y1);value-=sumValue;row=i1}return rows}function treemap(){function treemap(root){root.x0=root.y0=0;root.x1=dx;root.y1=dy;root.eachBefore(positionNode);paddingStack=[0];round&&root.eachBefore(roundNode);return root}function positionNode(node){var p=paddingStack[node.depth],x0=node.x0+
p,y0=node.y0+p,x1=node.x1-p,y1=node.y1-p;x1<x0&&(x0=x1=(x0+x1)/2);y1<y0&&(y0=y1=(y0+y1)/2);node.x0=x0;node.y0=y0;node.x1=x1;node.y1=y1;node.children&&(p=paddingStack[node.depth+1]=paddingInner(node)/2,x0+=paddingLeft(node)-p,y0+=paddingTop(node)-p,x1-=paddingRight(node)-p,y1-=paddingBottom(node)-p,x1<x0&&(x0=x1=(x0+x1)/2),y1<y0&&(y0=y1=(y0+y1)/2),tile(node,x0,y0,x1,y1))}var tile=treemapSquarify,round=!1,dx=1,dy=1,paddingStack=[0],paddingInner=constantZero,paddingTop=constantZero,paddingRight=constantZero,
paddingBottom=constantZero,paddingLeft=constantZero;treemap.round=function(x){return arguments.length?(round=!!x,treemap):round};treemap.size=function(x){return arguments.length?(dx=+x[0],dy=+x[1],treemap):[dx,dy]};treemap.tile=function(x){return arguments.length?(tile=required(x),treemap):tile};treemap.padding=function(x){return arguments.length?treemap.paddingInner(x).paddingOuter(x):treemap.paddingInner()};treemap.paddingInner=function(x){return arguments.length?(paddingInner="function"===typeof x?
x:constant(+x),treemap):paddingInner};treemap.paddingOuter=function(x){return arguments.length?treemap.paddingTop(x).paddingRight(x).paddingBottom(x).paddingLeft(x):treemap.paddingTop()};treemap.paddingTop=function(x){return arguments.length?(paddingTop="function"===typeof x?x:constant(+x),treemap):paddingTop};treemap.paddingRight=function(x){return arguments.length?(paddingRight="function"===typeof x?x:constant(+x),treemap):paddingRight};treemap.paddingBottom=function(x){return arguments.length?
(paddingBottom="function"===typeof x?x:constant(+x),treemap):paddingBottom};treemap.paddingLeft=function(x){return arguments.length?(paddingLeft="function"===typeof x?x:constant(+x),treemap):paddingLeft};return treemap}function Nest(params){vegaDataflow.Transform.call(this,null,params)}function nest(){function apply(array,depth){if(depth>=keys.length)return array;const n=array.length,key=keys[depth++],valuesByKey={},result={};let i=-1,keyValue,value,values;for(;++i<n;)keyValue=key(value=array[i])+
"",(values=valuesByKey[keyValue])?values.push(value):valuesByKey[keyValue]=[value];for(keyValue in valuesByKey)result[keyValue]=apply(valuesByKey[keyValue],depth);return result}function entries(map,depth){if(++depth>keys.length)return map;const array=[];for(const key in map)array.push({key,values:entries(map[key],depth)});return array}const keys=[],nest={entries:array=>entries(apply(array,0),0),key:d=>(keys.push(d),nest)};return nest}function HierarchyLayout(params){vegaDataflow.Transform.call(this,
null,params)}function setParams(layout,params,_){for(let p,i=0,n=params.length;i<n;++i)if(p=params[i],p in _)layout[p](_[p])}function Pack(params){HierarchyLayout.call(this,params)}function Partition(params){HierarchyLayout.call(this,params)}function Stratify(params){vegaDataflow.Transform.call(this,null,params)}function Tree(params){HierarchyLayout.call(this,params)}function TreeLinks(params){vegaDataflow.Transform.call(this,[],params)}function Treemap(params){HierarchyLayout.call(this,params)}Node$1.prototype=
hierarchy.prototype={constructor:Node$1,count:function(){return this.eachAfter(count)},each:function(callback,that){let index=-1;for(const node of this)callback.call(that,node,++index,this);return this},eachAfter:function(callback,that){for(var node,nodes=[this],next=[],i,n,index=-1;node=nodes.pop();)if(next.push(node),node=node.children)for(i=0,n=node.length;i<n;++i)nodes.push(node[i]);for(;node=next.pop();)callback.call(that,node,++index,this);return this},eachBefore:function(callback,that){for(var node,
nodes=[this],i,index=-1;node=nodes.pop();)if(callback.call(that,node,++index,this),node=node.children)for(i=node.length-1;0<=i;--i)nodes.push(node[i]);return this},find:function(callback,that){let index=-1;for(const node of this)if(callback.call(that,node,++index,this))return node},sum:function(value){return this.eachAfter(function(node){for(var sum=+value(node.data)||0,children=node.children,i=children&&children.length;0<=--i;)sum+=children[i].value;node.value=sum})},sort:function(compare){return this.eachBefore(function(node){node.children&&
node.children.sort(compare)})},path:function(end){var start=this;var ancestor=start;var b=end;if(ancestor!==b){var aNodes=ancestor.ancestors(),bNodes=b.ancestors(),c=null;ancestor=aNodes.pop();for(b=bNodes.pop();ancestor===b;)c=ancestor,ancestor=aNodes.pop(),b=bNodes.pop();ancestor=c}for(b=[start];start!==ancestor;)start=start.parent,b.push(start);for(start=b.length;end!==ancestor;)b.splice(start,0,end),end=end.parent;return b},ancestors:function(){for(var node=this,nodes=[node];node=node.parent;)nodes.push(node);
return nodes},descendants:function(){return Array.from(this)},leaves:function(){var leaves=[];this.eachBefore(function(node){node.children||leaves.push(node)});return leaves},links:function(){var root=this,links=[];root.each(function(node){node!==root&&links.push({source:node.parent,target:node})});return links},copy:function(){return hierarchy(this).eachBefore(copyData)},[Symbol.iterator]:function*(){var node,next=[this],n;do{var current=next.reverse();for(next=[];node=current.pop();)if(yield node,
node=node.children){var i=0;for(n=node.length;i<n;++i)next.push(node[i])}}while(next.length)}};var preroot={depth:-1},ambiguous={},imputed={};TreeNode.prototype=Object.create(Node$1.prototype);var phi=(1+Math.sqrt(5))/2,treemapSquarify=function custom(ratio){function squarify(parent,x0,y0,x1,y1){squarifyRatio(ratio,parent,x0,y0,x1,y1)}squarify.ratio=function(x){return custom(1<(x=+x)?x:1)};return squarify}(phi);phi=function custom(ratio){function resquarify(parent,x0,y0,x1,y1){if((rows=parent._squarify)&&
rows.ratio===ratio)for(var rows,nodes,i,j=-1,n,m=rows.length,value=parent.value;++j<m;){parent=rows[j];nodes=parent.children;i=parent.value=0;for(n=nodes.length;i<n;++i)parent.value+=nodes[i].value;parent.dice?treemapDice(parent,x0,y0,x1,value?y0+=(y1-y0)*parent.value/value:y1):treemapSlice(parent,x0,y0,value?x0+=(x1-x0)*parent.value/value:x1,y1);value-=parent.value}else parent._squarify=rows=squarifyRatio(ratio,parent,x0,y0,x1,y1),rows.ratio=ratio}resquarify.ratio=function(x){return custom(1<(x=
+x)?x:1)};return resquarify}(phi);Nest.Definition={type:"Nest",metadata:{treesource:!0,changes:!0},params:[{name:"keys",type:"field",array:!0},{name:"generate",type:"boolean"}]};const children$jscomp$1=n=>n.values;vegaUtil.inherits(Nest,vegaDataflow.Transform,{transform(_,pulse){pulse.source||vegaUtil.error("Nest transform requires an upstream data source.");var gen=_.generate,mod=_.modified(),out=pulse.clone(),tree=this.value;if(!tree||mod||pulse.changed())tree&&tree.each(node=>{node.children&&vegaDataflow.isTuple(node.data)&&
out.rem.push(node.data)}),this.value=tree=hierarchy({values:vegaUtil.array(_.keys).reduce((n,k)=>{n.key(k);return n},nest()).entries(out.source)},children$jscomp$1),gen&&tree.each(node=>{node.children&&(node=vegaDataflow.ingest(node.data),out.add.push(node),out.source.push(node))}),lookup(tree,vegaDataflow.tupleid,vegaDataflow.tupleid);out.source.root=tree;return out}});const defaultSeparation=(a,b)=>a.parent===b.parent?1:2;vegaUtil.inherits(HierarchyLayout,vegaDataflow.Transform,{transform(_,pulse){pulse.source&&
pulse.source.root||vegaUtil.error(this.constructor.name+" transform requires a backing tree data source.");const layout=this.layout(_.method),fields=this.fields,root=pulse.source.root,as=_.as||fields;_.field?root.sum(_.field):root.count();_.sort&&root.sort(vegaDataflow.stableCompare(_.sort,d=>d.data));setParams(layout,this.params,_);layout.separation&&layout.separation(!1!==_.separation?defaultSeparation:vegaUtil.one);try{this.value=layout(root)}catch(err){vegaUtil.error(err)}root.each(node=>{const t=
node.data,n=fields.length-1;for(let i=0;i<n;++i)t[as[i]]=node[fields[i]];t[as[n]]=node.children?node.children.length:0});return pulse.reflow(_.modified()).modifies(as).modifies("leaf")}});var Output$3=["x","y","r","depth","children"];Pack.Definition={type:"Pack",metadata:{tree:!0,modifies:!0},params:[{name:"field",type:"field"},{name:"sort",type:"compare"},{name:"padding",type:"number","default":0},{name:"radius",type:"field","default":null},{name:"size",type:"number",array:!0,length:2},{name:"as",
type:"string",array:!0,length:Output$3.length,"default":Output$3}]};vegaUtil.inherits(Pack,HierarchyLayout,{layout:function(){function pack(root){root.x=dx/2;root.y=dy/2;radius?root.eachBefore(radiusLeaf(radius)).eachAfter(packChildren(padding,.5)).eachBefore(translateChild(1)):root.eachBefore(radiusLeaf(defaultRadius)).eachAfter(packChildren(constantZero,1)).eachAfter(packChildren(padding,root.r/Math.min(dx,dy))).eachBefore(translateChild(Math.min(dx,dy)/(2*root.r)));return root}var radius=null,
dx=1,dy=1,padding=constantZero;pack.radius=function(x){return arguments.length?(radius=null==x?null:required(x),pack):radius};pack.size=function(x){return arguments.length?(dx=+x[0],dy=+x[1],pack):[dx,dy]};pack.padding=function(x){return arguments.length?(padding="function"===typeof x?x:constant(+x),pack):padding};return pack},params:["radius","size","padding"],fields:Output$3});Output$3="x0 y0 x1 y1 depth children".split(" ");Partition.Definition={type:"Partition",metadata:{tree:!0,modifies:!0},
params:[{name:"field",type:"field"},{name:"sort",type:"compare"},{name:"padding",type:"number","default":0},{name:"round",type:"boolean","default":!1},{name:"size",type:"number",array:!0,length:2},{name:"as",type:"string",array:!0,length:Output$3.length,"default":Output$3}]};vegaUtil.inherits(Partition,HierarchyLayout,{layout:function(){function partition(root){var n=root.height+1;root.x0=root.y0=padding;root.x1=dx;root.y1=dy$jscomp$0/n;root.eachBefore(positionNode(dy$jscomp$0,n));round&&root.eachBefore(roundNode);
return root}function positionNode(dy,n){return function(node){node.children&&treemapDice(node,node.x0,dy*(node.depth+1)/n,node.x1,dy*(node.depth+2)/n);var x0=node.x0,y0=node.y0,x1=node.x1-padding,y1=node.y1-padding;x1<x0&&(x0=x1=(x0+x1)/2);y1<y0&&(y0=y1=(y0+y1)/2);node.x0=x0;node.y0=y0;node.x1=x1;node.y1=y1}}var dx=1,dy$jscomp$0=1,padding=0,round=!1;partition.round=function(x){return arguments.length?(round=!!x,partition):round};partition.size=function(x){return arguments.length?(dx=+x[0],dy$jscomp$0=
+x[1],partition):[dx,dy$jscomp$0]};partition.padding=function(x){return arguments.length?(padding=+x,partition):padding};return partition},params:["size","round","padding"],fields:Output$3});Stratify.Definition={type:"Stratify",metadata:{treesource:!0},params:[{name:"key",type:"field",required:!0},{name:"parentKey",type:"field",required:!0}]};vegaUtil.inherits(Stratify,vegaDataflow.Transform,{transform(_,pulse){pulse.source||vegaUtil.error("Stratify transform requires an upstream data source.");let tree=
this.value;const mod=_.modified(),out=pulse.fork(pulse.ALL).materialize(pulse.SOURCE);pulse=!tree||mod||pulse.changed(pulse.ADD_REM)||pulse.modified(_.key.fields)||pulse.modified(_.parentKey.fields);out.source=out.source.slice();pulse&&(tree=out.source.length?lookup(stratify().id(_.key).parentId(_.parentKey)(out.source),_.key,vegaUtil.truthy):lookup(stratify()([{}]),_.key,_.key));out.source.root=this.value=tree;return out}});const Layouts={tidy:function(){function tree(root){var t=treeRoot(root);
t.eachAfter(firstWalk);t.parent.m=-t.z;t.eachBefore(secondWalk);if(nodeSize)root.eachBefore(sizeNode);else{var left=root,right=root,bottom=root;root.eachBefore(function(node){node.x<left.x&&(left=node);node.x>right.x&&(right=node);node.depth>bottom.depth&&(bottom=node)});t=left===right?1:separation(left,right)/2;var tx=t-left.x,kx=dx/(right.x+t+tx),ky=dy/(bottom.depth||1);root.eachBefore(function(node){node.x=(node.x+tx)*kx;node.y=node.depth*ky})}return root}function firstWalk(v){var children=v.children,
siblings=v.parent.children,w=v.i?siblings[v.i-1]:null;if(children){for(var shift=0,change=0,children$jscomp$0=v.children,i=children$jscomp$0.length,w$jscomp$0;0<=--i;)w$jscomp$0=children$jscomp$0[i],w$jscomp$0.z+=shift,w$jscomp$0.m+=shift,shift+=w$jscomp$0.s+(change+=w$jscomp$0.c);children=(children[0].z+children[children.length-1].z)/2;w?(v.z=w.z+separation(v._,w._),v.m=v.z-children):v.z=children}else w&&(v.z=w.z+separation(v._,w._));children=v.parent;siblings=v.parent.A||siblings[0];if(w){change=
shift=v;children$jscomp$0=shift.parent.children[0];i=shift.m;w$jscomp$0=change.m;for(var sim=w.m,som=children$jscomp$0.m,shift$jscomp$0;w=nextRight(w),shift=nextLeft(shift),w&&shift;){children$jscomp$0=nextLeft(children$jscomp$0);change=nextRight(change);change.a=v;shift$jscomp$0=w.z+sim-shift.z-i+separation(w._,shift._);if(0<shift$jscomp$0){var wm=w.a.parent===v.parent?w.a:siblings,wp=v,shift$jscomp$1=shift$jscomp$0,change$jscomp$0=shift$jscomp$1/(wp.i-wm.i);wp.c-=change$jscomp$0;wp.s+=shift$jscomp$1;
wm.c+=change$jscomp$0;wp.z+=shift$jscomp$1;wp.m+=shift$jscomp$1;i+=shift$jscomp$0;w$jscomp$0+=shift$jscomp$0}sim+=w.m;i+=shift.m;som+=children$jscomp$0.m;w$jscomp$0+=change.m}w&&!nextRight(change)&&(change.t=w,change.m+=sim-w$jscomp$0);shift&&!nextLeft(children$jscomp$0)&&(children$jscomp$0.t=shift,children$jscomp$0.m+=i-som,siblings=v)}children.A=siblings}function secondWalk(v){v._.x=v.z+v.parent.m;v.m+=v.parent.m}function sizeNode(node){node.x*=dx;node.y=node.depth*dy}var separation=defaultSeparation$1,
dx=1,dy=1,nodeSize=null;tree.separation=function(x){return arguments.length?(separation=x,tree):separation};tree.size=function(x){return arguments.length?(nodeSize=!1,dx=+x[0],dy=+x[1],tree):nodeSize?null:[dx,dy]};tree.nodeSize=function(x){return arguments.length?(nodeSize=!0,dx=+x[0],dy=+x[1],tree):nodeSize?[dx,dy]:null};return tree},cluster:function(){function cluster(root){var previousNode,x=0;root.eachAfter(function(node){var children=node.children;if(children){var JSCompiler_inline_result=children.reduce(meanXReduce,
0)/children.length;node.x=JSCompiler_inline_result;node.y=1+children.reduce(maxYReduce,0)}else node.x=previousNode?x+=separation(node,previousNode):0,node.y=0,previousNode=node});var left=leafLeft(root),right=leafRight(root),x0=left.x-separation(left,right)/2,x1=right.x+separation(right,left)/2;return root.eachAfter(nodeSize?function(node){node.x=(node.x-root.x)*dx;node.y=(root.y-node.y)*dy}:function(node){node.x=(node.x-x0)/(x1-x0)*dx;node.y=(1-(root.y?node.y/root.y:1))*dy})}var separation=defaultSeparation$2,
dx=1,dy=1,nodeSize=!1;cluster.separation=function(x){return arguments.length?(separation=x,cluster):separation};cluster.size=function(x){return arguments.length?(nodeSize=!1,dx=+x[0],dy=+x[1],cluster):nodeSize?null:[dx,dy]};cluster.nodeSize=function(x){return arguments.length?(nodeSize=!0,dx=+x[0],dy=+x[1],cluster):nodeSize?[dx,dy]:null};return cluster}};Output$3=["x","y","depth","children"];Tree.Definition={type:"Tree",metadata:{tree:!0,modifies:!0},params:[{name:"field",type:"field"},{name:"sort",
type:"compare"},{name:"method",type:"enum","default":"tidy",values:["tidy","cluster"]},{name:"size",type:"number",array:!0,length:2},{name:"nodeSize",type:"number",array:!0,length:2},{name:"separation",type:"boolean","default":!0},{name:"as",type:"string",array:!0,length:Output$3.length,"default":Output$3}]};vegaUtil.inherits(Tree,HierarchyLayout,{layout(method){method=method||"tidy";if(vegaUtil.hasOwnProperty(Layouts,method))return Layouts[method]();vegaUtil.error("Unrecognized Tree layout method: "+
method)},params:["size","nodeSize"],fields:Output$3});TreeLinks.Definition={type:"TreeLinks",metadata:{tree:!0,generates:!0,changes:!0},params:[]};vegaUtil.inherits(TreeLinks,vegaDataflow.Transform,{transform(_,pulse){_=this.value;const tree=pulse.source&&pulse.source.root,out=pulse.fork(pulse.NO_SOURCE),lut={};tree||vegaUtil.error("TreeLinks transform requires a tree data source.");pulse.changed(pulse.ADD_REM)?(out.rem=_,pulse.visit(pulse.SOURCE,t=>lut[vegaDataflow.tupleid(t)]=1),tree.each(node=>
{const t=node.data;(node=node.parent&&node.parent.data)&&lut[vegaDataflow.tupleid(t)]&&lut[vegaDataflow.tupleid(node)]&&out.add.push(vegaDataflow.ingest({source:node,target:t}))}),this.value=out.add):pulse.changed(pulse.MOD)&&(pulse.visit(pulse.MOD,t=>lut[vegaDataflow.tupleid(t)]=1),_.forEach(link=>{(lut[vegaDataflow.tupleid(link.source)]||lut[vegaDataflow.tupleid(link.target)])&&out.mod.push(link)}));return out}});const Tiles={binary:function(parent,x0$jscomp$0,y0$jscomp$0,x1$jscomp$0,y1$jscomp$0){function partition(i,
j,value,x0,y0,x1,y1){if(i>=j-1)i=nodes[i],i.x0=x0,i.y0=y0,i.x1=x1,i.y1=y1;else{for(var valueOffset=sums[i],valueTarget=value/2+valueOffset,k=i+1,hi=j-1;k<hi;){var mid=k+hi>>>1;sums[mid]<valueTarget?k=mid+1:hi=mid}valueTarget-sums[k-1]<sums[k]-valueTarget&&i+1<k&&--k;valueOffset=sums[k]-valueOffset;valueTarget=value-valueOffset;x1-x0>y1-y0?(value=value?(x0*valueTarget+x1*valueOffset)/value:x1,partition(i,k,valueOffset,x0,y0,value,y1),partition(k,j,valueTarget,value,y0,x1,y1)):(value=value?(y0*valueTarget+
y1*valueOffset)/value:y1,partition(i,k,valueOffset,x0,y0,x1,value),partition(k,j,valueTarget,x0,value,x1,y1))}}var nodes=parent.children,i$jscomp$0,n=nodes.length,sum,sums=Array(n+1);for(sums[0]=sum=i$jscomp$0=0;i$jscomp$0<n;++i$jscomp$0)sums[i$jscomp$0+1]=sum+=nodes[i$jscomp$0].value;partition(0,n,parent.value,x0$jscomp$0,y0$jscomp$0,x1$jscomp$0,y1$jscomp$0)},dice:treemapDice,slice:treemapSlice,slicedice:function(parent,x0,y0,x1,y1){(parent.depth&1?treemapSlice:treemapDice)(parent,x0,y0,x1,y1)},
squarify:treemapSquarify,resquarify:phi};phi="x0 y0 x1 y1 depth children".split(" ");Treemap.Definition={type:"Treemap",metadata:{tree:!0,modifies:!0},params:[{name:"field",type:"field"},{name:"sort",type:"compare"},{name:"method",type:"enum","default":"squarify",values:"squarify resquarify binary dice slice slicedice".split(" ")},{name:"padding",type:"number","default":0},{name:"paddingInner",type:"number","default":0},{name:"paddingOuter",type:"number","default":0},{name:"paddingTop",type:"number",
"default":0},{name:"paddingRight",type:"number","default":0},{name:"paddingBottom",type:"number","default":0},{name:"paddingLeft",type:"number","default":0},{name:"ratio",type:"number","default":1.618033988749895},{name:"round",type:"boolean","default":!1},{name:"size",type:"number",array:!0,length:2},{name:"as",type:"string",array:!0,length:phi.length,"default":phi}]};vegaUtil.inherits(Treemap,HierarchyLayout,{layout(){const x=treemap();x.ratio=_=>{const t=x.tile();t.ratio&&x.tile(t.ratio(_))};x.method=
_=>{vegaUtil.hasOwnProperty(Tiles,_)?x.tile(Tiles[_]):vegaUtil.error("Unrecognized Treemap layout method: "+_)};return x},params:"method ratio size round padding paddingInner paddingOuter paddingTop paddingRight paddingBottom paddingLeft".split(" "),fields:phi});exports.nest=Nest;exports.pack=Pack;exports.partition=Partition;exports.stratify=Stratify;exports.tree=Tree;exports.treelinks=TreeLinks;exports.treemap=Treemap;Object.defineProperty(exports,"__esModule",{value:!0})})}
//# sourceMappingURL=module$node_modules$vega_hierarchy$build$vega_hierarchy.js.map
