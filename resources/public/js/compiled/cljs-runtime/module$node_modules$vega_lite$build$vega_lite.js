shadow$provide.module$node_modules$vega_lite$build$vega_lite=function(global$jscomp$0,require,module$jscomp$0,exports$jscomp$0){var Buffer=require("module$node_modules$buffer$index").Buffer;(function(global,factory){"object"===typeof exports$jscomp$0&&"undefined"!==typeof module$jscomp$0?factory(exports$jscomp$0,require("module$node_modules$vega$build$vega_node")):"function"===typeof define&&define.amd?define(["exports","vega"],factory):(global="undefined"!==typeof globalThis?globalThis:global||self,
factory(global.vegaLite={},global.vega))})(this,function(exports,vega){function forEachLeaf(op,fn){if(op.not)forEachLeaf(op.not,fn);else if(op.and)for(const subop of op.and)forEachLeaf(subop,fn);else if(op.or)for(const subop of op.or)forEachLeaf(subop,fn);else fn(op)}function normalizeLogicalComposition(op,normalizer){return op.not?{not:normalizeLogicalComposition(op.not,normalizer)}:op.and?{and:op.and.map(o=>normalizeLogicalComposition(o,normalizer))}:op.or?{or:op.or.map(o=>normalizeLogicalComposition(o,
normalizer))}:normalizer(op)}function never(message){throw Error(message);}function pick(obj,props){const copy={};for(const prop of props)vega.hasOwnProperty(obj,prop)&&(copy[prop]=obj[prop]);return copy}function omit(obj,props){obj={...obj};for(const prop of props)delete obj[prop];return obj}function hash(a){if(vega.isNumber(a))return a;a=vega.isString(a)?a:fastJsonStableStringify(a);if(250>a.length)return a;let h=0;for(let i=0;i<a.length;i++){const char=a.charCodeAt(i);h=(h<<5)-h+char;h&=h}return h}
function isNullOrFalse(x){return!1===x||null===x}function contains(array,item){return array.includes(item)}function some(arr,f){let i=0;for(const [k,a]of arr.entries())if(f(a,k,i++))return!0;return!1}function every(arr,f){let i=0;for(const [k,a]of arr.entries())if(!f(a,k,i++))return!1;return!0}function mergeDeep(dest){for(var _len=arguments.length,src=Array(1<_len?_len-1:0),_key=1;_key<_len;_key++)src[_key-1]=arguments[_key];for(const s of src){_len=dest;src=s??{};for(const property of keys$jscomp$0(src))vega.writeConfig(_len,
property,src[property],!0)}return dest}function unique(values,f){const results=[],u={};for(const val of values)values=f(val),values in u||(u[values]=1,results.push(val));return results}function setEqual(a,b){if(a.size!==b.size)return!1;for(const e of a)if(!b.has(e))return!1;return!0}function hasIntersection(a,b){for(const key of a)if(b.has(key))return!0;return!1}function prefixGenerator(a){const prefixes=new Set;for(const x of a){const wrappedWithAccessors=vega.splitAccessPath(x).map((y,i)=>0===i?
y:`[${y}]`);a=wrappedWithAccessors.map((_,i)=>wrappedWithAccessors.slice(0,i+1).join(""));for(const y of a)prefixes.add(y)}return prefixes}function fieldIntersection(a,b){return void 0===a||void 0===b?!0:hasIntersection(prefixGenerator(a),prefixGenerator(b))}function isEmpty(obj){return 0===keys$jscomp$0(obj).length}function isBoolean(b){return!0===b||!1===b}function varName(s){const alphanumericS=s.replace(/\W/g,"_");return(s.match(/^\d+/)?"_":"")+alphanumericS}function logicalExpr(op,cb){return op.not?
`!(${logicalExpr(op.not,cb)})`:op.and?`(${op.and.map(and=>logicalExpr(and,cb)).join(") \x26\x26 (")})`:op.or?`(${op.or.map(or=>logicalExpr(or,cb)).join(") || (")})`:cb(op)}function deleteNestedProperty(obj,orderedProps){if(0===orderedProps.length)return!0;const prop=orderedProps.shift();prop in obj&&deleteNestedProperty(obj[prop],orderedProps)&&delete obj[prop];return isEmpty(obj)}function titleCase(s){return s.charAt(0).toUpperCase()+s.substr(1)}function accessPathWithDatum(path){let datum=1<arguments.length&&
void 0!==arguments[1]?arguments[1]:"datum";const pieces=vega.splitAccessPath(path),prefixes=[];for(let i=1;i<=pieces.length;i++){const prefix=`[${pieces.slice(0,i).map(vega.stringValue).join("][")}]`;prefixes.push(`${datum}${prefix}`)}return prefixes.join(" \x26\x26 ")}function flatAccessWithDatum(path){return`${1<arguments.length&&void 0!==arguments[1]?arguments[1]:"datum"}[${vega.stringValue(vega.splitAccessPath(path).join("."))}]`}function escapePathAccess(string){return string.replace(/(\[|\]|\.|'|")/g,
"\\$1")}function replacePathInField(path){return`${vega.splitAccessPath(path).map(escapePathAccess).join("\\.")}`}function replaceAll(string,find,replacement){return string.replace(new RegExp(find.replace(/[-/\\^$*+?.()|[\]{}]/g,"\\$\x26"),"g"),replacement)}function removePathFromField(path){return`${vega.splitAccessPath(path).join(".")}`}function accessPathDepth(path){return path?vega.splitAccessPath(path).length:0}function getFirstDefined(){for(var _len2=arguments.length,args=Array(_len2),_key2=
0;_key2<_len2;_key2++)args[_key2]=arguments[_key2];for(const arg of args)if(void 0!==arg)return arg}function uniqueId(prefix){const id=++idCounter;return prefix?String(prefix)+id:id}function internalField(name){return isInternalField(name)?name:`__${name}`}function isInternalField(name){return name.startsWith("__")}function normalizeAngle(angle){if(void 0!==angle)return(angle%360+360)%360}function isNumeric(value){return vega.isNumber(value)?!0:!isNaN(value)&&!isNaN(parseFloat(value))}function getPositionChannelFromLatLong(channel){switch(channel){case "latitude":return"y";
case "latitude2":return"y2";case "longitude":return"x";case "longitude2":return"x2"}}function isColorChannel(channel){return"color"===channel||"fill"===channel||"stroke"===channel}function isSecondaryRangeChannel(c){return getMainRangeChannel(c)!==c}function getMainRangeChannel(channel){switch(channel){case "x2":return"x";case "y2":return"y";case "latitude2":return"latitude";case "longitude2":return"longitude";case "theta2":return"theta";case "radius2":return"radius"}return channel}function getVgPositionChannel(channel){if(channel in
POLAR_POSITION_CHANNEL_INDEX)switch(channel){case "theta":return"startAngle";case "theta2":return"endAngle";case "radius":return"outerRadius";case "radius2":return"innerRadius"}return channel}function getSecondaryRangeChannel(channel){switch(channel){case "x":return"x2";case "y":return"y2";case "latitude":return"latitude2";case "longitude":return"longitude2";case "theta":return"theta2";case "radius":return"radius2"}}function getSizeChannel(channel){switch(channel){case "x":case "x2":return"width";
case "y":case "y2":return"height"}}function getOffsetChannel(channel){switch(channel){case "x":return"xOffset";case "y":return"yOffset";case "x2":return"x2Offset";case "y2":return"y2Offset";case "theta":return"thetaOffset";case "radius":return"radiusOffset";case "theta2":return"theta2Offset";case "radius2":return"radius2Offset"}}function getOffsetScaleChannel(channel){switch(channel){case "x":return"xOffset";case "y":return"yOffset"}}function getMainChannelFromOffsetChannel(channel){switch(channel){case "xOffset":return"x";
case "yOffset":return"y"}}function isXorY(channel){return channel in POSITION_SCALE_CHANNEL_INDEX}function getPositionScaleChannel(sizeType){return"width"===sizeType?"x":"y"}function getSupportedMark(channel){switch(channel){case "color":case "fill":case "stroke":case "description":case "detail":case "key":case "tooltip":case "href":case "order":case "opacity":case "fillOpacity":case "strokeOpacity":case "strokeWidth":case "facet":case "row":case "column":return ALL_MARKS;case "x":case "y":case "xOffset":case "yOffset":case "latitude":case "longitude":return ALL_MARKS_EXCEPT_GEOSHAPE;
case "x2":case "y2":case "latitude2":case "longitude2":return{area:"always",bar:"always",image:"always",rect:"always",rule:"always",circle:"binned",point:"binned",square:"binned",tick:"binned",line:"binned",trail:"binned"};case "size":return{point:"always",tick:"always",rule:"always",circle:"always",square:"always",bar:"always",text:"always",line:"always",trail:"always"};case "strokeDash":return{line:"always",point:"always",tick:"always",rule:"always",circle:"always",square:"always",bar:"always",
geoshape:"always"};case "shape":return{point:"always",geoshape:"always"};case "text":return{text:"always"};case "angle":return{point:"always",square:"always",text:"always"};case "url":return{image:"always"};case "theta":return{text:"always",arc:"always"};case "radius":return{text:"always",arc:"always"};case "theta2":case "radius2":return{arc:"always"}}}function rangeType(channel){switch(channel){case "facet":case "row":case "column":case "shape":case "strokeDash":case "text":case "tooltip":case "href":case "url":case "description":return"discrete";
case "color":case "fill":case "stroke":return"flexible"}}function isArgminDef(a){return!!a&&!!a.argmin}function isArgmaxDef(a){return!!a&&!!a.argmax}function isAggregateOp(a){return vega.isString(a)&&!!AGGREGATE_OP_INDEX[a]}function isCountingAggregateOp(aggregate){return vega.isString(aggregate)&&COUNTING_OPS.has(aggregate)}function binToString(bin){vega.isBoolean(bin)&&(bin=normalizeBin(bin,void 0));return"bin"+keys$jscomp$0(bin).map(p=>bin[p]?.param?varName(`_${p}_${entries$1(bin[p])}`):varName(`_${p}_${bin[p]}`)).join("")}
function isBinning(bin){return!0===bin||vega.isObject(bin)&&!bin.binned}function isBinned(bin){return"binned"===bin||vega.isObject(bin)&&!0===bin.binned}function autoMaxBins(channel){switch(channel){case "row":case "column":case "size":case "color":case "fill":case "stroke":case "strokeWidth":case "opacity":case "fillOpacity":case "strokeOpacity":case "shape":return 6;case "strokeDash":return 4;default:return 10}}function replaceExprRef(index){const props=keys$jscomp$0(index||{}),newIndex={};for(const prop of props)newIndex[prop]=
signalRefOrValue(index[prop]);return newIndex}function extractTitleConfig(titleConfig){const {anchor,frame,offset,orient,angle,limit,color,subtitleColor,subtitleFont,subtitleFontSize,subtitleFontStyle,subtitleFontWeight,subtitleLineHeight,subtitlePadding,...rest}=titleConfig,titleMarkConfig={...rest,...(color?{fill:color}:{})},nonMarkTitleProperties={...(anchor?{anchor}:{}),...(frame?{frame}:{}),...(offset?{offset}:{}),...(orient?{orient}:{}),...(void 0!==angle?{angle}:{}),...(void 0!==limit?{limit}:
{})},subtitle={...(subtitleColor?{subtitleColor}:{}),...(subtitleFont?{subtitleFont}:{}),...(subtitleFontSize?{subtitleFontSize}:{}),...(subtitleFontStyle?{subtitleFontStyle}:{}),...(subtitleFontWeight?{subtitleFontWeight}:{}),...(subtitleLineHeight?{subtitleLineHeight}:{}),...(subtitlePadding?{subtitlePadding}:{})};titleConfig=pick(titleConfig,["align","baseline","dx","dy","limit"]);return{titleMarkConfig,subtitleMarkConfig:titleConfig,nonMarkTitleProperties,subtitle}}function isText(v){return vega.isString(v)||
vega.isArray(v)&&vega.isString(v[0])}function isSignalRef(o){return!!o?.signal}function isVgRangeStep(range){return!!range.step}function isDataRefDomain(domain){return vega.isArray(domain)?!1:"field"in domain&&"data"in domain}function signalOrValueRefWithCondition(val){const condition=vega.isArray(val.condition)?val.condition.map(conditionalSignalRefOrValue):conditionalSignalRefOrValue(val.condition);return{...signalRefOrValue(val),condition}}function signalRefOrValue(value){if(value?.expr){const {expr,
...rest}=value;return{signal:expr,...rest}}return value}function conditionalSignalRefOrValue(value){if(value?.expr){const {expr,...rest}=value;return{signal:expr,...rest}}return value}function signalOrValueRef(value){if(value?.expr){const {expr,...rest}=value;return{signal:expr,...rest}}return isSignalRef(value)?value:void 0!==value?{value}:void 0}function exprFromValueRefOrSignalRef(ref){return isSignalRef(ref)?ref.signal:vega.stringValue(ref.value)}function signalOrStringValue(v){return isSignalRef(v)?
v.signal:null==v?null:vega.stringValue(v)}function getMarkPropOrConfig(channel,mark,config){let opt=3<arguments.length&&void 0!==arguments[3]?arguments[3]:{};const {vgChannel,ignoreVgConfig}=opt;if(vgChannel&&void 0!==mark[vgChannel])return mark[vgChannel];if(void 0!==mark[channel])return mark[channel];if(!ignoreVgConfig||vgChannel&&vgChannel!==channel)return getMarkConfig(channel,mark,config,opt)}function getMarkConfig(channel,mark,config){let {vgChannel}=3<arguments.length&&void 0!==arguments[3]?
arguments[3]:{};return getFirstDefined(vgChannel?getMarkStyleConfig(channel,mark,config.style):void 0,getMarkStyleConfig(channel,mark,config.style),vgChannel?config[mark.type][vgChannel]:void 0,config[mark.type][channel],vgChannel?config.mark[vgChannel]:config.mark[channel])}function getMarkStyleConfig(prop,mark,styleConfigIndex){return getStyleConfig(prop,[].concat(mark.type,mark.style??[]),styleConfigIndex)}function getStyleConfig(p,styles,styleConfigIndex){styles=vega.array(styles);let value;for(const style of styles)(styles=
styleConfigIndex[style])&&void 0!==styles[p]&&(value=styles[p]);return value}function sortParams(orderDef,fieldRefOption){return vega.array(orderDef).reduce((s,orderChannelDef)=>{s.field.push(vgField(orderChannelDef,fieldRefOption));s.order.push(orderChannelDef.sort??"ascending");return s},{field:[],order:[]})}function mergeTitleFieldDefs(f1,f2){const merged=[...f1];f2.forEach(fdToMerge=>{for(const fieldDef1 of merged)if(deepEqual(fieldDef1,fdToMerge))return;merged.push(fdToMerge)});return merged}
function mergeTitle(title1,title2){return deepEqual(title1,title2)||!title2?title1:title1?[...vega.array(title1),...vega.array(title2)].join(", "):title2}function mergeTitleComponent(v1,v2){const v1Val=v1.value;v2=v2.value;if(null==v1Val||null===v2)return{explicit:v1.explicit,value:null};if((isText(v1Val)||isSignalRef(v1Val))&&(isText(v2)||isSignalRef(v2)))return{explicit:v1.explicit,value:mergeTitle(v1Val,v2)};if(isText(v1Val)||isSignalRef(v1Val))return{explicit:v1.explicit,value:v1Val};if(isText(v2)||
isSignalRef(v2))return{explicit:v1.explicit,value:v2};if(!(isText(v1Val)||isSignalRef(v1Val)||isText(v2)||isSignalRef(v2)))return{explicit:v1.explicit,value:mergeTitleFieldDefs(v1Val,v2)};throw Error("It should never reach here");}function _defineProperty(obj,key,value){a:if("object"===typeof key&&null!==key){var prim=key[Symbol.toPrimitive];if(void 0!==prim){key=prim.call(key,"string");if("object"!==typeof key)break a;throw new TypeError("@@toPrimitive must return a primitive value.");}key=String(key)}key=
"symbol"===typeof key?key:String(key);key in obj?Object.defineProperty(obj,key,{value,enumerable:!0,configurable:!0,writable:!0}):obj[key]=value;return obj}function _classPrivateFieldSet(receiver,privateMap,value){privateMap=_classExtractFieldDescriptor(receiver,privateMap,"set");if(privateMap.set)privateMap.set.call(receiver,value);else{if(!privateMap.writable)throw new TypeError("attempted to set read only private field");privateMap.value=value}return value}function _classExtractFieldDescriptor(receiver,
privateMap,action){if(!privateMap.has(receiver))throw new TypeError("attempted to "+action+" private field on non-instance");return privateMap.get(receiver)}function invalidSpec(spec){return`Invalid specification ${stringify(spec)}. Make sure the specification includes at least one of the following properties: "mark", "layer", "facet", "hconcat", "vconcat", "concat", or "repeat".`}function containerSizeNonSingle(name){return`${"width"==name?"Width":"Height"} "container" only works for single views and layered views.`}
function containerSizeNotCompatibleWithAutosize(name){return`${"width"==name?"Width":"Height"} "container" only works well with autosize "fit" or "fit-${"width"==name?"x":"y"}".`}function droppingFit(channel){return channel?`Dropping "fit-${channel}" because spec has discrete ${getSizeChannel(channel)}.`:'Dropping "fit" because spec has discrete size.'}function unknownField(channel){return`Unknown field for ${channel}. Cannot calculate view size.`}function cannotProjectOnChannelWithoutField(channel){return`Cannot project a selection on encoding channel "${channel}", which has no field.`}
function selectionNotSupported(mark){return`Selection not supported for ${mark} yet.`}function columnsNotSupportByRowCol(type){return`The "columns" property cannot be used when "${type}" has nested row/column.`}function differentParse(field,local,ancestor){return`An ancestor parsed field "${field}" as ${ancestor} but a child wants to parse the field as ${local}.`}function customFormatTypeNotAllowed(channel){return`Config.customFormatTypes is not true, thus custom format type and format for channel ${channel} are dropped.`}
function droppingColor(type,opt){const {fill,stroke}=opt;return`Dropping color ${type} as the plot also has ${fill&&stroke?"fill and stroke":fill?"fill":"stroke"}.`}function emptyFieldDef(fieldDef,channel){return`Dropping ${stringify(fieldDef)} from channel "${channel}" since it does not contain any data field, datum, value, or signal.`}function incompatibleChannel(channel,markOrFacet,when){return`${channel} dropped as it is incompatible with "${markOrFacet}"${when?` when ${when}`:""}.`}function discreteChannelCannotEncode(channel,
type){return`Using discrete channel "${channel}" to encode "${type}" field can be misleading as it does not encode ${"ordinal"===type?"order":"magnitude"}.`}function scalePropertyNotWorkWithScaleType(scaleType,propName,channel){return`${channel}-scale's "${propName}" is dropped as it does not work with ${scaleType} scale.`}function stepDropped(channel){return`The step for "${channel}" is dropped because the ${"width"===channel?"x":"y"} is continuous.`}function invalidTimeUnit(unitName,value){return`Invalid ${unitName}: ${stringify(value)}.`}
function errorBand1DNotSupport(property){return`1D error band does not support ${property}.`}function channelRequiredForBinned(channel){return`Channel ${channel} is required for "binned" bin.`}function warn(){current.warn(...arguments)}function debug(){current.debug(...arguments)}function isDateTime(o){if(o&&vega.isObject(o))for(const part of TIMEUNIT_PARTS)if(part in o)return!0;return!1}function normalizeMonth(m){isNumeric(m)&&(m=+m);if(vega.isNumber(m))return m-1;var lowerM=m.toLowerCase();const monthIndex=
MONTHS.indexOf(lowerM);if(-1!==monthIndex)return monthIndex;lowerM=lowerM.substr(0,3);lowerM=SHORT_MONTHS.indexOf(lowerM);if(-1!==lowerM)return lowerM;throw Error(invalidTimeUnit("month",m));}function normalizeDay(d){isNumeric(d)&&(d=+d);if(vega.isNumber(d))return d%7;var lowerD=d.toLowerCase();const dayIndex=DAYS.indexOf(lowerD);if(-1!==dayIndex)return dayIndex;lowerD=lowerD.substr(0,3);lowerD=SHORT_DAYS.indexOf(lowerD);if(-1!==lowerD)return lowerD;throw Error(invalidTimeUnit("day",d));}function dateTimeParts(d,
normalize){const parts=[];normalize&&void 0!==d.day&&1<keys$jscomp$0(d).length&&(warn(`Dropping day from datetime ${stringify(d)} as day cannot be combined with other units.`),d=duplicate(d),delete d.day);void 0!==d.year?parts.push(d.year):parts.push(2012);if(void 0!==d.month){var month=normalize?normalizeMonth(d.month):d.month;parts.push(month)}else if(void 0!==d.quarter){if(normalize)if(month=d.quarter,isNumeric(month)&&(month=+month),vega.isNumber(month))4<month&&warn(invalidTimeUnit("quarter",
month)),--month;else throw Error(invalidTimeUnit("quarter",month));else month=d.quarter;parts.push(vega.isNumber(month)?3*month:`${month}*3`)}else parts.push(0);void 0!==d.date?parts.push(d.date):void 0!==d.day?(normalize=normalize?normalizeDay(d.day):d.day,parts.push(vega.isNumber(normalize)?normalize+1:`${normalize}+1`)):parts.push(1);for(const timeUnit of["hours","minutes","seconds","milliseconds"])normalize=d[timeUnit],parts.push("undefined"===typeof normalize?0:normalize);return parts}function dateTimeToExpr(d){const string=
dateTimeParts(d,!0).join(", ");return d.utc?`utc(${string})`:`datetime(${string})`}function dateTimeToTimestamp(d){const parts=dateTimeParts(d,!0);return d.utc?+new Date(Date.UTC(...parts)):+new Date(...parts)}function getTimeUnitParts(timeUnit){return TIMEUNIT_PARTS.filter(part=>containsTimeUnit(timeUnit,part))}function containsTimeUnit(fullTimeUnit,timeUnit){const index=fullTimeUnit.indexOf(timeUnit);return 0>index||0<index&&"seconds"===timeUnit&&"i"===fullTimeUnit.charAt(index-1)||fullTimeUnit.length>
index+3&&"day"===timeUnit&&"o"===fullTimeUnit.charAt(index+3)||0<index&&"year"===timeUnit&&"f"===fullTimeUnit.charAt(index-1)?!1:!0}function fieldExpr(fullTimeUnit,field){var {end}=2<arguments.length&&void 0!==arguments[2]?arguments[2]:{end:!1};const fieldRef=accessPathWithDatum(field),utc=fullTimeUnit.startsWith("utc")?"utc":"";const dateExpr={};for(const part of TIMEUNIT_PARTS)if(containsTimeUnit(fullTimeUnit,part)){var lastTimeUnit="quarter"===part?`(${utc}quarter(${fieldRef})-1)`:`${utc}${part}(${fieldRef})`;
dateExpr[part]=lastTimeUnit;lastTimeUnit=part}end&&(dateExpr[lastTimeUnit]+="+1");end=dateTimeParts(dateExpr,!1).join(", ");return dateExpr.utc?`utc(${end})`:`datetime(${end})`}function timeUnitSpecifierExpression(timeUnit){if(timeUnit)return timeUnit=getTimeUnitParts(timeUnit),`timeUnitSpecifier(${stringify(timeUnit)}, ${stringify(VEGALITE_TIMEFORMAT)})`}function normalizeTimeUnit(timeUnit){if(timeUnit){var params;vega.isString(timeUnit)?params={unit:timeUnit}:vega.isObject(timeUnit)&&(params={...timeUnit,
...(timeUnit.unit?{unit:timeUnit.unit}:{})});params.unit.startsWith("utc")&&(params.utc=!0,params.unit=params.unit.substr(3));return params}}function timeUnitToString(tu){const {utc,...rest}=normalizeTimeUnit(tu);return rest.unit?(utc?"utc":"")+keys$jscomp$0(rest).map(p=>varName(`${"unit"===p?"":`_${p}_`}${rest[p]}`)).join(""):(utc?"utc":"")+"timeunit"+keys$jscomp$0(rest).map(p=>varName(`_${p}_${rest[p]}`)).join("")}function isFieldRangePredicate(predicate){return predicate?.field&&(vega.isArray(predicate.range)&&
2===predicate.range.length||isSignalRef(predicate.range))?!0:!1}function isFieldOneOfPredicate(predicate){return!!predicate?.field&&(vega.isArray(predicate.oneOf)||vega.isArray(predicate.in))}function isFieldPredicate(predicate){return isFieldOneOfPredicate(predicate)||!!predicate?.field&&void 0!==predicate.equal||isFieldRangePredicate(predicate)||!!predicate?.field&&void 0!==predicate.lt||!!predicate?.field&&void 0!==predicate.gt||!!predicate?.field&&void 0!==predicate.lte||!!predicate?.field&&void 0!==
predicate.gte}function predicateValueExpr(v,timeUnit){return valueExpr(v,{timeUnit,wrapTime:!0})}function predicateValuesExpr(vals,timeUnit){return vals.map(v=>predicateValueExpr(v,timeUnit))}function fieldFilterExpression(predicate){var useInRange=1<arguments.length&&void 0!==arguments[1]?arguments[1]:!0,{field}=predicate;const timeUnit=normalizeTimeUnit(predicate.timeUnit)?.unit;field=timeUnit?`time(${fieldExpr(timeUnit,field)})`:vgField(predicate,{expr:"datum"});if(predicate?.field&&void 0!==predicate.equal)return`${field}===${predicateValueExpr(predicate.equal,
timeUnit)}`;if(predicate?.field&&void 0!==predicate.lt)return`${field}<${predicateValueExpr(predicate.lt,timeUnit)}`;if(predicate?.field&&void 0!==predicate.gt)return`${field}>${predicateValueExpr(predicate.gt,timeUnit)}`;if(predicate?.field&&void 0!==predicate.lte)return`${field}<=${predicateValueExpr(predicate.lte,timeUnit)}`;if(predicate?.field&&void 0!==predicate.gte)return`${field}>=${predicateValueExpr(predicate.gte,timeUnit)}`;if(isFieldOneOfPredicate(predicate))return`indexof([${predicateValuesExpr(predicate.oneOf,
timeUnit).join(",")}], ${field}) !== -1`;if(predicate?.field&&void 0!==predicate.valid)return fieldValidPredicate(field,predicate.valid);if(isFieldRangePredicate(predicate)){var {range}=predicate;const lower=isSignalRef(range)?{signal:`${range.signal}[0]`}:range[0];range=isSignalRef(range)?{signal:`${range.signal}[1]`}:range[1];if(null!==lower&&null!==range&&useInRange)return"inrange("+field+", ["+predicateValueExpr(lower,timeUnit)+", "+predicateValueExpr(range,timeUnit)+"])";useInRange=[];null!==
lower&&useInRange.push(`${field} >= ${predicateValueExpr(lower,timeUnit)}`);null!==range&&useInRange.push(`${field} <= ${predicateValueExpr(range,timeUnit)}`);return 0<useInRange.length?useInRange.join(" \x26\x26 "):"true"}throw Error(`Invalid field predicate: ${stringify(predicate)}`);}function fieldValidPredicate(fieldExpr){return(1<arguments.length&&void 0!==arguments[1]?arguments[1]:1)?`isValid(${fieldExpr}) && isFinite(+${fieldExpr})`:`!isValid(${fieldExpr}) || !isFinite(+${fieldExpr})`}function normalizePredicate$1(f){return isFieldPredicate(f)&&
f.timeUnit?{...f,timeUnit:normalizeTimeUnit(f.timeUnit)?.unit}:f}function isContinuous(type){return"quantitative"===type||"temporal"===type}function isDiscrete$1(type){return"ordinal"===type||"nominal"===type}function getFullName(type){if(type)switch(type=type.toLowerCase(),type){case "q":case "quantitative":return"quantitative";case "t":case "temporal":return"temporal";case "o":case "ordinal":return"ordinal";case "n":case "nominal":return"nominal";case "geojson":return"geojson"}}function hasDiscreteDomain(type){return DISCRETE_DOMAIN_SCALES.has(type)}
function hasContinuousDomain(type){return CONTINUOUS_DOMAIN_SCALES.has(type)}function scaleTypeSupportProperty(scaleType,propName){switch(propName){case "type":case "domain":case "reverse":case "range":return!0;case "scheme":case "interpolate":return!["point","band","identity"].includes(scaleType);case "bins":return!["point","band","identity","ordinal"].includes(scaleType);case "round":return CONTINUOUS_TO_CONTINUOUS_SCALES.has(scaleType)||"band"===scaleType||"point"===scaleType;case "padding":case "rangeMin":case "rangeMax":return CONTINUOUS_TO_CONTINUOUS_SCALES.has(scaleType)||
["point","band"].includes(scaleType);case "paddingOuter":case "align":return["point","band"].includes(scaleType);case "paddingInner":return"band"===scaleType;case "domainMax":case "domainMid":case "domainMin":case "clamp":return CONTINUOUS_TO_CONTINUOUS_SCALES.has(scaleType);case "nice":return CONTINUOUS_TO_CONTINUOUS_SCALES.has(scaleType)||"quantize"===scaleType||"threshold"===scaleType;case "exponent":return"pow"===scaleType;case "base":return"log"===scaleType;case "constant":return"symlog"===scaleType;
case "zero":return hasContinuousDomain(scaleType)&&!contains(["log","time","utc","threshold","quantile"],scaleType)}}function channelScalePropertyIncompatability(channel,propName){switch(propName){case "interpolate":case "scheme":case "domainMid":if(!isColorChannel(channel))return`Cannot use the scale property "${propName}" with non-color channel.`}}function channelSupportScaleType(channel,scaleType){let hasNestedOffsetScale=2<arguments.length&&void 0!==arguments[2]?arguments[2]:!1;if(!SCALE_CHANNEL_INDEX[channel])return!1;
switch(channel){case "x":case "y":case "xOffset":case "yOffset":case "theta":case "radius":return CONTINUOUS_TO_CONTINUOUS_SCALES.has(scaleType)||"band"===scaleType?!0:"point"===scaleType?!hasNestedOffsetScale:!1;case "size":case "strokeWidth":case "opacity":case "fillOpacity":case "strokeOpacity":case "angle":return CONTINUOUS_TO_CONTINUOUS_SCALES.has(scaleType)||CONTINUOUS_TO_DISCRETE_SCALES.has(scaleType)||contains(["band","point","ordinal"],scaleType);case "color":case "fill":case "stroke":return"band"!==
scaleType;case "strokeDash":case "shape":return"ordinal"===scaleType||CONTINUOUS_TO_DISCRETE_SCALES.has(scaleType)}}function isPathMark(m){return["line","area","trail"].includes(m)}function isMarkDef(mark){return mark.type}function isRelativeBandSize(o){return o&&void 0!=o.band}function midPointRefWithPositionInvalidTest(params){const {channel:channel$jscomp$0,channelDef,markDef,scale,config:config$jscomp$0}=params;params=midPoint(params);if(isFieldDef(channelDef)&&!isCountingAggregateOp(channelDef.aggregate)&&
scale&&CONTINUOUS_TO_CONTINUOUS_SCALES.has(scale.get("type"))){{let {fieldDef,channel,markDef:markDef$jscomp$0,ref,config}={fieldDef:channelDef,channel:channel$jscomp$0,markDef,ref:params,config:config$jscomp$0};if(isPathMark(markDef$jscomp$0.type))params=ref;else if(null===getMarkPropOrConfig("invalid",markDef$jscomp$0,config)){var channel$jscomp$1=channel;params=fieldInvalidPredicate(fieldDef,!0);channel$jscomp$1="y"===getMainRangeChannel(channel$jscomp$1)?{field:{group:"height"}}:{value:0};params=
[{test:params,...channel$jscomp$1},ref]}else params=ref}return params}return params}function fieldInvalidPredicate(field){let invalid=1<arguments.length&&void 0!==arguments[1]?arguments[1]:!0;return fieldValidPredicate(vega.isString(field)?field:vgField(field,{expr:"datum"}),!invalid)}function valueRefForFieldOrDatumDef(fieldDef,scaleName,opt,encode){const ref={};scaleName&&(ref.scale=scaleName);isDatumDef(fieldDef)?({datum:fieldDef}=fieldDef,isDateTime(fieldDef)?ref.signal=dateTimeToExpr(fieldDef):
isSignalRef(fieldDef)?ref.signal=fieldDef.signal:fieldDef?.expr?ref.signal=fieldDef.expr:ref.value=fieldDef):ref.field=vgField(fieldDef,opt);if(encode){const {offset,band}=encode;offset&&(ref.offset=offset);band&&(ref.band=band)}return ref}function interpolatedSignalRef(_ref2){let {scaleName,fieldOrDatumDef,fieldOrDatumDef2,offset,startSuffix,bandPosition=.5}=_ref2;var expr=0<bandPosition&&1>bandPosition?"datum":void 0;_ref2=vgField(fieldOrDatumDef,{expr,suffix:startSuffix});const end=void 0!==fieldOrDatumDef2?
vgField(fieldOrDatumDef2,{expr}):vgField(fieldOrDatumDef,{suffix:"end",expr});expr={};0===bandPosition||1===bandPosition?(expr.scale=scaleName,expr.field=0===bandPosition?_ref2:end):(_ref2=isSignalRef(bandPosition)?`${bandPosition.signal} * ${_ref2} + (1-${bandPosition.signal}) * ${end}`:`${bandPosition} * ${_ref2} + ${1-bandPosition} * ${end}`,expr.signal=`scale("${scaleName}", ${_ref2})`);offset&&(expr.offset=offset);return expr}function midPoint(_ref3){let {channel,channelDef,channel2Def,markDef,
config,scaleName,scale,stack,offset,defaultRef,bandPosition}=_ref3;if(channelDef){if(isFieldOrDatumDef(channelDef)){_ref3=scale?.get("type");if(isTypedFieldDef(channelDef)){bandPosition??(bandPosition=getBandPosition({fieldDef:channelDef,fieldDef2:channel2Def,markDef,config}));const {bin,timeUnit,type}=channelDef;if(isBinning(bin)||bandPosition&&timeUnit&&"temporal"===type)return stack?.impute?valueRefForFieldOrDatumDef(channelDef,scaleName,{binSuffix:"mid"},{offset}):bandPosition&&!hasDiscreteDomain(_ref3)?
interpolatedSignalRef({scaleName,fieldOrDatumDef:channelDef,bandPosition,offset}):valueRefForFieldOrDatumDef(channelDef,scaleName,binRequiresRange(channelDef,channel)?{binSuffix:"range"}:{},{offset});if(isBinned(bin)){if(isFieldDef(channel2Def))return interpolatedSignalRef({scaleName,fieldOrDatumDef:channelDef,fieldOrDatumDef2:channel2Def,bandPosition,offset});warn(channelRequiredForBinned("x"===channel?"x2":"y2"))}}return valueRefForFieldOrDatumDef(channelDef,scaleName,hasDiscreteDomain(_ref3)?{binSuffix:"range"}:
{},{offset,band:"band"===_ref3?bandPosition??channelDef.bandPosition??.5:void 0})}if(isValueDef(channelDef))return _ref3=offset?{offset}:{},{...widthHeightValueOrSignalRef(channel,channelDef.value),..._ref3}}vega.isFunction(defaultRef)&&(defaultRef=defaultRef());return defaultRef?{...defaultRef,...(offset?{offset}:{})}:defaultRef}function widthHeightValueOrSignalRef(channel,value){return contains(["x","x2"],channel)&&"width"===value?{field:{group:"width"}}:contains(["y","y2"],channel)&&"height"===
value?{field:{group:"height"}}:signalOrValueRef(value)}function isCustomFormatType(formatType){return formatType&&"number"!==formatType&&"time"!==formatType}function formatSignalRef(_ref){let {fieldOrDatumDef,format:format$jscomp$0,formatType:formatType$jscomp$0,expr,normalizeStack,config}=_ref;if(isCustomFormatType(formatType$jscomp$0))return formatCustomType({fieldOrDatumDef,format:format$jscomp$0,formatType:formatType$jscomp$0,expr,config});_ref=fieldToFormat(fieldOrDatumDef,expr,normalizeStack);
var type=fieldOrDatumDef?.type;if(void 0===format$jscomp$0&&void 0===formatType$jscomp$0&&config.customFormatTypes){if("quantitative"===type){if(normalizeStack&&config.normalizedNumberFormatType)return formatCustomType({fieldOrDatumDef,format:config.normalizedNumberFormat,formatType:config.normalizedNumberFormatType,expr,config});if(config.numberFormatType)return formatCustomType({fieldOrDatumDef,format:config.numberFormat,formatType:config.numberFormatType,expr,config})}if("temporal"===type&&config.timeFormatType&&
isFieldDef(fieldOrDatumDef)&&void 0===fieldOrDatumDef.timeUnit)return formatCustomType({fieldOrDatumDef,format:config.timeFormat,formatType:config.timeFormatType,expr,config})}if(isFieldOrDatumDefForTimeFormat(fieldOrDatumDef)){{_ref={field:_ref,timeUnit:isFieldDef(fieldOrDatumDef)?normalizeTimeUnit(fieldOrDatumDef.timeUnit)?.unit:void 0,format:format$jscomp$0,formatType:config.timeFormatType,rawTimeFormat:config.timeFormat,isUTCScale:isScaleFieldDef(fieldOrDatumDef)&&fieldOrDatumDef.scale?.type===
ScaleType.UTC};let {field,timeUnit,format,formatType,rawTimeFormat,isUTCScale}=_ref;if(!timeUnit||format)!timeUnit&&formatType?_ref=`${formatType}(${field}, '${format}')`:(format=vega.isString(format)?format:rawTimeFormat,_ref=`${isUTCScale?"utc":"time"}Format(${field}, '${format}')`);else{_ref=timeUnit;type=field;var isUTCScale$jscomp$0=isUTCScale;if(_ref){var expr$jscomp$0=timeUnitSpecifierExpression(_ref);_ref=`${isUTCScale$jscomp$0||_ref.startsWith("utc")?"utc":"time"}Format(${type}, ${expr$jscomp$0})`}else _ref=
void 0}}return _ref?{signal:_ref}:void 0}format$jscomp$0=numberFormat({type,specifiedFormat:format$jscomp$0,config,normalizeStack});return isFieldDef(fieldOrDatumDef)&&isBinning(fieldOrDatumDef.bin)?(type=vgField(fieldOrDatumDef,{expr,binSuffix:"end"}),{signal:binFormatExpression(_ref,type,format$jscomp$0,formatType$jscomp$0,config)}):format$jscomp$0||"quantitative"===fieldOrDatumDef?.type?{signal:`${`format(${_ref}, "${format$jscomp$0||""}")`}`}:{signal:`isValid(${_ref}) ? ${_ref} : ""+${_ref}`}}
function fieldToFormat(fieldOrDatumDef,expr,normalizeStack){if(isFieldDef(fieldOrDatumDef))return normalizeStack?`${vgField(fieldOrDatumDef,{expr,suffix:"end"})}-${vgField(fieldOrDatumDef,{expr,suffix:"start"})}`:vgField(fieldOrDatumDef,{expr});({datum:fieldOrDatumDef}=fieldOrDatumDef);fieldOrDatumDef=isDateTime(fieldOrDatumDef)?dateTimeToExpr(fieldOrDatumDef):`${stringify(fieldOrDatumDef)}`;return fieldOrDatumDef}function formatCustomType(_ref2){let {fieldOrDatumDef,format,formatType,expr,normalizeStack,
config,field}=_ref2;field??(field=fieldToFormat(fieldOrDatumDef,expr,normalizeStack));return"datum.value"!==field&&isFieldDef(fieldOrDatumDef)&&isBinning(fieldOrDatumDef.bin)?(_ref2=vgField(fieldOrDatumDef,{expr,binSuffix:"end"}),{signal:binFormatExpression(field,_ref2,format,formatType,config)}):{signal:`${formatType}(${field}${format?`, ${stringify(format)}`:""})`}}function guideFormat(fieldOrDatumDef,type,format,formatType,config$jscomp$0,omitTimeFormatConfig){if(!(isCustomFormatType(formatType)||
void 0===format&&void 0===formatType&&config$jscomp$0.customFormatTypes&&"quantitative"===fieldOrDatumDef?.type&&(config$jscomp$0.normalizedNumberFormatType&&isPositionFieldOrDatumDef(fieldOrDatumDef)&&"normalize"===fieldOrDatumDef.stack||config$jscomp$0.numberFormatType))){if(isPositionFieldOrDatumDef(fieldOrDatumDef)&&"normalize"===fieldOrDatumDef.stack&&config$jscomp$0.normalizedNumberFormat)return numberFormat({type:"quantitative",config:config$jscomp$0,normalizeStack:!0});if(isFieldOrDatumDefForTimeFormat(fieldOrDatumDef)){fieldOrDatumDef=
isFieldDef(fieldOrDatumDef)?normalizeTimeUnit(fieldOrDatumDef.timeUnit)?.unit:void 0;if(void 0===fieldOrDatumDef&&config$jscomp$0.customFormatTypes&&config$jscomp$0.timeFormatType)return;{let {specifiedFormat,timeUnit,config,omitTimeFormatConfig:omitTimeFormatConfig$jscomp$0}={specifiedFormat:format,timeUnit:fieldOrDatumDef,config:config$jscomp$0,omitTimeFormatConfig};format=specifiedFormat?specifiedFormat:timeUnit?{signal:timeUnitSpecifierExpression(timeUnit)}:omitTimeFormatConfig$jscomp$0?void 0:
config.timeFormat}return format}return numberFormat({type,specifiedFormat:format,config:config$jscomp$0})}}function guideFormatType(formatType,fieldOrDatumDef,scaleType){if(formatType&&(isSignalRef(formatType)||"number"===formatType||"time"===formatType))return formatType;if(isFieldOrDatumDefForTimeFormat(fieldOrDatumDef)&&"time"!==scaleType&&"utc"!==scaleType)return isFieldDef(fieldOrDatumDef)&&normalizeTimeUnit(fieldOrDatumDef?.timeUnit)?.utc?"utc":"time"}function numberFormat(_ref3){let {type,
specifiedFormat,config,normalizeStack}=_ref3;if(vega.isString(specifiedFormat))return specifiedFormat;if("quantitative"===type)return normalizeStack?config.normalizedNumberFormat:config.numberFormat}function binNumberFormatExpr(field,format,formatType,config){if(isCustomFormatType(formatType))return`${formatType}(${field}${format?`, ${stringify(format)}`:""})`;format=(vega.isString(format)?format:void 0)??config.numberFormat;return`format(${field}, "${format||""}")`}function binFormatExpression(startField,
endField,format,formatType,config){if(void 0===format&&void 0===formatType&&config.customFormatTypes&&config.numberFormatType)return binFormatExpression(startField,endField,config.numberFormat,config.numberFormatType,config);const start=binNumberFormatExpr(startField,format,formatType,config);endField=binNumberFormatExpr(endField,format,formatType,config);return`${fieldValidPredicate(startField,!1)} ? "null" : ${start} + "${" – "}" + ${endField}`}function isSortField(sort){return sort&&("count"===
sort.op||!!sort.field)}function isSortArray(sort){return sort&&vega.isArray(sort)}function isFacetMapping(f){return"row"in f||"column"in f}function toFieldDefBase(fieldDef){const {field,timeUnit,bin,aggregate}=fieldDef;return{...(timeUnit?{timeUnit}:{}),...(bin?{bin}:{}),...(aggregate?{aggregate}:{}),field}}function getBandPosition(_ref){let {fieldDef,fieldDef2,markDef:mark,config}=_ref;if(isFieldOrDatumDef(fieldDef)&&void 0!==fieldDef.bandPosition)return fieldDef.bandPosition;if(isFieldDef(fieldDef)){const {timeUnit,
bin}=fieldDef;if(timeUnit&&!fieldDef2)return["rect","bar","image","arc"].includes(mark.type)?0:getMarkConfig("timeUnitBandPosition",mark,config);if(isBinning(bin))return.5}}function getBandSize(_ref2){let {channel,fieldDef,fieldDef2,markDef:mark,config,scaleType,useVlSizeChannel}=_ref2;_ref2=getSizeChannel(channel);_ref2=getMarkPropOrConfig(useVlSizeChannel?"size":_ref2,mark,config,{vgChannel:_ref2});if(void 0!==_ref2)return _ref2;if(isFieldDef(fieldDef)){const {timeUnit,bin}=fieldDef;if(timeUnit&&
!fieldDef2)return{band:getMarkConfig("timeUnitBandSize",mark,config)};if(isBinning(bin)&&!hasDiscreteDomain(scaleType))return{band:1}}if(["rect","bar","image","arc"].includes(mark.type))return scaleType?hasDiscreteDomain(scaleType)?config[mark.type]?.discreteBandSize||{band:1}:config[mark.type]?.continuousBandSize:config[mark.type]?.discreteBandSize}function hasBandEnd(fieldDef,fieldDef2,markDef,config){return isBinning(fieldDef.bin)||fieldDef.timeUnit&&isTypedFieldDef(fieldDef)&&"temporal"===fieldDef.type?
void 0!==getBandPosition({fieldDef,fieldDef2,markDef,config}):!1}function isConditionalDef(channelDef){return channelDef&&"condition"in channelDef}function hasConditionalFieldDef(channelDef){channelDef=channelDef?.condition;return!!channelDef&&!vega.isArray(channelDef)&&isFieldDef(channelDef)}function hasConditionalFieldOrDatumDef(channelDef){channelDef=channelDef?.condition;return!!channelDef&&!vega.isArray(channelDef)&&isFieldOrDatumDef(channelDef)}function isFieldDef(channelDef){return channelDef&&
(!!channelDef.field||"count"===channelDef.aggregate)}function isDatumDef(channelDef){return channelDef&&"datum"in channelDef}function isContinuousFieldOrDatumDef(cd){return isTypedFieldDef(cd)&&!isDiscrete(cd)||isNumericDataDef(cd)}function isNumericDataDef(cd){return isDatumDef(cd)&&vega.isNumber(cd.datum)}function isFieldOrDatumDef(channelDef){return isFieldDef(channelDef)||isDatumDef(channelDef)}function isTypedFieldDef(channelDef){return channelDef&&("field"in channelDef||"count"===channelDef.aggregate)&&
"type"in channelDef}function isValueDef(channelDef){return channelDef&&"value"in channelDef&&"value"in channelDef}function isScaleFieldDef(channelDef){return channelDef&&("scale"in channelDef||"sort"in channelDef)}function isPositionFieldOrDatumDef(channelDef){return channelDef&&("axis"in channelDef||"stack"in channelDef||"impute"in channelDef)}function isStringFieldOrDatumDef(channelDef){return channelDef&&("format"in channelDef||"formatType"in channelDef)}function toStringFieldDef(fieldDef){return omit(fieldDef,
["legend","axis","header","scale"])}function vgField(fieldDef){let opt=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{},field=fieldDef.field;const prefix=opt.prefix;let suffix=opt.suffix,argAccessor="";if("count"===fieldDef.aggregate)field=internalField("count");else{let fn;if(!opt.nofn)if("op"in fieldDef)fn=fieldDef.op;else{const {bin,aggregate,timeUnit}=fieldDef;isBinning(bin)?(fn=binToString(bin),suffix=(opt.binSuffix??"")+(opt.suffix??"")):aggregate?isArgmaxDef(aggregate)?(argAccessor=
`["${field}"]`,field=`argmax_${aggregate.argmax}`):isArgminDef(aggregate)?(argAccessor=`["${field}"]`,field=`argmin_${aggregate.argmin}`):fn=String(aggregate):timeUnit&&(fn=timeUnitToString(timeUnit),suffix=(!["range","mid"].includes(opt.binSuffix)&&opt.binSuffix||"")+(opt.suffix??""))}fn&&(field=field?`${fn}_${field}`:fn)}suffix&&(field=`${field}_${suffix}`);prefix&&(field=`${prefix}_${field}`);return opt.forAs?removePathFromField(field):opt.expr?flatAccessWithDatum(field,opt.expr)+argAccessor:replacePathInField(field)+
argAccessor}function isDiscrete(def){switch(def.type){case "nominal":case "ordinal":case "geojson":return!0;case "quantitative":return isFieldDef(def)&&!!def.bin;case "temporal":return!1}throw Error(`Invalid field type "${def.type}".`);}function verbalTitleFormatter(fieldDef,config){const {field,bin,timeUnit,aggregate}=fieldDef;if("count"===aggregate)return config.countTitle;if(isBinning(bin))return`${field} (binned)`;if(timeUnit){if(fieldDef=normalizeTimeUnit(timeUnit)?.unit)return`${field} (${getTimeUnitParts(fieldDef).join("-")})`}else if(aggregate)return isArgmaxDef(aggregate)?
`${field} for max ${aggregate.argmax}`:isArgminDef(aggregate)?`${field} for min ${aggregate.argmin}`:`${titleCase(aggregate)} of ${field}`;return field}function title$jscomp$0(fieldOrDatumDef,config,_ref3){let {allowDisabling,includeDefault=!0}=_ref3;_ref3=getGuide(fieldOrDatumDef)?.title;if(!isFieldDef(fieldOrDatumDef))return _ref3??fieldOrDatumDef.title;config=includeDefault?titleFormatter(fieldOrDatumDef,config):void 0;return allowDisabling?getFirstDefined(_ref3,fieldOrDatumDef.title,config):_ref3??
fieldOrDatumDef.title??config}function getGuide(fieldDef){if(isPositionFieldOrDatumDef(fieldDef)&&fieldDef.axis)return fieldDef.axis;if(fieldDef&&"legend"in fieldDef&&fieldDef.legend)return fieldDef.legend;if(fieldDef&&"header"in fieldDef&&fieldDef.header)return fieldDef.header}function getFormatMixins(fieldDef){if(isStringFieldOrDatumDef(fieldDef)){const {format,formatType}=fieldDef;return{format,formatType}}fieldDef=getGuide(fieldDef)??{};const {format:format$jscomp$0,formatType:formatType$jscomp$0}=
fieldDef;return{format:format$jscomp$0,formatType:formatType$jscomp$0}}function defaultType$2(fieldDef,channel){switch(channel){case "latitude":case "longitude":return"quantitative";case "row":case "column":case "facet":case "shape":case "strokeDash":return"nominal";case "order":return"ordinal"}if("sort"in fieldDef&&vega.isArray(fieldDef.sort))return"ordinal";const {aggregate,bin,timeUnit}=fieldDef;if(timeUnit)return"temporal";if(bin||aggregate&&!isArgmaxDef(aggregate)&&!isArgminDef(aggregate))return"quantitative";
if(isScaleFieldDef(fieldDef)&&fieldDef.scale?.type)switch(SCALE_CATEGORY_INDEX[fieldDef.scale.type]){case "numeric":case "discretizing":return"quantitative";case "time":return"temporal"}return"nominal"}function getFieldDef(channelDef){if(isFieldDef(channelDef))return channelDef;if(hasConditionalFieldDef(channelDef))return channelDef.condition}function getFieldOrDatumDef(channelDef){if(isFieldOrDatumDef(channelDef))return channelDef;if(hasConditionalFieldOrDatumDef(channelDef))return channelDef.condition}
function initChannelDef(channelDef,channel,config){var opt=3<arguments.length&&void 0!==arguments[3]?arguments[3]:{};return vega.isString(channelDef)||vega.isNumber(channelDef)||vega.isBoolean(channelDef)?(opt=vega.isString(channelDef)?"string":vega.isNumber(channelDef)?"number":"boolean",warn(`Channel ${channel} is a ${opt}. Converted to {value: ${stringify(channelDef)}}.`),{value:channelDef}):isFieldOrDatumDef(channelDef)?initFieldOrDatumDef(channelDef,channel,config,opt):hasConditionalFieldOrDatumDef(channelDef)?
{...channelDef,condition:initFieldOrDatumDef(channelDef.condition,channel,config,opt)}:channelDef}function initFieldOrDatumDef(fd,channel,config,opt){if(isStringFieldOrDatumDef(fd)){const {format,formatType,...rest}=fd;if(isCustomFormatType(formatType)&&!config.customFormatTypes)return warn(customFormatTypeNotAllowed(channel)),initFieldOrDatumDef(rest,channel,config,opt)}else{const guideType=isPositionFieldOrDatumDef(fd)?"axis":fd&&"legend"in fd?"legend":fd&&"header"in fd?"header":null;if(guideType&&
fd[guideType]){const {format,formatType,...newGuide}=fd[guideType];if(isCustomFormatType(formatType)&&!config.customFormatTypes)return warn(customFormatTypeNotAllowed(channel)),initFieldOrDatumDef({...fd,[guideType]:newGuide},channel,config,opt)}}if(isFieldDef(fd))return initFieldDef(fd,channel,opt);channel=fd.type;channel||({datum:channel}=fd,channel=vega.isNumber(channel)?"quantitative":vega.isString(channel)?"nominal":isDateTime(channel)?"temporal":void 0,fd={...fd,type:channel});return fd}function initFieldDef(fd,
channel){var {compositeMark=!1}=2<arguments.length&&void 0!==arguments[2]?arguments[2]:{};const {aggregate,timeUnit,bin,field}=fd,fieldDef={...fd};compositeMark||!aggregate||isAggregateOp(aggregate)||isArgmaxDef(aggregate)||isArgminDef(aggregate)||(warn(`Invalid aggregation operator "${aggregate}".`),delete fieldDef.aggregate);timeUnit&&(fieldDef.timeUnit=normalizeTimeUnit(timeUnit));field&&(fieldDef.field=`${field}`);isBinning(bin)&&(fieldDef.bin=normalizeBin(bin,channel));isBinned(bin)&&!isXorY(channel)&&
warn(`Channel ${channel} should not be used with "binned" bin.`);if(isTypedFieldDef(fieldDef)){({type:compositeMark}=fieldDef);var fullType=getFullName(compositeMark);compositeMark!==fullType&&(fieldDef.type=fullType);"quantitative"!==compositeMark&&isCountingAggregateOp(aggregate)&&(warn(`Invalid field type "${compositeMark}" for aggregate: "${aggregate}", using "quantitative" instead.`),fieldDef.type="quantitative")}else isSecondaryRangeChannel(channel)||(compositeMark=defaultType$2(fieldDef,channel),
fieldDef.type=compositeMark);if(isTypedFieldDef(fieldDef)){const {compatible,warning}=channelCompatibility(fieldDef,channel)||{};!1===compatible&&warn(warning)}if("sort"in fieldDef&&vega.isString(fieldDef.sort)){({sort:compositeMark}=fieldDef);if(compositeMark in SORT_BY_CHANNEL_INDEX)return{...fieldDef,sort:{encoding:compositeMark}};fullType=compositeMark.substr(1);if("-"===compositeMark.charAt(0)&&fullType in SORT_BY_CHANNEL_INDEX)return{...fieldDef,sort:{encoding:fullType,order:"descending"}}}if(fieldDef&&
"header"in fieldDef&&({header:compositeMark}=fieldDef,compositeMark)){const {orient,...rest}=compositeMark;if(orient)return{...fieldDef,header:{...rest,labelOrient:compositeMark.labelOrient||orient,titleOrient:compositeMark.titleOrient||orient}}}return fieldDef}function normalizeBin(bin,channel){return vega.isBoolean(bin)?{maxbins:autoMaxBins(channel)}:"binned"===bin?{binned:!0}:bin.maxbins||bin.step?bin:{...bin,maxbins:autoMaxBins(channel)}}function channelCompatibility(fieldDef,channel){var type=
fieldDef.type;if("geojson"===type&&"shape"!==channel)return{compatible:!1,warning:`Channel ${channel} should not be used with a geojson data.`};switch(channel){case "row":case "column":case "facet":return isDiscrete(fieldDef)?COMPATIBLE:{compatible:!1,warning:`${channel} encoding should be discrete (ordinal / nominal / binned).`};case "x":case "y":case "xOffset":case "yOffset":case "color":case "fill":case "stroke":case "text":case "detail":case "key":case "tooltip":case "href":case "url":case "angle":case "theta":case "radius":case "description":return COMPATIBLE;
case "longitude":case "longitude2":case "latitude":case "latitude2":return"quantitative"!==type?{compatible:!1,warning:`Channel ${channel} should be used with a quantitative field only, not ${fieldDef.type} field.`}:COMPATIBLE;case "opacity":case "fillOpacity":case "strokeOpacity":case "strokeWidth":case "size":case "theta2":case "radius2":case "x2":case "y2":return"nominal"!==type||fieldDef.sort?COMPATIBLE:{compatible:!1,warning:`Channel ${channel} should not be used with an unsorted discrete field.`};
case "shape":case "strokeDash":if(type=!isDiscrete(fieldDef))type=!(isScaleFieldDef(fieldDef)&&CONTINUOUS_TO_DISCRETE_SCALES.has(fieldDef.scale?.type));return type?{compatible:!1,warning:`${channel} encoding should be discrete (ordinal / nominal / binned) or use a discretizing scale (e.g. threshold).`}:COMPATIBLE;case "order":return"nominal"!==fieldDef.type||"sort"in fieldDef?COMPATIBLE:{compatible:!1,warning:"Channel order is inappropriate for nominal field, which has no inherent order."}}}function isFieldOrDatumDefForTimeFormat(fieldOrDatumDef){var {formatType}=
getFormatMixins(fieldOrDatumDef),JSCompiler_temp;if(!(JSCompiler_temp="time"===formatType)){if(formatType=!formatType)formatType=fieldOrDatumDef&&("temporal"===fieldOrDatumDef.type||isFieldDef(fieldOrDatumDef)&&!!fieldOrDatumDef.timeUnit);JSCompiler_temp=formatType}return JSCompiler_temp}function valueExpr(v,_ref4){let {timeUnit,type,wrapTime,undefinedIfExprNotRequired}=_ref4,isTime=(_ref4=timeUnit&&normalizeTimeUnit(timeUnit)?.unit)||"temporal"===type,expr;v?.expr?expr=v.expr:isSignalRef(v)?expr=
v.signal:isDateTime(v)?(isTime=!0,expr=dateTimeToExpr(v)):(vega.isString(v)||vega.isNumber(v))&&isTime&&(expr=`datetime(${stringify(v)})`,LOCAL_SINGLE_TIMEUNIT_INDEX[_ref4]&&(vega.isNumber(v)&&1E4>v||vega.isString(v)&&isNaN(Date.parse(v)))&&(expr=dateTimeToExpr({[_ref4]:v})));return expr?wrapTime&&isTime?`time(${expr})`:expr:undefinedIfExprNotRequired?void 0:stringify(v)}function valueArray(fieldOrDatumDef,values){const {type}=fieldOrDatumDef;return values.map(v=>{const expr=valueExpr(v,{timeUnit:isFieldDef(fieldOrDatumDef)?
fieldOrDatumDef.timeUnit:void 0,type,undefinedIfExprNotRequired:!0});return void 0!==expr?{signal:expr}:v})}function binRequiresRange(fieldDef,channel){return isBinning(fieldDef.bin)?!!SCALE_CHANNEL_INDEX[channel]&&["ordinal","nominal"].includes(fieldDef.type):(console.warn("Only call this method for binned field defs."),!1)}function isUnitSpec(spec){return"mark"in spec}function channelHasField(encoding,channel){return(encoding=encoding&&encoding[channel])?vega.isArray(encoding)?some(encoding,fieldDef=>
!!fieldDef.field):isFieldDef(encoding)||hasConditionalFieldDef(encoding):!1}function channelHasFieldOrDatum(encoding,channel){return(encoding=encoding&&encoding[channel])?vega.isArray(encoding)?some(encoding,fieldDef=>!!fieldDef.field):isFieldDef(encoding)||isDatumDef(encoding)||hasConditionalFieldOrDatumDef(encoding):!1}function channelHasNestedOffsetScale(encoding,channel){if(isXorY(channel)){const fieldDef=encoding[channel];if((isFieldDef(fieldDef)||isDatumDef(fieldDef))&&isDiscrete$1(fieldDef.type))return channel=
getOffsetScaleChannel(channel),channelHasFieldOrDatum(encoding,channel)}return!1}function isAggregate$1(encoding){return some(CHANNELS,channel=>channelHasField(encoding,channel)?(channel=encoding[channel],vega.isArray(channel)?some(channel,fieldDef=>!!fieldDef.aggregate):(channel=getFieldDef(channel))&&!!channel.aggregate):!1)}function extractTransformsFromEncoding(oldEncoding,config){const groupby=[],bins=[],timeUnits=[],aggregate=[],encoding={};forEach(oldEncoding,(channelDef,channel)=>{if(isFieldDef(channelDef)){const {field,
aggregate:aggOp,bin,timeUnit,...remaining}=channelDef;if(aggOp||timeUnit||bin){var isTitleDefined=getGuide(channelDef)?.title;let newField=vgField(channelDef,{forAs:!0});isTitleDefined={...(isTitleDefined?[]:{title:title$jscomp$0(channelDef,config,{allowDisabling:!0})}),...remaining,field:newField};if(aggOp){let op;isArgmaxDef(aggOp)?(op="argmax",newField=vgField({op:"argmax",field:aggOp.argmax},{forAs:!0}),isTitleDefined.field=`${newField}.${field}`):isArgminDef(aggOp)?(op="argmin",newField=vgField({op:"argmin",
field:aggOp.argmin},{forAs:!0}),isTitleDefined.field=`${newField}.${field}`):"boxplot"!==aggOp&&"errorbar"!==aggOp&&"errorband"!==aggOp&&(op=aggOp);op&&(channelDef={op,as:newField},field&&(channelDef.field=field),aggregate.push(channelDef))}else groupby.push(newField),isTypedFieldDef(channelDef)&&isBinning(bin)?(bins.push({bin,field,as:newField}),groupby.push(vgField(channelDef,{binSuffix:"end"})),binRequiresRange(channelDef,channel)&&groupby.push(vgField(channelDef,{binSuffix:"range"})),isXorY(channel)&&
(encoding[`${channel}2`]={field:`${newField}_end`}),isTitleDefined.bin="binned",isSecondaryRangeChannel(channel)||(isTitleDefined.type="quantitative")):timeUnit&&(timeUnits.push({timeUnit,field,as:newField}),(channelDef=isTypedFieldDef(channelDef)&&"temporal"!==channelDef.type&&"time")&&("text"===channel||"tooltip"===channel?isTitleDefined.formatType=channelDef:NONPOSITION_CHANNEL_INDEX[channel]?isTitleDefined.legend={formatType:channelDef,...isTitleDefined.legend}:isXorY(channel)&&(isTitleDefined.axis=
{formatType:channelDef,...isTitleDefined.axis})));encoding[channel]=isTitleDefined}else groupby.push(field),encoding[channel]=oldEncoding[channel]}else encoding[channel]=oldEncoding[channel]});return{bins,timeUnits,aggregate,groupby,encoding}}function markChannelCompatible(encoding,channel,mark){mark=getSupportedMark(channel)[mark];return mark&&("binned"!==mark||(mark=encoding["x2"===channel?"x":"y"],isFieldDef(mark)&&isFieldDef(encoding[channel])&&isBinned(mark.bin)))?!0:!1}function initEncoding(encoding,
mark,filled,config){const normalizedEncoding={};for(var key of keys$jscomp$0(encoding))CHANNEL_INDEX[key]||warn(`${key}-encoding is dropped as ${key} is not a valid encoding channel.`);for(let channel of UNIT_CHANNELS)if(encoding[channel]){key=encoding[channel];if(channel in OFFSET_SCALE_CHANNEL_INDEX){const mainChannel=getMainChannelFromOffsetChannel(channel),positionDef=normalizedEncoding[mainChannel];if(isFieldDef(positionDef)){if(isContinuous(positionDef.type)&&isFieldDef(key)){warn(`${mainChannel}Offset dropped because ${mainChannel} is continuous`);
continue}}else channel=mainChannel,warn(`There is no ${mainChannel} encoding. Replacing ${mainChannel}Offset encoding as ${mainChannel}.`)}"angle"!==channel||"arc"!==mark||encoding.theta||(warn("Arc marks uses theta channel rather than angle, replacing angle with theta."),channel="theta");if(markChannelCompatible(encoding,channel,mark))if("size"===channel&&"line"===mark&&getFieldDef(encoding[channel])?.aggregate)warn("Line marks cannot encode size with a non-groupby field. You may want to use trail marks instead.");
else if("color"===channel&&(filled?"fill"in encoding:"stroke"in encoding))warn(droppingColor("encoding",{fill:"fill"in encoding,stroke:"stroke"in encoding}));else if("detail"===channel||"order"===channel&&!vega.isArray(key)&&!isValueDef(key)||"tooltip"===channel&&vega.isArray(key))key&&(normalizedEncoding[channel]=vega.array(key).reduce((defs,fieldDef)=>{isFieldDef(fieldDef)?defs.push(initFieldDef(fieldDef,channel)):warn(emptyFieldDef(fieldDef,channel));return defs},[]));else{if("tooltip"===channel&&
null===key)normalizedEncoding[channel]=null;else if(!(isFieldDef(key)||isDatumDef(key)||isValueDef(key)||isConditionalDef(key)||isSignalRef(key))){warn(emptyFieldDef(key,channel));continue}normalizedEncoding[channel]=initChannelDef(key,channel,config)}else warn(incompatibleChannel(channel,mark))}return normalizedEncoding}function normalizeEncoding(encoding,config){const normalizedEncoding={};for(const channel of keys$jscomp$0(encoding)){const newChannelDef=initChannelDef(encoding[channel],channel,
config,{compositeMark:!0});normalizedEncoding[channel]=newChannelDef}return normalizedEncoding}function fieldDefs(encoding){const arr=[];for(const channel of keys$jscomp$0(encoding))if(channelHasField(encoding,channel)){const channelDefArray=vega.array(encoding[channel]);for(const def of channelDefArray)isFieldDef(def)?arr.push(def):hasConditionalFieldDef(def)&&arr.push(def.condition)}return arr}function forEach(mapping,f,thisArg){if(mapping)for(const channel of keys$jscomp$0(mapping)){const el=mapping[channel];
if(vega.isArray(el))for(const channelDef of el)f.call(thisArg,channelDef,channel);else f.call(thisArg,el,channel)}}function reduce(mapping,f,init,thisArg){return mapping?keys$jscomp$0(mapping).reduce((r,channel)=>{const map=mapping[channel];return vega.isArray(map)?map.reduce((r1,channelDef)=>f.call(thisArg,r1,channelDef,channel),r):f.call(thisArg,r,map,channel)},init):init}function pathGroupingFields(mark,encoding){return keys$jscomp$0(encoding).reduce((details,channel)=>{switch(channel){case "x":case "y":case "href":case "description":case "url":case "x2":case "y2":case "xOffset":case "yOffset":case "theta":case "theta2":case "radius":case "radius2":case "latitude":case "longitude":case "latitude2":case "longitude2":case "text":case "shape":case "angle":case "tooltip":return details;
case "order":if("line"===mark||"trail"===mark)return details;case "detail":case "key":channel=encoding[channel];if(vega.isArray(channel)||isFieldDef(channel))for(var fieldDef of vega.array(channel))fieldDef.aggregate||details.push(vgField(fieldDef,{}));return details;case "size":if("trail"===mark)return details;case "color":case "fill":case "stroke":case "opacity":case "fillOpacity":case "strokeOpacity":case "strokeDash":case "strokeWidth":return(fieldDef=getFieldDef(encoding[channel]))&&!fieldDef.aggregate&&
details.push(vgField(fieldDef,{})),details}},[])}function getCompositeMarkTooltip(tooltipSummary,continuousAxisChannelDef,encodingWithoutContinuousAxis){let withFieldName=3<arguments.length&&void 0!==arguments[3]?arguments[3]:!0;if("tooltip"in encodingWithoutContinuousAxis)return{tooltip:encodingWithoutContinuousAxis.tooltip};const fiveSummaryTooltip=tooltipSummary.map(_ref=>{let {fieldPrefix,titlePrefix}=_ref;_ref=withFieldName?` of ${getTitle(continuousAxisChannelDef)}`:"";return{field:fieldPrefix+
continuousAxisChannelDef.field,type:continuousAxisChannelDef.type,title:isSignalRef(titlePrefix)?{signal:`${titlePrefix}"${escape(_ref)}"`}:titlePrefix+_ref}}),tooltipFieldDefs=fieldDefs(encodingWithoutContinuousAxis).map(toStringFieldDef);return{tooltip:[...fiveSummaryTooltip,...unique(tooltipFieldDefs,hash)]}}function getTitle(continuousAxisChannelDef){const {title,field}=continuousAxisChannelDef;return getFirstDefined(title,field)}function makeCompositeAggregatePartFactory(compositeMarkDef,continuousAxis,
continuousAxisChannelDef,sharedEncoding,compositeMarkConfig){const {scale,axis}=continuousAxisChannelDef;return _ref2=>{let {partName,mark,positionPrefix,endPositionPrefix,extraEncoding={}}=_ref2;_ref2=getTitle(continuousAxisChannelDef);return partLayerMixins(compositeMarkDef,partName,compositeMarkConfig,{mark,encoding:{[continuousAxis]:{field:`${positionPrefix}_${continuousAxisChannelDef.field}`,type:continuousAxisChannelDef.type,...(void 0!==_ref2?{title:_ref2}:{}),...(void 0!==scale?{scale}:{}),
...(void 0!==axis?{axis}:{})},...(vega.isString(endPositionPrefix)?{[`${continuousAxis}2`]:{field:`${endPositionPrefix}_${continuousAxisChannelDef.field}`}}:{}),...sharedEncoding,...extraEncoding}})}}function partLayerMixins(markDef,part,compositeMarkConfig,partBaseSpec){const {clip,color,opacity}=markDef,mark=markDef.type;return markDef[part]||void 0===markDef[part]&&compositeMarkConfig[part]?[{...partBaseSpec,mark:{...compositeMarkConfig[part],...(clip?{clip}:{}),...(color?{color}:{}),...(opacity?
{opacity}:{}),...(isMarkDef(partBaseSpec.mark)?partBaseSpec.mark:{type:partBaseSpec.mark}),style:`${mark}-${String(part)}`,...(vega.isBoolean(markDef[part])?{}:markDef[part])}}]:[]}function compositeMarkContinuousAxis(spec,orient,compositeMark){({encoding:spec}=spec);orient="vertical"===orient?"y":"x";const continuousAxisChannelDef2=spec[`${orient}2`],continuousAxisChannelDefError=spec[`${orient}Error`],continuousAxisChannelDefError2=spec[`${orient}Error2`];return{continuousAxisChannelDef:filterAggregateFromChannelDef(spec[orient],
compositeMark),continuousAxisChannelDef2:filterAggregateFromChannelDef(continuousAxisChannelDef2,compositeMark),continuousAxisChannelDefError:filterAggregateFromChannelDef(continuousAxisChannelDefError,compositeMark),continuousAxisChannelDefError2:filterAggregateFromChannelDef(continuousAxisChannelDefError2,compositeMark),continuousAxis:orient}}function filterAggregateFromChannelDef(continuousAxisChannelDef,compositeMark){if(continuousAxisChannelDef?.aggregate){const {aggregate,...continuousAxisWithoutAggregate}=
continuousAxisChannelDef;aggregate!==compositeMark&&warn(`Continuous axis should not have customized aggregation function ${aggregate}; ${compositeMark} already agregates the axis.`);return continuousAxisWithoutAggregate}return continuousAxisChannelDef}function compositeMarkOrient(spec,compositeMark){const {mark,encoding}=spec,{x,y}=encoding;if(isMarkDef(mark)&&mark.orient)return mark.orient;if(isContinuousFieldOrDatumDef(x)){if(isContinuousFieldOrDatumDef(y)){spec=isFieldDef(x)&&x.aggregate;const yAggregate=
isFieldDef(y)&&y.aggregate;if(!spec&&yAggregate===compositeMark)return"vertical";if(yAggregate||spec!==compositeMark){if(spec===compositeMark&&yAggregate===compositeMark)throw Error("Both x and y cannot have aggregate");return isFieldOrDatumDefForTimeFormat(y)&&!isFieldOrDatumDefForTimeFormat(x)?"horizontal":"vertical"}}return"horizontal"}if(isContinuousFieldOrDatumDef(y))return"vertical";throw Error(`Need a valid continuous axis for ${compositeMark}s`);}function getBoxPlotType(extent){return vega.isNumber(extent)?
"tukey":extent}function normalizeBoxPlot(spec$jscomp$0,_ref){({config:_ref}=_ref);spec$jscomp$0={...spec$jscomp$0,encoding:normalizeEncoding(spec$jscomp$0.encoding,_ref)};const {mark,encoding:_encoding,params,projection:_p,...outerSpec}=spec$jscomp$0;var markDef=isMarkDef(mark)?mark:{type:mark};params&&warn(selectionNotSupported("boxplot"));var extent=markDef.extent??_ref.boxplot.extent,sizeValue=getMarkPropOrConfig("size",markDef,_ref),invalid=markDef.invalid,boxPlotType=getBoxPlotType(extent),spec=
spec$jscomp$0;spec$jscomp$0=compositeMarkOrient(spec,"boxplot");const {continuousAxisChannelDef,continuousAxis}=compositeMarkContinuousAxis(spec,spec$jscomp$0,"boxplot");var continuousFieldName=continuousAxisChannelDef.field;const boxPlotType$jscomp$0=getBoxPlotType(extent);var boxplotSpecificAggregate=[...boxParamsQuartiles(continuousFieldName),{op:"median",field:continuousFieldName,as:`mid_box_${continuousFieldName}`},{op:"min",field:continuousFieldName,as:("min-max"===boxPlotType$jscomp$0?"lower_whisker_":
"min_")+continuousFieldName},{op:"max",field:continuousFieldName,as:("min-max"===boxPlotType$jscomp$0?"upper_whisker_":"max_")+continuousFieldName}];continuousFieldName="min-max"===boxPlotType$jscomp$0||"tukey"===boxPlotType$jscomp$0?[]:[{calculate:`datum["upper_box_${continuousFieldName}"] - datum["lower_box_${continuousFieldName}"]`,as:`iqr_${continuousFieldName}`},{calculate:`min(datum["upper_box_${continuousFieldName}"] + datum["iqr_${continuousFieldName}"] * ${extent}, datum["max_${continuousFieldName}"])`,
as:`upper_whisker_${continuousFieldName}`},{calculate:`max(datum["lower_box_${continuousFieldName}"] - datum["iqr_${continuousFieldName}"] * ${extent}, datum["min_${continuousFieldName}"])`,as:`lower_whisker_${continuousFieldName}`}];({...spec}=spec.encoding);var JSCompiler_inline_result;{const {tooltip,...filteredEncoding}=spec;if(tooltip){var customTooltipWithoutAggregatedField;if(vega.isArray(tooltip)){for(var t of tooltip)t.aggregate?(JSCompiler_inline_result||(JSCompiler_inline_result=[]),JSCompiler_inline_result.push(t)):
(customTooltipWithoutAggregatedField||(customTooltipWithoutAggregatedField=[]),customTooltipWithoutAggregatedField.push(t));JSCompiler_inline_result&&(filteredEncoding.tooltip=JSCompiler_inline_result)}else tooltip.aggregate?filteredEncoding.tooltip=tooltip:customTooltipWithoutAggregatedField=tooltip;vega.isArray(customTooltipWithoutAggregatedField)&&1===customTooltipWithoutAggregatedField.length&&(customTooltipWithoutAggregatedField=customTooltipWithoutAggregatedField[0]);JSCompiler_inline_result=
{customTooltipWithoutAggregatedField,filteredEncoding}}else JSCompiler_inline_result={filteredEncoding}}const {customTooltipWithoutAggregatedField:customTooltipWithoutAggregatedField$jscomp$0,filteredEncoding:filteredEncoding$jscomp$0}=JSCompiler_inline_result,{bins,timeUnits,aggregate,groupby,encoding:encodingWithoutContinuousAxis}=extractTransformsFromEncoding(filteredEncoding$jscomp$0,_ref);JSCompiler_inline_result=[...bins,...timeUnits,{aggregate:[...aggregate,...boxplotSpecificAggregate],groupby},
...continuousFieldName];const {bins:bins$jscomp$0,timeUnits:timeUnits$jscomp$0,transform,continuousAxisChannelDef:continuousAxisChannelDef$jscomp$0,continuousAxis:continuousAxis$jscomp$0,groupby:groupby$jscomp$0,aggregate:aggregate$jscomp$0,encodingWithoutContinuousAxis:encodingWithoutContinuousAxis$jscomp$0,ticksOrient,boxOrient,customTooltipWithoutAggregatedField:customTooltipWithoutAggregatedField$jscomp$2}={bins,timeUnits,transform:JSCompiler_inline_result,groupby,aggregate,continuousAxisChannelDef,
continuousAxis,encodingWithoutContinuousAxis,ticksOrient:"vertical"===spec$jscomp$0?"horizontal":"vertical",boxOrient:spec$jscomp$0,customTooltipWithoutAggregatedField:customTooltipWithoutAggregatedField$jscomp$0},{color,size,...encodingWithoutSizeColorAndContinuousAxis}=encodingWithoutContinuousAxis$jscomp$0;spec$jscomp$0=makeCompositeAggregatePartFactory(markDef,continuousAxis$jscomp$0,continuousAxisChannelDef$jscomp$0,encodingWithoutSizeColorAndContinuousAxis,_ref.boxplot);JSCompiler_inline_result=
makeCompositeAggregatePartFactory(markDef,continuousAxis$jscomp$0,continuousAxisChannelDef$jscomp$0,encodingWithoutContinuousAxis$jscomp$0,_ref.boxplot);customTooltipWithoutAggregatedField=makeCompositeAggregatePartFactory(markDef,continuousAxis$jscomp$0,continuousAxisChannelDef$jscomp$0,{...encodingWithoutSizeColorAndContinuousAxis,...(size?{size}:{})},_ref.boxplot);t=getCompositeMarkTooltip([{fieldPrefix:"min-max"===boxPlotType?"upper_whisker_":"max_",titlePrefix:"Max"},{fieldPrefix:"upper_box_",
titlePrefix:"Q3"},{fieldPrefix:"mid_box_",titlePrefix:"Median"},{fieldPrefix:"lower_box_",titlePrefix:"Q1"},{fieldPrefix:"min-max"===boxPlotType?"lower_whisker_":"min_",titlePrefix:"Min"}],continuousAxisChannelDef$jscomp$0,encodingWithoutContinuousAxis$jscomp$0);boxplotSpecificAggregate={type:"tick",color:"black",opacity:1,orient:ticksOrient,invalid,aria:!1};spec="min-max"===boxPlotType?t:getCompositeMarkTooltip([{fieldPrefix:"upper_whisker_",titlePrefix:"Upper Whisker"},{fieldPrefix:"lower_whisker_",
titlePrefix:"Lower Whisker"}],continuousAxisChannelDef$jscomp$0,encodingWithoutContinuousAxis$jscomp$0);spec$jscomp$0=[...spec$jscomp$0({partName:"rule",mark:{type:"rule",invalid,aria:!1},positionPrefix:"lower_whisker",endPositionPrefix:"lower_box",extraEncoding:spec}),...spec$jscomp$0({partName:"rule",mark:{type:"rule",invalid,aria:!1},positionPrefix:"upper_box",endPositionPrefix:"upper_whisker",extraEncoding:spec}),...spec$jscomp$0({partName:"ticks",mark:boxplotSpecificAggregate,positionPrefix:"lower_whisker",
extraEncoding:spec}),...spec$jscomp$0({partName:"ticks",mark:boxplotSpecificAggregate,positionPrefix:"upper_whisker",extraEncoding:spec})];sizeValue=[...("tukey"!==boxPlotType?spec$jscomp$0:[]),...JSCompiler_inline_result({partName:"box",mark:{type:"bar",...(sizeValue?{size:sizeValue}:{}),orient:boxOrient,invalid,ariaRoleDescription:"box"},positionPrefix:"lower_box",endPositionPrefix:"upper_box",extraEncoding:t}),...customTooltipWithoutAggregatedField({partName:"median",mark:{type:"tick",invalid,
...(vega.isObject(_ref.boxplot.median)&&_ref.boxplot.median.color?{color:_ref.boxplot.median.color}:{}),...(sizeValue?{size:sizeValue}:{}),orient:ticksOrient,aria:!1},positionPrefix:"mid_box",extraEncoding:t})];if("min-max"===boxPlotType)return{...outerSpec,transform:(outerSpec.transform??[]).concat(transform),layer:sizeValue};boxPlotType=`datum["lower_box_${continuousAxisChannelDef$jscomp$0.field}"]`;invalid=`datum["upper_box_${continuousAxisChannelDef$jscomp$0.field}"]`;JSCompiler_inline_result=
`(${invalid} - ${boxPlotType})`;boxPlotType=`${boxPlotType} - ${extent} * ${JSCompiler_inline_result}`;JSCompiler_inline_result=`${invalid} + ${extent} * ${JSCompiler_inline_result}`;customTooltipWithoutAggregatedField=`datum["${continuousAxisChannelDef$jscomp$0.field}"]`;extent={joinaggregate:boxParamsQuartiles(continuousAxisChannelDef$jscomp$0.field),groupby:groupby$jscomp$0};invalid={transform:[{filter:`(${boxPlotType} <= ${customTooltipWithoutAggregatedField}) && (${customTooltipWithoutAggregatedField} <= ${JSCompiler_inline_result})`},
{aggregate:[{op:"min",field:continuousAxisChannelDef$jscomp$0.field,as:`lower_whisker_${continuousAxisChannelDef$jscomp$0.field}`},{op:"max",field:continuousAxisChannelDef$jscomp$0.field,as:`upper_whisker_${continuousAxisChannelDef$jscomp$0.field}`},{op:"min",field:`lower_box_${continuousAxisChannelDef$jscomp$0.field}`,as:`lower_box_${continuousAxisChannelDef$jscomp$0.field}`},{op:"max",field:`upper_box_${continuousAxisChannelDef$jscomp$0.field}`,as:`upper_box_${continuousAxisChannelDef$jscomp$0.field}`},
...aggregate$jscomp$0],groupby:groupby$jscomp$0}],layer:spec$jscomp$0};const {tooltip:tooltip$jscomp$0,...encodingWithoutSizeColorContinuousAxisAndTooltip}=encodingWithoutSizeColorAndContinuousAxis,{scale,axis}=continuousAxisChannelDef$jscomp$0;spec$jscomp$0=getTitle(continuousAxisChannelDef$jscomp$0);t=omit(axis,["title"]);_ref=partLayerMixins(markDef,"outliers",_ref.boxplot,{transform:[{filter:`(${customTooltipWithoutAggregatedField} < ${boxPlotType}) || (${customTooltipWithoutAggregatedField} > ${JSCompiler_inline_result})`}],
mark:"point",encoding:{[continuousAxis$jscomp$0]:{field:continuousAxisChannelDef$jscomp$0.field,type:continuousAxisChannelDef$jscomp$0.type,...(void 0!==spec$jscomp$0?{title:spec$jscomp$0}:{}),...(void 0!==scale?{scale}:{}),...(isEmpty(t)?{}:{axis:t})},...encodingWithoutSizeColorContinuousAxisAndTooltip,...(color?{color}:{}),...(customTooltipWithoutAggregatedField$jscomp$2?{tooltip:customTooltipWithoutAggregatedField$jscomp$2}:{})}})[0];markDef=[...bins$jscomp$0,...timeUnits$jscomp$0,extent];_ref?
_ref={transform:markDef,layer:[_ref,invalid]}:(_ref=invalid,_ref.transform.unshift(...markDef));return{...outerSpec,layer:[_ref,{transform,layer:sizeValue}]}}function boxParamsQuartiles(continousAxisField){return[{op:"q1",field:continousAxisField,as:`lower_box_${continousAxisField}`},{op:"q3",field:continousAxisField,as:`upper_box_${continousAxisField}`}]}function normalizeErrorBar(spec,_ref){({config:_ref}=_ref);spec={...spec,encoding:normalizeEncoding(spec.encoding,_ref)};const {transform,continuousAxisChannelDef,
continuousAxis,encodingWithoutContinuousAxis,ticksOrient,markDef,outerSpec,tooltipEncoding}=errorBarParams(spec,"errorbar",_ref);delete encodingWithoutContinuousAxis.size;spec=makeCompositeAggregatePartFactory(markDef,continuousAxis,continuousAxisChannelDef,encodingWithoutContinuousAxis,_ref.errorbar);_ref=markDef.thickness;var size=markDef.size;size={type:"tick",orient:ticksOrient,aria:!1,...(void 0!==_ref?{thickness:_ref}:{}),...(void 0!==size?{size}:{})};spec=[...spec({partName:"ticks",mark:size,
positionPrefix:"lower",extraEncoding:tooltipEncoding}),...spec({partName:"ticks",mark:size,positionPrefix:"upper",extraEncoding:tooltipEncoding}),...spec({partName:"rule",mark:{type:"rule",ariaRoleDescription:"errorbar",...(void 0!==_ref?{size:_ref}:{})},positionPrefix:"lower",endPositionPrefix:"upper",extraEncoding:tooltipEncoding})];return{...outerSpec,transform,...(1<spec.length?{layer:spec}:{...spec[0]})}}function errorBarOrientAndInputType(spec,compositeMark){var {encoding}=spec;if(!(!isFieldOrDatumDef(encoding.x)&&
!isFieldOrDatumDef(encoding.y)||isFieldOrDatumDef(encoding.x2)||isFieldOrDatumDef(encoding.y2)||isFieldOrDatumDef(encoding.xError)||isFieldOrDatumDef(encoding.xError2)||isFieldOrDatumDef(encoding.yError)||isFieldOrDatumDef(encoding.yError2)))return{orient:compositeMarkOrient(spec,compositeMark),inputType:"raw"};var JSCompiler_inline_result=isFieldOrDatumDef(encoding.x2)||isFieldOrDatumDef(encoding.y2);var JSCompiler_inline_result$jscomp$0=isFieldOrDatumDef(encoding.xError)||isFieldOrDatumDef(encoding.xError2)||
isFieldOrDatumDef(encoding.yError)||isFieldOrDatumDef(encoding.yError2);spec=encoding.x;const y=encoding.y;if(JSCompiler_inline_result){if(JSCompiler_inline_result$jscomp$0)throw Error(`${compositeMark} cannot be both type aggregated-upper-lower and aggregated-error`);JSCompiler_inline_result=encoding.x2;encoding=encoding.y2;if(isFieldOrDatumDef(JSCompiler_inline_result)&&isFieldOrDatumDef(encoding))throw Error(`${compositeMark} cannot have both x2 and y2`);if(isFieldOrDatumDef(JSCompiler_inline_result)){if(isContinuousFieldOrDatumDef(spec))return{orient:"horizontal",
inputType:"aggregated-upper-lower"};throw Error(`Both x and x2 have to be quantitative in ${compositeMark}`);}if(isFieldOrDatumDef(encoding)){if(isContinuousFieldOrDatumDef(y))return{orient:"vertical",inputType:"aggregated-upper-lower"};throw Error(`Both y and y2 have to be quantitative in ${compositeMark}`);}}else{JSCompiler_inline_result=encoding.xError;JSCompiler_inline_result$jscomp$0=encoding.yError;const yError2=encoding.yError2;if(isFieldOrDatumDef(encoding.xError2)&&!isFieldOrDatumDef(JSCompiler_inline_result))throw Error(`${compositeMark} cannot have xError2 without xError`);
if(isFieldOrDatumDef(yError2)&&!isFieldOrDatumDef(JSCompiler_inline_result$jscomp$0))throw Error(`${compositeMark} cannot have yError2 without yError`);if(isFieldOrDatumDef(JSCompiler_inline_result)&&isFieldOrDatumDef(JSCompiler_inline_result$jscomp$0))throw Error(`${compositeMark} cannot have both xError and yError with both are quantiative`);if(isFieldOrDatumDef(JSCompiler_inline_result)){if(isContinuousFieldOrDatumDef(spec))return{orient:"horizontal",inputType:"aggregated-error"};throw Error("All x, xError, and xError2 (if exist) have to be quantitative");
}if(isFieldOrDatumDef(JSCompiler_inline_result$jscomp$0)){if(isContinuousFieldOrDatumDef(y))return{orient:"vertical",inputType:"aggregated-error"};throw Error("All y, yError, and yError2 (if exist) have to be quantitative");}}throw Error("No ranged axis");}function errorBarParams(spec,compositeMark,config){const {mark,encoding,params,projection:_p,...outerSpec}=spec,markDef=isMarkDef(mark)?mark:{type:mark};params&&warn(selectionNotSupported(compositeMark));const {orient,inputType}=errorBarOrientAndInputType(spec,
compositeMark),{continuousAxisChannelDef,continuousAxisChannelDef2,continuousAxisChannelDefError,continuousAxisChannelDefError2,continuousAxis}=compositeMarkContinuousAxis(spec,orient,compositeMark);spec=[];var postAggregateCalculates=[],continuousFieldName=continuousAxisChannelDef.field,tooltipTitleWithFieldName$jscomp$0=!1;if("raw"===inputType){var tooltipSummary=markDef.center?markDef.center:markDef.extent?"iqr"===markDef.extent?"median":"mean":config.errorbar.center;var extent=markDef.extent?
markDef.extent:"mean"===tooltipSummary?"stderr":"iqr";"median"===tooltipSummary!==("iqr"===extent)&&warn(`${tooltipSummary} is not usually used with ${extent} for ${compositeMark}.`);"stderr"===extent||"stdev"===extent?(spec=[{op:extent,field:continuousFieldName,as:`extent_${continuousFieldName}`},{op:tooltipSummary,field:continuousFieldName,as:`center_${continuousFieldName}`}],postAggregateCalculates=[{calculate:`datum["center_${continuousFieldName}"] + datum["extent_${continuousFieldName}"]`,as:`upper_${continuousFieldName}`},
{calculate:`datum["center_${continuousFieldName}"] - datum["extent_${continuousFieldName}"]`,as:`lower_${continuousFieldName}`}],continuousFieldName={fieldPrefix:"center_",titlePrefix:titleCase(tooltipSummary)},tooltipTitleWithFieldName$jscomp$0=extent,tooltipTitleWithFieldName$jscomp$0={fieldPrefix:"upper_",titlePrefix:`${titleCase(tooltipSummary)} ${"+"} ${tooltipTitleWithFieldName$jscomp$0}`},compositeMark=extent,tooltipSummary=`${titleCase(tooltipSummary)} ${"-"} ${compositeMark}`,tooltipSummary=
[continuousFieldName,tooltipTitleWithFieldName$jscomp$0,{fieldPrefix:"lower_",titlePrefix:tooltipSummary}],tooltipTitleWithFieldName$jscomp$0=!0):("ci"===extent?(tooltipSummary="mean",compositeMark="ci0",extent="ci1"):(tooltipSummary="median",compositeMark="q1",extent="q3"),spec=[{op:compositeMark,field:continuousFieldName,as:`lower_${continuousFieldName}`},{op:extent,field:continuousFieldName,as:`upper_${continuousFieldName}`},{op:tooltipSummary,field:continuousFieldName,as:`center_${continuousFieldName}`}],
tooltipSummary=[{fieldPrefix:"upper_",titlePrefix:title$jscomp$0({field:continuousFieldName,aggregate:extent,type:"quantitative"},config,{allowDisabling:!1})},{fieldPrefix:"lower_",titlePrefix:title$jscomp$0({field:continuousFieldName,aggregate:compositeMark,type:"quantitative"},config,{allowDisabling:!1})},{fieldPrefix:"center_",titlePrefix:title$jscomp$0({field:continuousFieldName,aggregate:tooltipSummary,type:"quantitative"},config,{allowDisabling:!1})}])}else{if(markDef.center||markDef.extent){compositeMark=
markDef.center;var extent$jscomp$0=markDef.extent;warn(`${extent$jscomp$0?"extent ":""}${extent$jscomp$0&&compositeMark?"and ":""}${compositeMark?"center ":""}${extent$jscomp$0&&compositeMark?"are ":"is "}not needed when data are aggregated.`)}"aggregated-upper-lower"===inputType?(tooltipSummary=[],postAggregateCalculates=[{calculate:`datum["${continuousAxisChannelDef2.field}"]`,as:`upper_${continuousFieldName}`},{calculate:`datum["${continuousFieldName}"]`,as:`lower_${continuousFieldName}`}]):"aggregated-error"===
inputType&&(tooltipSummary=[{fieldPrefix:"",titlePrefix:continuousFieldName}],postAggregateCalculates=[{calculate:`datum["${continuousFieldName}"] + datum["${continuousAxisChannelDefError.field}"]`,as:`upper_${continuousFieldName}`}],continuousAxisChannelDefError2?postAggregateCalculates.push({calculate:`datum["${continuousFieldName}"] + datum["${continuousAxisChannelDefError2.field}"]`,as:`lower_${continuousFieldName}`}):postAggregateCalculates.push({calculate:`datum["${continuousFieldName}"] - datum["${continuousAxisChannelDefError.field}"]`,
as:`lower_${continuousFieldName}`}));for(extent of postAggregateCalculates)tooltipSummary.push({fieldPrefix:extent.as.substring(0,6),titlePrefix:replaceAll(replaceAll(extent.calculate,'datum["',""),'"]',"")})}const {errorBarSpecificAggregate,postAggregateCalculates:postAggregateCalculates$jscomp$0,tooltipSummary:tooltipSummary$jscomp$0,tooltipTitleWithFieldName}={postAggregateCalculates,errorBarSpecificAggregate:spec,tooltipSummary,tooltipTitleWithFieldName:tooltipTitleWithFieldName$jscomp$0};({...spec}=
encoding);const {bins,timeUnits,aggregate:oldAggregate,groupby:oldGroupBy,encoding:encodingWithoutContinuousAxis}=extractTransformsFromEncoding(spec,config);config=[...oldAggregate,...errorBarSpecificAggregate];spec="raw"!==inputType?[]:oldGroupBy;postAggregateCalculates=getCompositeMarkTooltip(tooltipSummary$jscomp$0,continuousAxisChannelDef,encodingWithoutContinuousAxis,tooltipTitleWithFieldName);return{transform:[...(outerSpec.transform??[]),...bins,...timeUnits,...(0===config.length?[]:[{aggregate:config,
groupby:spec}]),...postAggregateCalculates$jscomp$0],groupby:spec,continuousAxisChannelDef,continuousAxis,encodingWithoutContinuousAxis,ticksOrient:"vertical"===orient?"horizontal":"vertical",markDef,outerSpec,tooltipEncoding:postAggregateCalculates}}function normalizeErrorBand(spec,_ref){({config:_ref}=_ref);spec={...spec,encoding:normalizeEncoding(spec.encoding,_ref)};const {transform,continuousAxisChannelDef,continuousAxis,encodingWithoutContinuousAxis,markDef,outerSpec,tooltipEncoding}=errorBarParams(spec,
"errorband",_ref);_ref=makeCompositeAggregatePartFactory(markDef,continuousAxis,continuousAxisChannelDef,encodingWithoutContinuousAxis,_ref.errorband);spec=void 0!==spec.encoding.x&&void 0!==spec.encoding.y;let bandMark={type:spec?"area":"rect"},bordersMark={type:spec?"line":"rule"};const interpolate={...(markDef.interpolate?{interpolate:markDef.interpolate}:{}),...(markDef.tension&&markDef.interpolate?{tension:markDef.tension}:{})};spec?(bandMark={...bandMark,...interpolate,ariaRoleDescription:"errorband"},
bordersMark={...bordersMark,...interpolate,aria:!1}):markDef.interpolate?warn(errorBand1DNotSupport("interpolate")):markDef.tension&&warn(errorBand1DNotSupport("tension"));return{...outerSpec,transform,layer:[..._ref({partName:"band",mark:bandMark,positionPrefix:"lower",endPositionPrefix:"upper",extraEncoding:tooltipEncoding}),..._ref({partName:"borders",mark:bordersMark,positionPrefix:"lower",extraEncoding:tooltipEncoding}),..._ref({partName:"borders",mark:bordersMark,positionPrefix:"upper",extraEncoding:tooltipEncoding})]}}
function add$jscomp$0(mark,run,parts){run=new CompositeMarkNormalizer(mark,run);compositeMarkRegistry[mark]={normalizer:run,parts}}function isLegendBinding(bind){return"legend"===bind||!!bind?.legend}function isLegendStreamBinding(bind){return isLegendBinding(bind)&&vega.isObject(bind)}function assembleParameterSignals(params){const signals=[];for(const param of params||[]){if(param?.select)continue;const {expr,bind,...rest}=param;bind&&expr?signals.push({...rest,bind,init:expr}):signals.push({...rest,
...(expr?{update:expr}:{}),...(bind?{bind}:{})})}return signals}function getStepFor(_ref){let {step,offsetIsDiscrete}=_ref;return offsetIsDiscrete?step.for??"offset":"position"}function isStep(size){return vega.isObject(size)&&void 0!==size.step}function isFrameMixins(o){return o.view||o.width||o.height}function extractCompositionLayout(spec,specType,config){const layout={},{spacing:spacingConfig,columns}=config[specType];void 0!==spacingConfig&&(layout.spacing=spacingConfig);void 0!==columns&&("facet"in
spec&&!isFacetMapping(spec.facet)||"concat"in spec)&&(layout.columns=columns);"vconcat"in spec&&(layout.columns=1);for(const prop of COMPOSITION_LAYOUT_PROPERTIES)void 0!==spec[prop]&&("spacing"===prop?(specType=spec[prop],layout[prop]=vega.isNumber(specType)?specType:{row:specType.row??spacingConfig,column:specType.column??spacingConfig}):layout[prop]=spec[prop]);return layout}function getViewConfigContinuousSize(viewConfig,channel){return viewConfig[channel]??viewConfig["width"===channel?"continuousWidth":
"continuousHeight"]}function getViewConfigDiscreteStep(viewConfig,channel){viewConfig=getViewConfigDiscreteSize(viewConfig,channel);return isStep(viewConfig)?viewConfig.step:20}function getViewConfigDiscreteSize(viewConfig,channel){return getFirstDefined(viewConfig[channel]??viewConfig["width"===channel?"discreteWidth":"discreteHeight"],{step:viewConfig.step})}function colorSignalConfig(){let color=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{};return{signals:[{name:"color",value:vega.isObject(color)?
{...DEFAULT_COLOR,...color}:DEFAULT_COLOR}],mark:{color:{signal:"color.blue"}},rule:{color:{signal:"color.gray0"}},text:{color:{signal:"color.gray0"}},style:{"guide-label":{fill:{signal:"color.gray0"}},"guide-title":{fill:{signal:"color.gray0"}},"group-title":{fill:{signal:"color.gray0"}},"group-subtitle":{fill:{signal:"color.gray0"}},cell:{stroke:{signal:"color.gray8"}}},axis:{domainColor:{signal:"color.gray13"},gridColor:{signal:"color.gray8"},tickColor:{signal:"color.gray13"}},range:{category:[{signal:"color.blue"},
{signal:"color.orange"},{signal:"color.red"},{signal:"color.teal"},{signal:"color.green"},{signal:"color.yellow"},{signal:"color.purple"},{signal:"color.pink"},{signal:"color.brown"},{signal:"color.grey8"}]}}}function getAxisConfigInternal(axisConfig){var props=keys$jscomp$0(axisConfig||{});const axisConfigInternal={};for(const prop of props)props=axisConfig[prop],axisConfigInternal[prop]=props?.condition?signalOrValueRefWithCondition(props):signalRefOrValue(props);return axisConfigInternal}function initConfig(){const {color,
font,fontSize,selection,...restConfig}=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{};var JSCompiler_temp_const=vega.mergeConfig,JSCompiler_temp_const$jscomp$0=duplicate(defaultConfig),JSCompiler_temp_const$jscomp$1=font?{text:{font},style:{"guide-label":{font},"guide-title":{font},"group-title":{font},"group-subtitle":{font}}}:{},JSCompiler_temp_const$jscomp$2=color?colorSignalConfig(color):{};var JSCompiler_temp=fontSize?{signals:[{name:"fontSize",value:vega.isObject(fontSize)?{...DEFAULT_FONT_SIZE,
...fontSize}:DEFAULT_FONT_SIZE}],text:{fontSize:{signal:"fontSize.text"}},style:{"guide-label":{fontSize:{signal:"fontSize.guideLabel"}},"guide-title":{fontSize:{signal:"fontSize.guideTitle"}},"group-title":{fontSize:{signal:"fontSize.groupTitle"}},"group-subtitle":{fontSize:{signal:"fontSize.groupSubtitle"}}}}:{};JSCompiler_temp_const=JSCompiler_temp_const.call(vega,{},JSCompiler_temp_const$jscomp$0,JSCompiler_temp_const$jscomp$1,JSCompiler_temp_const$jscomp$2,JSCompiler_temp,restConfig||{});selection&&
vega.writeConfig(JSCompiler_temp_const,"selection",selection,!0);JSCompiler_temp_const$jscomp$0=omit(JSCompiler_temp_const,configPropsWithExpr);for(var prop$jscomp$0 of["background","lineBreak","padding"])JSCompiler_temp_const[prop$jscomp$0]&&(JSCompiler_temp_const$jscomp$0[prop$jscomp$0]=signalRefOrValue(JSCompiler_temp_const[prop$jscomp$0]));for(var markConfigType of MARK_CONFIGS)JSCompiler_temp_const[markConfigType]&&(JSCompiler_temp_const$jscomp$0[markConfigType]=replaceExprRef(JSCompiler_temp_const[markConfigType]));
for(var axisConfigType of AXIS_CONFIGS)JSCompiler_temp_const[axisConfigType]&&(JSCompiler_temp_const$jscomp$0[axisConfigType]=getAxisConfigInternal(JSCompiler_temp_const[axisConfigType]));for(const headerConfigType of HEADER_CONFIGS)JSCompiler_temp_const[headerConfigType]&&(JSCompiler_temp_const$jscomp$0[headerConfigType]=replaceExprRef(JSCompiler_temp_const[headerConfigType]));JSCompiler_temp_const.legend&&(JSCompiler_temp_const$jscomp$0.legend=replaceExprRef(JSCompiler_temp_const.legend));JSCompiler_temp_const.scale&&
(JSCompiler_temp_const$jscomp$0.scale=replaceExprRef(JSCompiler_temp_const.scale));if(JSCompiler_temp_const.style){prop$jscomp$0=JSCompiler_temp_const.style;markConfigType=keys$jscomp$0(prop$jscomp$0);axisConfigType={};for(const prop of markConfigType)axisConfigType[prop]=getAxisConfigInternal(prop$jscomp$0[prop]);JSCompiler_temp_const$jscomp$0.style=axisConfigType}JSCompiler_temp_const.title&&(JSCompiler_temp_const$jscomp$0.title=replaceExprRef(JSCompiler_temp_const.title));JSCompiler_temp_const.view&&
(JSCompiler_temp_const$jscomp$0.view=replaceExprRef(JSCompiler_temp_const.view));return JSCompiler_temp_const$jscomp$0}function stripAndRedirectConfig(config){config=duplicate(config);for(var prop$jscomp$0 of VL_ONLY_CONFIG_PROPERTIES)delete config[prop$jscomp$0];if(config.axis)for(var prop$jscomp$1 in config.axis)config.axis[prop$jscomp$1]?.condition&&delete config.axis[prop$jscomp$1];if(config.legend)for(var prop$jscomp$2 of VL_ONLY_LEGEND_CONFIG)delete config.legend[prop$jscomp$2];if(config.mark){for(var prop$jscomp$3 of VL_ONLY_MARK_CONFIG_PROPERTIES)delete config.mark[prop$jscomp$3];
config.mark.tooltip&&vega.isObject(config.mark.tooltip)&&delete config.mark.tooltip}config.params&&(config.signals=(config.signals||[]).concat(assembleParameterSignals(config.params)),delete config.params);for(var markType of MARK_STYLES){for(const prop of VL_ONLY_MARK_CONFIG_PROPERTIES)delete config[markType][prop];if(prop$jscomp$0=VL_ONLY_ALL_MARK_SPECIFIC_CONFIG_PROPERTY_INDEX[markType])for(const prop of prop$jscomp$0)delete config[markType][prop];prop$jscomp$0=config;prop$jscomp$1=markType;prop$jscomp$2=
void 0;prop$jscomp$3=prop$jscomp$0[prop$jscomp$1];"view"===prop$jscomp$1&&(prop$jscomp$2="cell");prop$jscomp$3={...prop$jscomp$3,...prop$jscomp$0.style[prop$jscomp$2??prop$jscomp$1]};isEmpty(prop$jscomp$3)||(prop$jscomp$0.style[prop$jscomp$2??prop$jscomp$1]=prop$jscomp$3);delete prop$jscomp$0[prop$jscomp$1]}for(const m of keys$jscomp$0(compositeMarkRegistry))delete config[m];markType=config;const {titleMarkConfig,subtitleMarkConfig,subtitle}=extractTitleConfig(markType.title);isEmpty(titleMarkConfig)||
(markType.style["group-title"]={...markType.style["group-title"],...titleMarkConfig});isEmpty(subtitleMarkConfig)||(markType.style["group-subtitle"]={...markType.style["group-subtitle"],...subtitleMarkConfig});isEmpty(subtitle)?delete markType.title:markType.title=subtitle;for(const prop in config)vega.isObject(config[prop])&&isEmpty(config[prop])&&delete config[prop];return isEmpty(config)?void 0:config}function isUnbinnedQuantitative(channelDef){return isFieldDef(channelDef)&&"quantitative"===channelDef?.type&&
!channelDef.bin}function potentialStackedChannel(encoding,x){const y="x"===x?"y":"radius";var xDef=encoding[x];encoding=encoding[y];if(isFieldDef(xDef)&&isFieldDef(encoding))if(isUnbinnedQuantitative(xDef)&&isUnbinnedQuantitative(encoding)){if(xDef.stack)return x;if(encoding.stack)return y;const xAggregate=isFieldDef(xDef)&&!!xDef.aggregate,yAggregate=isFieldDef(encoding)&&!!encoding.aggregate;if(xAggregate!==yAggregate)return xAggregate?x:y;xDef=xDef.scale?.type;encoding=encoding.scale?.type;if(xDef&&
"linear"!==xDef)return y;if(encoding&&"linear"!==encoding)return x}else{if(isUnbinnedQuantitative(xDef))return x;if(isUnbinnedQuantitative(encoding))return y}else{if(isUnbinnedQuantitative(xDef))return x;if(isUnbinnedQuantitative(encoding))return y}}function getDimensionChannel(channel){switch(channel){case "x":return"y";case "y":return"x";case "theta":return"radius";case "radius":return"theta"}}function stack$jscomp$1(m,encoding){m=isMarkDef(m)?m.type:m;if(!STACKABLE_MARKS.has(m))return null;const fieldChannel=
potentialStackedChannel(encoding,"x")||potentialStackedChannel(encoding,"theta");if(!fieldChannel)return null;const stackedFieldDef=encoding[fieldChannel];var stackedField=isFieldDef(stackedFieldDef)?vgField(stackedFieldDef,{}):void 0,dimensionChannel=getDimensionChannel(fieldChannel);const groupbyChannels=[],groupbyFields=new Set;if(encoding[dimensionChannel]){var dimensionDef=encoding[dimensionChannel];(dimensionDef=isFieldDef(dimensionDef)?vgField(dimensionDef,{}):void 0)&&dimensionDef!==stackedField&&
(groupbyChannels.push(dimensionChannel),groupbyFields.add(dimensionDef));dimensionChannel="x"===dimensionChannel?"xOffset":"yOffset";dimensionDef=encoding[dimensionChannel];(dimensionDef=isFieldDef(dimensionDef)?vgField(dimensionDef,{}):void 0)&&dimensionDef!==stackedField&&(groupbyChannels.push(dimensionChannel),groupbyFields.add(dimensionDef))}stackedField=NONPOSITION_CHANNELS.reduce((sc,channel)=>{if("tooltip"!==channel&&channelHasField(encoding,channel)){var channelDef=encoding[channel];for(const cDef of vega.array(channelDef)){channelDef=
getFieldDef(cDef);if(channelDef.aggregate)continue;const f=vgField(channelDef,{});f&&groupbyFields.has(f)||sc.push({channel,fieldDef:channelDef})}}return sc},[]);let offset;void 0!==stackedFieldDef.stack?offset=vega.isBoolean(stackedFieldDef.stack)?stackedFieldDef.stack?"zero":null:stackedFieldDef.stack:STACK_BY_DEFAULT_MARKS.has(m)&&(offset="zero");if(!(offset&&offset in STACK_OFFSET_INDEX)||isAggregate$1(encoding)&&0===stackedField.length)return null;if(stackedFieldDef?.scale?.type&&stackedFieldDef?.scale?.type!==
ScaleType.LINEAR)return warn(`Cannot stack non-linear scale (${stackedFieldDef.scale.type}).`),null;if(isFieldOrDatumDef(encoding[getSecondaryRangeChannel(fieldChannel)]))return void 0!==stackedFieldDef.stack&&warn(`Cannot stack "${fieldChannel}" if there is already "${fieldChannel}2".`),null;isFieldDef(stackedFieldDef)&&stackedFieldDef.aggregate&&!SUM_OPS.has(stackedFieldDef.aggregate)&&warn(`Stacking is applied even though the aggregate function is non-summative ("${stackedFieldDef.aggregate}").`);
return{groupbyChannels,groupbyFields,fieldChannel,impute:null===stackedFieldDef.impute?!1:isPathMark(m),stackBy:stackedField,offset}}function getPointOverlay(markDef){let markConfig=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{},encoding=2<arguments.length?arguments[2]:void 0;if("transparent"===markDef.point)return{opacity:0};if(markDef.point)return vega.isObject(markDef.point)?markDef.point:{};if(void 0!==markDef.point)return null;if(markConfig.point||encoding.shape)return vega.isObject(markConfig.point)?
markConfig.point:{}}function getLineOverlay(markDef){let markConfig=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{};if(markDef.line)return!0===markDef.line?{}:markDef.line;if(void 0!==markDef.line)return null;if(markConfig.line)return!0===markConfig.line?{}:markConfig.line}function replaceRepeaterInEncoding(encoding,repeater){return repeater?replaceRepeaterInMapping(encoding,repeater):encoding}function replaceRepeatInProp(prop,o,repeater){const val=o[prop];if(val&&!vega.isString(val)&&"repeat"in
val){if(val.repeat in repeater)return{...o,[prop]:repeater[val.repeat]};warn(`Unknown repeated value "${val.repeat}".`)}else return o}function replaceRepeaterInFieldDef(fieldDef,repeater){fieldDef=replaceRepeatInProp("field",fieldDef,repeater);if(void 0!==fieldDef){if(null===fieldDef)return null;"sort"in fieldDef&&isSortField(fieldDef.sort)&&(repeater=replaceRepeatInProp("field",fieldDef.sort,repeater),fieldDef={...fieldDef,...(repeater?{sort:repeater}:{})});return fieldDef}}function replaceRepeaterInFieldOrDatumDef(def,
repeater){if(isFieldDef(def))return replaceRepeaterInFieldDef(def,repeater);repeater=replaceRepeatInProp("datum",def,repeater);repeater===def||repeater.type||(repeater.type="nominal");return repeater}function replaceRepeaterInChannelDef(channelDef,repeater){if(isFieldOrDatumDef(channelDef)){if(repeater=replaceRepeaterInFieldOrDatumDef(channelDef,repeater))return repeater;if(isConditionalDef(channelDef))return{condition:channelDef.condition}}else{if(hasConditionalFieldOrDatumDef(channelDef)){if(repeater=
replaceRepeaterInFieldOrDatumDef(channelDef.condition,repeater))return{...channelDef,condition:repeater};const {condition,...channelDefWithoutCondition}=channelDef;return channelDefWithoutCondition}return channelDef}}function replaceRepeaterInMapping(mapping,repeater){const out={};for(const channel in mapping)if(vega.hasOwnProperty(mapping,channel)){var channelDef=mapping[channel];vega.isArray(channelDef)?out[channel]=channelDef.map(cd=>replaceRepeaterInChannelDef(cd,repeater)).filter(cd=>cd):(channelDef=
replaceRepeaterInChannelDef(channelDef,repeater),void 0!==channelDef&&(out[channel]=channelDef))}return out}function mergeEncoding(_ref2){let {parentEncoding,encoding={},layer}=_ref2;_ref2={};if(parentEncoding){var channels=new Set([...keys$jscomp$0(parentEncoding),...keys$jscomp$0(encoding)]);for(const channel of channels){channels=encoding[channel];const parentChannelDef=parentEncoding[channel];if(isFieldOrDatumDef(channels))_ref2[channel]={...parentChannelDef,...channels};else if(hasConditionalFieldOrDatumDef(channels))_ref2[channel]=
{...channels,condition:{...parentChannelDef,...channels.condition}};else if(channels||null===channels)_ref2[channel]=channels;else if(layer||isValueDef(parentChannelDef)||isSignalRef(parentChannelDef)||isFieldOrDatumDef(parentChannelDef)||vega.isArray(parentChannelDef))_ref2[channel]=parentChannelDef}}else _ref2=encoding;return!_ref2||isEmpty(_ref2)?void 0:_ref2}function mergeProjection(opt){const {parentProjection:parentProjection$jscomp$0,projection:projection$jscomp$0}=opt;if(parentProjection$jscomp$0&&
projection$jscomp$0){const {parentProjection,projection}={parentProjection:parentProjection$jscomp$0,projection:projection$jscomp$0};opt=`Layer's shared projection ${stringify(parentProjection)} is overridden by a child projection ${stringify(projection)}.`;warn(opt)}return projection$jscomp$0??parentProjection$jscomp$0}function normalizeTransform(transform){return transform.map(t=>"filter"in t?{filter:normalizeLogicalComposition(t.filter,normalizePredicate$1)}:t)}function normalizeTransforms(spec,
normParams){const {transform:tx,...rest}=spec;return tx?(spec=tx.map(t=>{if("filter"in t)return{filter:normalizePredicate(t,normParams)};if("bin"in t&&vega.isObject(t.bin))return{...t,bin:normalizeBinExtent(t.bin)};if("lookup"in t){const {selection:param,...from}=t.from;return param?{...t,from:{param,...from}}:t}return t}),{...rest,transform:spec}):spec}function normalizeChannelDef(obj,normParams){obj=duplicate(obj);isFieldDef(obj)&&vega.isObject(obj.bin)&&(obj.bin=normalizeBinExtent(obj.bin));if(isScaleFieldDef(obj)&&
obj.scale?.domain?.selection){const {selection:param,...domain}=obj.scale.domain;obj.scale.domain={...domain,...(param?{param}:{})}}if(isConditionalDef(obj))if(vega.isArray(obj.condition))obj.condition=obj.condition.map(c=>{const {selection,param,test,...cond}=c;return param?c:{...cond,test:normalizePredicate(c,normParams)}});else{const {selection,param,test,...cond}=normalizeChannelDef(obj.condition,normParams);obj.condition=param?obj.condition:{...cond,test:normalizePredicate(obj.condition,normParams)}}return obj}
function normalizeBinExtent(bin){const ext=bin.extent;if(ext?.selection){const {selection:param,...rest}=ext;return{...bin,extent:{...rest,param}}}return bin}function normalizePredicate(op,normParams){const normalizeSelectionComposition=o=>normalizeLogicalComposition(o,param=>{const pred={param,empty:normParams.emptySelections[param]??!0};let $jscomp$logical$assign$tmp730812712$3;($jscomp$logical$assign$tmp730812712$3=normParams.selectionPredicates)[param]??($jscomp$logical$assign$tmp730812712$3[param]=
[]);normParams.selectionPredicates[param].push(pred);return pred});return op.selection?normalizeSelectionComposition(op.selection):normalizeLogicalComposition(op.test||op.filter,o=>o.selection?normalizeSelectionComposition(o.selection):o)}function addSpecNameToParams(spec,params){return spec.name?{...params,path:(params.path??[]).concat(spec.name)}:params}function normalize$jscomp$0(spec,config){void 0===config&&(config=initConfig(spec.config));const normalizedSpec=normalizeGenericSpec(spec,config),
{width:width$jscomp$0,height:height$jscomp$0}=spec;{let {width,height}={width:width$jscomp$0,height:height$jscomp$0,autosize:spec.autosize};spec=isUnitSpec(normalizedSpec)||"layer"in normalizedSpec;const autosizeDefault={};spec?"container"==width&&"container"==height?(autosizeDefault.type="fit",autosizeDefault.contains="padding"):"container"==width?(autosizeDefault.type="fit-x",autosizeDefault.contains="padding"):"container"==height&&(autosizeDefault.type="fit-y",autosizeDefault.contains="padding"):
("container"==width&&(warn(containerSizeNonSingle("width")),width=void 0),"container"==height&&(warn(containerSizeNonSingle("height")),height=void 0));config={type:"pad",...autosizeDefault,...(config?_normalizeAutoSize(config.autosize):{}),..._normalizeAutoSize(normalizedSpec.autosize)};"fit"!==config.type||spec||(warn('Autosize "fit" only works for single views and layered views.'),config.type="pad");"container"==width&&"fit"!=config.type&&"fit-x"!=config.type&&warn(containerSizeNotCompatibleWithAutosize("width"));
"container"==height&&"fit"!=config.type&&"fit-y"!=config.type&&warn(containerSizeNotCompatibleWithAutosize("height"));config=deepEqual(config,{type:"pad"})?void 0:config}return{...normalizedSpec,...(config?{autosize:config}:{})}}function normalizeGenericSpec(spec){const normParams={config:1<arguments.length&&void 0!==arguments[1]?arguments[1]:{}};return topLevelSelectionNormalizer.map(coreNormalizer.map(selectionCompatNormalizer.map(spec,normParams),normParams),normParams)}function _normalizeAutoSize(autosize){return vega.isString(autosize)?
{type:autosize}:autosize??{}}function extractTopLevelProperties(t,includeParams){const o={};for(const p of TOP_LEVEL_PROPERTIES)t&&void 0!==t[p]&&(o[p]=signalRefOrValue(t[p]));includeParams&&(o.params=t.params);return o}function makeExplicit(value){return{explicit:!0,value}}function makeImplicit(value){return{explicit:!1,value}}function tieBreakByComparing(compare){return(v1,v2,property,propertyOf)=>{const diff=compare(v1.value,v2.value);return 0<diff?v1:0>diff?v2:defaultTieBreaker(v1,v2,property,
propertyOf)}}function defaultTieBreaker(v1$jscomp$0,v2,property,propertyOf){if(v1$jscomp$0.explicit&&v2.explicit){var v1=v1$jscomp$0.value;v2=v2.value;property=`Conflicting ${propertyOf.toString()} property "${property.toString()}" (${stringify(v1)} and ${stringify(v2)}). Using ${stringify(v1)}.`;warn(property)}return v1$jscomp$0}function mergeValuesWithExplicit(v1,v2,property,propertyOf){let tieBreaker=4<arguments.length&&void 0!==arguments[4]?arguments[4]:defaultTieBreaker;return void 0===v1||void 0===
v1.value?v2:v1.explicit&&!v2.explicit?v1:v2.explicit&&!v1.explicit?v2:deepEqual(v1.value,v2.value)?v1:tieBreaker(v1,v2,property,propertyOf)}function isNamedData(data){return"name"in data&&!("url"in data)&&!("values"in data)&&!isGenerator(data)}function isGenerator(data){return data&&("sequence"in data||"sphere"in data||"graticule"in data)}function assembleInit(init){let isExpr=1<arguments.length&&void 0!==arguments[1]?arguments[1]:!0,wrap=2<arguments.length&&void 0!==arguments[2]?arguments[2]:vega.identity;
if(vega.isArray(init)){const assembled=init.map(v=>assembleInit(v,isExpr,wrap));return isExpr?`[${assembled.join(", ")}]`:assembled}return isDateTime(init)?isExpr?wrap(dateTimeToExpr(init)):wrap(dateTimeToTimestamp(init)):isExpr?wrap(stringify(init)):init}function assembleFacetSignals(model,signals){model.component.selection&&keys$jscomp$0(model.component.selection).length&&(model=vega.stringValue(model.getName("cell")),signals.unshift({name:"facet",value:{},on:[{events:vega.parseSelector("mousemove",
"scope"),update:`isTuple(facet) ? facet : group(${model}).datum`}]}));return cleanupEmptyOnArray(signals)}function assembleTopLevelSignals(model,signals){var hasSelections=!1;for(const selCmpt of vals$jscomp$0(model.component.selection??{})){const name=selCmpt.name;hasSelections=vega.stringValue(name+"_store");if(0===signals.filter(s=>s.name===name).length){const isPoint="point"===selCmpt.type?", true, true)":")";signals.push({name:selCmpt.name,update:`${"vlSelectionResolve"}(${hasSelections}, ${vega.stringValue("global"===
selCmpt.resolve?"union":selCmpt.resolve)}${isPoint}`})}hasSelections=!0;for(const c of selectionCompilers)c.defined(selCmpt)&&c.topLevelSignals&&(signals=c.topLevelSignals(model,selCmpt,signals))}hasSelections&&0===signals.filter(s=>"unit"===s.name).length&&signals.unshift({name:"unit",value:{},on:[{events:"mousemove",update:"isTuple(group()) ? group() : unit"}]});return cleanupEmptyOnArray(signals)}function assembleUnitSelectionData(model,data){data=[...data];const unit=unitName(model,{escape:!1});
for(const selCmpt of vals$jscomp$0(model.component.selection??{})){model={name:selCmpt.name+"_store"};selCmpt.project.hasSelectionId&&(model.transform=[{type:"collect",sort:{field:"_vgsid_"}}]);if(selCmpt.init){const fields=selCmpt.project.items.map(proj=>{const {signals,...rest}=proj;return rest});model.values=selCmpt.project.hasSelectionId?selCmpt.init.map(i=>({unit,_vgsid_:assembleInit(i,!1)[0]})):selCmpt.init.map(i=>({unit,fields,values:assembleInit(i,!1)}))}data.filter(d=>d.name===selCmpt.name+
"_store").length||data.push(model)}return data}function assembleUnitSelectionMarks(model,marks){for(const selCmpt of vals$jscomp$0(model.component.selection??{}))for(const c of selectionCompilers)c.defined(selCmpt)&&c.marks&&(marks=c.marks(model,selCmpt,marks));return marks}function assembleLayerSelectionMarks(model,marks){for(const child of model.children)isUnitModel(child)&&(marks=assembleUnitSelectionMarks(child,marks));return marks}function cleanupEmptyOnArray(signals){return signals.map(s=>{s.on&&
!s.on.length&&delete s.on;return s})}function domain$jscomp$0(model,channel){return`domain(${vega.stringValue(model.scaleName(channel))})`}function isTopLevelLayer(model){return model.parent&&isLayerModel(model.parent)&&!model.parent.parent}function channelSignals(model,selCmpt,proj,init){const channel=proj.channel,vname=proj.signals.visual;proj=proj.signals.data;const hasScales=scaleBindings.defined(selCmpt),scaleName=vega.stringValue(model.scaleName(channel));var scale=model.getScaleComponent(channel);
scale=scale?scale.get("type"):void 0;const scaled=str=>`scale(${scaleName}, ${str})`,size=model.getSizeSignalRef("x"===channel?"width":"height").signal,coord=`${channel}(unit)`;model=events$jscomp$0(selCmpt,(def,evt)=>[...def,{events:evt.between[0],update:`[${coord}, ${coord}]`},{events:evt,update:`[${vname}[0], clamp(${coord}, 0, ${size})]`}]);model.push({events:{signal:selCmpt.name+"_scale_trigger"},update:hasContinuousDomain(scale)?`[${scaled(`${proj}[0]`)}, ${scaled(`${proj}[1]`)}]`:"[0, 0]"});
return hasScales?[{name:proj,on:[]}]:[{name:vname,...(init?{init:assembleInit(init,!0,scaled)}:{value:[]}),on:model},{name:proj,...(init?{init:assembleInit(init)}:{}),on:[{events:{signal:vname},update:`${vname}[0] === ${vname}[1] ? null : invert(${scaleName}, ${vname})`}]}]}function events$jscomp$0(selCmpt,cb){return selCmpt.events.reduce((on,evt)=>evt.between?cb(on,evt):(warn(`${evt} is not an ordered event stream for interval selections.`),on),[])}function wrapCondition(model,channelDef,vgChannel,
refFn){var condition=isConditionalDef(channelDef)&&channelDef.condition;channelDef=refFn(channelDef);return condition?(condition=vega.array(condition).map(c=>{const conditionValueRef=refFn(c);if(c.param){const {param,empty}=c;return{test:parseSelectionPredicate(model,{param,empty}),...conditionValueRef}}return{test:expression$jscomp$0(model,c.test),...conditionValueRef}}),{[vgChannel]:[...condition,...(void 0!==channelDef?[channelDef]:[])]}):void 0!==channelDef?{[vgChannel]:channelDef}:{}}function text$1(model){let channel=
1<arguments.length&&void 0!==arguments[1]?arguments[1]:"text";return wrapCondition(model,model.encoding[channel],channel,cDef=>textRef(cDef,model.config))}function textRef(channelDef,config){let expr=2<arguments.length&&void 0!==arguments[2]?arguments[2]:"datum";if(channelDef){if(isValueDef(channelDef))return signalOrValueRef(channelDef.value);if(isFieldOrDatumDef(channelDef)){const {format,formatType}=getFormatMixins(channelDef);return formatSignalRef({fieldOrDatumDef:channelDef,format,formatType,
expr,config})}}}function tooltip$jscomp$1(model){let opt=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{};const {encoding,markDef,config,stack}=model,channelDef=encoding.tooltip;if(vega.isArray(channelDef))return{tooltip:tooltipRefForEncoding({tooltip:channelDef},stack,config,opt)};const datum=opt.reactiveGeom?"datum.datum":"datum";return wrapCondition(model,channelDef,"tooltip",cDef=>{const tooltipRefFromChannelDef=textRef(cDef,config,datum);if(tooltipRefFromChannelDef)return tooltipRefFromChannelDef;
if(null!==cDef){cDef=getMarkPropOrConfig("tooltip",markDef,config);!0===cDef&&(cDef={content:"encoding"});if(vega.isString(cDef))return{value:cDef};if(vega.isObject(cDef))return isSignalRef(cDef)?cDef:"encoding"===cDef.content?tooltipRefForEncoding(encoding,stack,config,opt):{signal:datum}}})}function tooltipData(encoding,stack,config){function add(fDef,channel){var mainChannel=getMainRangeChannel(channel);fDef=isTypedFieldDef(fDef)?fDef:{...fDef,type:encoding[mainChannel].type};mainChannel=fDef.title||
titleFormatter(fDef,config);mainChannel=vega.array(mainChannel).join(", ");if(isXorY(channel)){const channel2="x"===channel?"x2":"y2";var fieldDef2=getFieldDef(encoding[channel2]);if(isBinned(fDef.bin)&&fieldDef2){var value=vgField(fDef,{expr});fieldDef2=vgField(fieldDef2,{expr});const {format,formatType}=getFormatMixins(fDef);value=binFormatExpression(value,fieldDef2,format,formatType,config);toSkip[channel2]=!0}}if((isXorY(channel)||"theta"===channel||"radius"===channel)&&stack&&stack.fieldChannel===
channel&&"normalize"===stack.offset){const {format,formatType}=getFormatMixins(fDef);value=formatSignalRef({fieldOrDatumDef:fDef,format,formatType,expr,config,normalizeStack:!0}).signal}value??(value=textRef(fDef,config,expr).signal);tuples.push({channel,key:mainChannel,value})}var {reactiveGeom}=3<arguments.length&&void 0!==arguments[3]?arguments[3]:{};const toSkip={},expr=reactiveGeom?"datum.datum":"datum",tuples=[];forEach(encoding,(channelDef,channel)=>{isFieldDef(channelDef)?add(channelDef,channel):
hasConditionalFieldDef(channelDef)&&add(channelDef.condition,channel)});reactiveGeom={};for(const {channel,key,value}of tuples)toSkip[channel]||reactiveGeom[key]||(reactiveGeom[key]=value);return reactiveGeom}function tooltipRefForEncoding(encoding,stack,config){var {reactiveGeom}=3<arguments.length&&void 0!==arguments[3]?arguments[3]:{};reactiveGeom=tooltipData(encoding,stack,config,{reactiveGeom});reactiveGeom=entries$1(reactiveGeom).map(_ref=>{let [key,value]=_ref;return`"${key}": ${value}`});
return 0<reactiveGeom.length?{signal:`{${reactiveGeom.join(", ")}}`}:void 0}function description(model){const {encoding,markDef,config,stack}=model;var channelDef=encoding.description;if(channelDef)return wrapCondition(model,channelDef,"description",cDef=>textRef(cDef,model.config));channelDef=getMarkPropOrConfig("description",markDef,config);if(null!=channelDef)return{description:signalOrValueRef(channelDef)};if(!1===config.aria)return{};channelDef=tooltipData(encoding,stack,config);if(!isEmpty(channelDef))return{description:{signal:entries$1(channelDef).map((_ref,
index)=>{let [key,value]=_ref;return`"${0<index?"; ":""}${key}: " + (${value})`}).join(" + ")}}}function nonPosition(channel,model){let opt=2<arguments.length&&void 0!==arguments[2]?arguments[2]:{};const {markDef,encoding,config}=model,{vgChannel}=opt;let {defaultRef,defaultValue}=opt;void 0===defaultRef&&(defaultValue??(defaultValue=getMarkPropOrConfig(channel,markDef,config,{vgChannel,ignoreVgConfig:!0})),void 0!==defaultValue&&(defaultRef=signalOrValueRef(defaultValue)));return wrapCondition(model,
encoding[channel],vgChannel??channel,cDef=>midPoint({channel,channelDef:cDef,markDef,config,scaleName:model.scaleName(channel),scale:model.getScaleComponent(channel),stack:null,defaultRef}))}function color$jscomp$0(model){var opt=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{filled:void 0};const {markDef,encoding,config}=model;var {type:markType}=markDef;opt=opt.filled??getMarkPropOrConfig("filled",markDef,config);markType=contains(["bar","point","circle","square","geoshape"],markType)?
"transparent":void 0;markType=getMarkPropOrConfig(!0===opt?"color":void 0,markDef,config,{vgChannel:"fill"})??config.mark[!0===opt&&"color"]??markType;const defaultStroke=getMarkPropOrConfig(!1===opt?"color":void 0,markDef,config,{vgChannel:"stroke"})??config.mark[!1===opt&&"color"],colorVgChannel=opt?"fill":"stroke",fillStrokeMarkDefAndConfig={...(markType?{fill:signalOrValueRef(markType)}:{}),...(defaultStroke?{stroke:signalOrValueRef(defaultStroke)}:{})};markDef.color&&(opt?markDef.fill:markDef.stroke)&&
warn(droppingColor("property",{fill:"fill"in markDef,stroke:"stroke"in markDef}));return{...fillStrokeMarkDefAndConfig,...nonPosition("color",model,{vgChannel:colorVgChannel,defaultValue:opt?markType:defaultStroke}),...nonPosition("fill",model,{defaultValue:encoding.fill?markType:void 0}),...nonPosition("stroke",model,{defaultValue:encoding.stroke?defaultStroke:void 0})}}function zindex(model){const {encoding,mark}=model,order=encoding.order;return!isPathMark(mark)&&isValueDef(order)?wrapCondition(model,
order,"zindex",cd=>signalOrValueRef(cd.value)):{}}function positionOffset(_ref){let {channel:baseChannel,markDef,encoding={},model,bandPosition}=_ref;_ref=`${baseChannel}Offset`;const defaultValue=markDef[_ref],channelDef=encoding[_ref];return"xOffset"!==_ref&&"yOffset"!==_ref||!channelDef?(_ref=markDef[_ref])?{offsetType:"visual",offset:_ref}:{}:{offsetType:"encoding",offset:midPoint({channel:_ref,channelDef,markDef,config:model?.config,scaleName:model.scaleName(_ref),scale:model.getScaleComponent(_ref),
stack:null,defaultRef:signalOrValueRef(defaultValue),bandPosition})}}function pointPosition(channel$jscomp$0,model,_ref){let {defaultPos,vgChannel}=_ref;const {encoding,markDef:markDef$jscomp$0,config,stack:stack$jscomp$0}=model;_ref=encoding[channel$jscomp$0];const channel2Def=encoding[getSecondaryRangeChannel(channel$jscomp$0)],scaleName$jscomp$0=model.scaleName(channel$jscomp$0),scale=model.getScaleComponent(channel$jscomp$0),{offset:offset$jscomp$0,offsetType}=positionOffset({channel:channel$jscomp$0,
markDef:markDef$jscomp$0,encoding,model,bandPosition:.5}),defaultRef=pointPositionDefaultRef({model,defaultPos,channel:channel$jscomp$0,scaleName:scaleName$jscomp$0,scale});if(!_ref&&isXorY(channel$jscomp$0)&&(encoding.latitude||encoding.longitude))model={field:model.getName(channel$jscomp$0)};else a:{model={channel:channel$jscomp$0,channelDef:_ref,channel2Def,markDef:markDef$jscomp$0,config,scaleName:scaleName$jscomp$0,scale,stack:stack$jscomp$0,offset:offset$jscomp$0,defaultRef,bandPosition:"encoding"===
offsetType?0:void 0};const {channel,channelDef,scaleName,stack,offset,markDef}=model;if(isFieldOrDatumDef(channelDef)&&stack&&channel===stack.fieldChannel){if(isFieldDef(channelDef)&&(model=channelDef.bandPosition,void 0!==model||"text"!==markDef.type||"radius"!==channel&&"theta"!==channel||(model=.5),void 0!==model)){model=interpolatedSignalRef({scaleName,fieldOrDatumDef:channelDef,startSuffix:"start",bandPosition:model,offset});break a}model=valueRefForFieldOrDatumDef(channelDef,scaleName,{suffix:"end"},
{offset})}else model=midPointRefWithPositionInvalidTest(model)}return model?{[vgChannel||channel$jscomp$0]:model}:void 0}function pointPositionDefaultRef(_ref2){let {model,defaultPos,channel,scaleName,scale}=_ref2;const {markDef,config}=model;return()=>{const mainChannel=getMainRangeChannel(channel);var vgChannel=getVgPositionChannel(channel);vgChannel=getMarkPropOrConfig(channel,markDef,config,{vgChannel});if(void 0!==vgChannel)return widthHeightValueOrSignalRef(channel,vgChannel);switch(defaultPos){case "zeroOrMin":case "zeroOrMax":if(scaleName&&
(vgChannel=scale.get("type"),!contains([ScaleType.LOG,ScaleType.TIME,ScaleType.UTC],vgChannel)&&scale.domainDefinitelyIncludesZero()))return{scale:scaleName,value:0};if("zeroOrMin"===defaultPos)return"y"===mainChannel?{field:{group:"height"}}:{value:0};switch(mainChannel){case "radius":return{signal:`min(${model.width.signal},${model.height.signal})/2`};case "theta":return{signal:"2*PI"};case "x":return{field:{group:"width"}};case "y":return{value:0}}break;case "mid":return{...model[getSizeChannel(channel)],
mult:.5}}}}function vgAlignedPositionChannel(channel,markDef,config){let defaultAlign=3<arguments.length&&void 0!==arguments[3]?arguments[3]:"middle";if("radius"===channel||"theta"===channel)return getVgPositionChannel(channel);var alignChannel="x"===channel?"align":"baseline";const align=getMarkPropOrConfig(alignChannel,markDef,config);isSignalRef(align)?(warn(`The ${alignChannel} for range marks cannot be an expression`),alignChannel=void 0):alignChannel=align;return"x"===channel?ALIGNED_X_CHANNEL[alignChannel||
("top"===defaultAlign?"left":"center")]:BASELINED_Y_CHANNEL[alignChannel||defaultAlign]}function pointOrRangePosition(channel,model,_ref){let {defaultPos,defaultPos2,range}=_ref;return range?rangePosition(channel,model,{defaultPos,defaultPos2}):pointPosition(channel,model,{defaultPos})}function rangePosition(channel$jscomp$0,model,_ref2){let {defaultPos,defaultPos2}=_ref2;const {markDef:markDef$jscomp$1,config:config$jscomp$1}=model;var channel2=getSecondaryRangeChannel(channel$jscomp$0);_ref2=getSizeChannel(channel$jscomp$0);
{const {encoding,mark,markDef:markDef$jscomp$0,stack:stack$jscomp$0,config:config$jscomp$0}=model;var baseChannel=getMainRangeChannel(channel2),sizeChannel=getSizeChannel(channel2);const vgChannel=getVgPositionChannel(channel2);var channelDef$jscomp$0=encoding[baseChannel],scaleName$jscomp$0=model.scaleName(baseChannel);const scale$jscomp$0=model.getScaleComponent(baseChannel);({offset:baseChannel}=channel2 in encoding||channel2 in markDef$jscomp$0?positionOffset({channel:channel2,markDef:markDef$jscomp$0,
encoding,model}):positionOffset({channel:baseChannel,markDef:markDef$jscomp$0,encoding,model}));if(channelDef$jscomp$0||"x2"!==channel2&&"y2"!==channel2||!encoding.latitude&&!encoding.longitude){let {channel,channelDef,channel2Def,markDef,config,scaleName,scale,stack,offset,defaultRef}={channel:channel2,channelDef:channelDef$jscomp$0,channel2Def:encoding[channel2],markDef:markDef$jscomp$0,config:config$jscomp$0,scaleName:scaleName$jscomp$0,scale:scale$jscomp$0,stack:stack$jscomp$0,offset:baseChannel,
defaultRef:void 0};channelDef$jscomp$0=isFieldOrDatumDef(channelDef)&&stack&&channel.charAt(0)===stack.fieldChannel.charAt(0)?valueRefForFieldOrDatumDef(channelDef,scaleName,{suffix:"start"},{offset}):midPointRefWithPositionInvalidTest({channel,channelDef:channel2Def,scaleName,scale,stack,markDef,config,offset,defaultRef});channel2=void 0!==channelDef$jscomp$0?{[vgChannel]:channelDef$jscomp$0}:position2orSize(channel2,markDef$jscomp$0)||position2orSize(channel2,{[channel2]:getMarkStyleConfig(channel2,
markDef$jscomp$0,config$jscomp$0.style),[sizeChannel]:getMarkStyleConfig(sizeChannel,markDef$jscomp$0,config$jscomp$0.style)})||position2orSize(channel2,config$jscomp$0[mark])||position2orSize(channel2,config$jscomp$0.mark)||{[vgChannel]:pointPositionDefaultRef({model,defaultPos:defaultPos2,channel:channel2,scaleName:scaleName$jscomp$0,scale:scale$jscomp$0})()}}else sizeChannel=getSizeChannel(channel2),scaleName$jscomp$0=model.markDef[sizeChannel],channel2=null!=scaleName$jscomp$0?{[sizeChannel]:{value:scaleName$jscomp$0}}:
{[vgChannel]:{field:model.getName(channel2)}}}_ref2=channel2[_ref2]?vgAlignedPositionChannel(channel$jscomp$0,markDef$jscomp$1,config$jscomp$1):getVgPositionChannel(channel$jscomp$0);return{...pointPosition(channel$jscomp$0,model,{defaultPos,vgChannel:_ref2}),...channel2}}function position2orSize(channel,markDef){const sizeChannel=getSizeChannel(channel),vgChannel=getVgPositionChannel(channel);if(void 0!==markDef[vgChannel])return{[vgChannel]:widthHeightValueOrSignalRef(channel,markDef[vgChannel])};
if(void 0!==markDef[channel])return{[vgChannel]:widthHeightValueOrSignalRef(channel,markDef[channel])};if(markDef[sizeChannel])if(markDef=markDef[sizeChannel],isRelativeBandSize(markDef))warn(`Position range does not support relative band size for ${sizeChannel}.`);else return{[sizeChannel]:widthHeightValueOrSignalRef(channel,markDef)}}function rectPosition(model$jscomp$0,channel$jscomp$0){const {config:config$jscomp$0,encoding:encoding$jscomp$0,markDef:markDef$jscomp$0}=model$jscomp$0;var mark=markDef$jscomp$0.type,
channel2=getSecondaryRangeChannel(channel$jscomp$0),sizeChannel=getSizeChannel(channel$jscomp$0),channelDef=encoding$jscomp$0[channel$jscomp$0];channel2=encoding$jscomp$0[channel2];var scale=model$jscomp$0.getScaleComponent(channel$jscomp$0);scale=scale?scale.get("type"):void 0;var orient=markDef$jscomp$0.orient;sizeChannel=encoding$jscomp$0[sizeChannel]??encoding$jscomp$0.size??getMarkPropOrConfig("size",markDef$jscomp$0,config$jscomp$0,{vgChannel:sizeChannel});mark="bar"===mark&&("x"===channel$jscomp$0?
"vertical"===orient:"horizontal"===orient);if(!isFieldDef(channelDef)||!(isBinning(channelDef.bin)||isBinned(channelDef.bin)||channelDef.timeUnit&&!channel2)||sizeChannel&&!isRelativeBandSize(sizeChannel)||hasDiscreteDomain(scale)){if((isFieldOrDatumDef(channelDef)&&hasDiscreteDomain(scale)||mark)&&!channel2){var JSCompiler_inline_result;{const {markDef,encoding,config,stack}=model$jscomp$0;var orient$jscomp$0=markDef.orient;sizeChannel=model$jscomp$0.scaleName(channel$jscomp$0);scale=model$jscomp$0.getScaleComponent(channel$jscomp$0);
mark=getSizeChannel(channel$jscomp$0);channel2=getSecondaryRangeChannel(channel$jscomp$0);orient=getOffsetChannel(channel$jscomp$0);orient=model$jscomp$0.scaleName(orient);orient$jscomp$0="horizontal"===orient$jscomp$0&&"y"===channel$jscomp$0||"vertical"===orient$jscomp$0&&"x"===channel$jscomp$0;if(encoding.size||markDef.size)orient$jscomp$0?JSCompiler_inline_result=nonPosition("size",model$jscomp$0,{vgChannel:mark,defaultRef:signalOrValueRef(markDef.size)}):warn(`Cannot apply size to non-oriented mark "${markDef.type}".`);
var hasSizeFromMarkOrEncoding=!!JSCompiler_inline_result;orient$jscomp$0=getBandSize({channel:channel$jscomp$0,fieldDef:channelDef,markDef,config,scaleType:scale?.get("type"),useVlSizeChannel:orient$jscomp$0});JSCompiler_inline_result=JSCompiler_inline_result||{[mark]:defaultSizeRef(mark,orient||sizeChannel,scale,config,orient$jscomp$0)};orient="band"===scale?.get("type")&&isRelativeBandSize(orient$jscomp$0)&&!hasSizeFromMarkOrEncoding?"top":"middle";orient=vgAlignedPositionChannel(channel$jscomp$0,
markDef,config,orient);hasSizeFromMarkOrEncoding="xc"===orient||"yc"===orient;const {offset,offsetType}=positionOffset({channel:channel$jscomp$0,markDef,encoding,model:model$jscomp$0,bandPosition:hasSizeFromMarkOrEncoding?.5:0});model$jscomp$0=midPointRefWithPositionInvalidTest({channel:channel$jscomp$0,channelDef,markDef,config,scaleName:sizeChannel,scale,stack,offset,defaultRef:pointPositionDefaultRef({model:model$jscomp$0,defaultPos:"mid",channel:channel$jscomp$0,scaleName:sizeChannel,scale}),
bandPosition:hasSizeFromMarkOrEncoding?"encoding"===offsetType?0:.5:isSignalRef(orient$jscomp$0)?{signal:`(1-${orient$jscomp$0})/2`}:isRelativeBandSize(orient$jscomp$0)?(1-orient$jscomp$0.band)/2:0});mark?JSCompiler_inline_result={[orient]:model$jscomp$0,...JSCompiler_inline_result}:(channel$jscomp$0=getVgPositionChannel(channel2),JSCompiler_inline_result=JSCompiler_inline_result[mark],JSCompiler_inline_result=offset?{...JSCompiler_inline_result,offset}:JSCompiler_inline_result,JSCompiler_inline_result=
{[orient]:model$jscomp$0,[channel$jscomp$0]:vega.isArray(model$jscomp$0)?[model$jscomp$0[0],{...model$jscomp$0[1],offset:JSCompiler_inline_result}]:{...model$jscomp$0,offset:JSCompiler_inline_result}})}return JSCompiler_inline_result}return rangePosition(channel$jscomp$0,model$jscomp$0,{defaultPos:"zeroOrMax",defaultPos2:"zeroOrMin"})}a:{let {fieldDef,fieldDef2,channel,model}={fieldDef:channelDef,fieldDef2:channel2,channel:channel$jscomp$0,model:model$jscomp$0};const {config,markDef,encoding}=model;
model$jscomp$0=model.getScaleComponent(channel);JSCompiler_inline_result=model.scaleName(channel);channel$jscomp$0=model$jscomp$0?model$jscomp$0.get("type"):void 0;model$jscomp$0=model$jscomp$0.get("reverse");orient=getBandSize({channel,fieldDef,markDef,config,scaleType:channel$jscomp$0});channel$jscomp$0=model.component.axes[channel]?.[0]?.get("translate")??.5;channelDef=isXorY(channel)?getMarkPropOrConfig("binSpacing",markDef,config)??0:0;mark=getSecondaryRangeChannel(channel);channel2=getVgPositionChannel(channel);
sizeChannel=getVgPositionChannel(mark);({offset:scale}=positionOffset({channel,markDef,encoding,model,bandPosition:0}));orient=isSignalRef(orient)?{signal:`(1-${orient.signal})/2`}:isRelativeBandSize(orient)?(1-orient.band)/2:.5;if(isBinning(fieldDef.bin)||fieldDef.timeUnit)JSCompiler_inline_result={[sizeChannel]:rectBinRef({fieldDef,scaleName:JSCompiler_inline_result,bandPosition:orient,offset:getBinSpacing(mark,channelDef,model$jscomp$0,channel$jscomp$0,scale)}),[channel2]:rectBinRef({fieldDef,
scaleName:JSCompiler_inline_result,bandPosition:isSignalRef(orient)?{signal:`1-${orient.signal}`}:1-orient,offset:getBinSpacing(channel,channelDef,model$jscomp$0,channel$jscomp$0,scale)})};else{if(isBinned(fieldDef.bin)){orient=valueRefForFieldOrDatumDef(fieldDef,JSCompiler_inline_result,{},{offset:getBinSpacing(mark,channelDef,model$jscomp$0,channel$jscomp$0,scale)});if(isFieldDef(fieldDef2)){JSCompiler_inline_result={[sizeChannel]:orient,[channel2]:valueRefForFieldOrDatumDef(fieldDef2,JSCompiler_inline_result,
{},{offset:getBinSpacing(channel,channelDef,model$jscomp$0,channel$jscomp$0,scale)})};break a}if(vega.isObject(fieldDef.bin)&&fieldDef.bin.step){JSCompiler_inline_result={[sizeChannel]:orient,[channel2]:{signal:`scale("${JSCompiler_inline_result}", ${vgField(fieldDef,{expr:"datum"})} + ${fieldDef.bin.step})`,offset:getBinSpacing(channel,channelDef,model$jscomp$0,channel$jscomp$0,scale)}};break a}}warn(channelRequiredForBinned(mark));JSCompiler_inline_result=void 0}}return JSCompiler_inline_result}
function defaultSizeRef(sizeChannel,scaleName,scale,config,bandSize){if(isRelativeBandSize(bandSize))if(scale){const scaleType=scale.get("type");if("band"===scaleType)return sizeChannel=`bandwidth('${scaleName}')`,1!==bandSize.band&&(sizeChannel=`${bandSize.band} * ${sizeChannel}`),{signal:`max(0.25, ${sizeChannel})`};1!==bandSize.band&&warn(`Cannot use the relative band size with ${scaleType} scale.`)}else return{mult:bandSize.band,field:{group:sizeChannel}};else{if(isSignalRef(bandSize))return bandSize;
if(bandSize)return{value:bandSize}}return scale&&(bandSize=scale.get("range"),isVgRangeStep(bandSize)&&vega.isNumber(bandSize.step))?{value:bandSize.step-2}:{value:getViewConfigDiscreteStep(config.view,sizeChannel)-2}}function getBinSpacing(channel,spacing,reverse,translate,offset){if(channel in POLAR_POSITION_CHANNEL_INDEX)return 0;channel="x"===channel||"y2"===channel?-spacing/2:spacing/2;if(isSignalRef(reverse)||isSignalRef(offset)||isSignalRef(translate))return reverse=signalOrStringValue(reverse),
offset=signalOrStringValue(offset),translate=signalOrStringValue(translate),{signal:(translate?`${translate} + `:"")+(reverse?`(${reverse} ? -1 : 1) * `:"")+(offset?`(${offset} + ${channel})`:channel)};offset=offset||0;return translate+(reverse?-offset-channel:+offset+channel)}function rectBinRef(_ref2){let {fieldDef,scaleName,bandPosition,offset}=_ref2;return interpolatedSignalRef({scaleName,fieldOrDatumDef:fieldDef,bandPosition,offset})}function baseEncodeEntry(model,ignore){const {fill,stroke}=
"include"===ignore.color?color$jscomp$0(model):{};ignore={...markDefProperties(model.markDef,ignore)};var JSCompiler_temp_const={...wrapAllFieldsInvalid(model,"fill",fill)},JSCompiler_temp_const$jscomp$0={...wrapAllFieldsInvalid(model,"stroke",stroke)},JSCompiler_temp_const$jscomp$1={...nonPosition("opacity",model)},JSCompiler_temp_const$jscomp$2={...nonPosition("fillOpacity",model)},JSCompiler_temp_const$jscomp$3={...nonPosition("strokeOpacity",model)},JSCompiler_temp_const$jscomp$4={...nonPosition("strokeWidth",
model)},JSCompiler_temp_const$jscomp$5={...nonPosition("strokeDash",model)},JSCompiler_temp_const$jscomp$6={...zindex(model)},JSCompiler_temp_const$jscomp$7={...tooltip$jscomp$1(model)},JSCompiler_temp_const$jscomp$8={...text$1(model,"href")};{const {markDef:markDef$jscomp$0,config:config$jscomp$0}=model,enableAria=getMarkPropOrConfig("aria",markDef$jscomp$0,config$jscomp$0);if(!1===enableAria)model={};else{{const {mark,markDef,config}=model;if(!1===config.aria)var JSCompiler_inline_result={};else JSCompiler_inline_result=
getMarkPropOrConfig("ariaRoleDescription",markDef,config),JSCompiler_inline_result=null!=JSCompiler_inline_result?{ariaRoleDescription:{value:JSCompiler_inline_result}}:mark in VG_MARK_INDEX?{}:{ariaRoleDescription:{value:mark}}}model={...(enableAria?{aria:enableAria}:{}),...JSCompiler_inline_result,...description(model)}}}return{...ignore,...JSCompiler_temp_const,...JSCompiler_temp_const$jscomp$0,...JSCompiler_temp_const$jscomp$1,...JSCompiler_temp_const$jscomp$2,...JSCompiler_temp_const$jscomp$3,
...JSCompiler_temp_const$jscomp$4,...JSCompiler_temp_const$jscomp$5,...JSCompiler_temp_const$jscomp$6,...JSCompiler_temp_const$jscomp$7,...JSCompiler_temp_const$jscomp$8,...model}}function wrapAllFieldsInvalid(model,channel,valueRef){const {config,mark,markDef}=model;return"hide"===getMarkPropOrConfig("invalid",markDef,config)&&valueRef&&!isPathMark(mark)&&(model=allFieldsInvalidPredicate$1(model,{invalid:!0,channels:SCALE_CHANNELS}))?{[channel]:[{test:model,value:null},...vega.array(valueRef)]}:
valueRef?{[channel]:valueRef}:{}}function markDefProperties(mark,ignore){return VG_MARK_CONFIGS.reduce((m,prop)=>{ALWAYS_IGNORE.has(prop)||void 0===mark[prop]||"ignore"===ignore[prop]||(m[prop]=signalOrValueRef(mark[prop]));return m},{})}function allFieldsInvalidPredicate$1(model,_ref){let {invalid=!1,channels}=_ref;_ref=channels.reduce((aggregator,channel)=>{var scaleComponent=model.getScaleComponent(channel);scaleComponent&&(scaleComponent=scaleComponent.get("type"),(channel=model.vgField(channel,
{expr:"datum"}))&&hasContinuousDomain(scaleComponent)&&(aggregator[channel]=!0));return aggregator},{});_ref=keys$jscomp$0(_ref);if(0<_ref.length){const op=invalid?"||":"\x26\x26";return _ref.map(field=>fieldInvalidPredicate(field,invalid)).join(` ${op} `)}}function defined(model){const {config,markDef}=model;return getMarkPropOrConfig("invalid",markDef,config)&&(model=allFieldsInvalidPredicate(model,{channels:POSITION_SCALE_CHANNELS}))?{defined:{signal:model}}:{}}function allFieldsInvalidPredicate(model,
_ref){let {invalid=!1,channels}=_ref;_ref=channels.reduce((aggregator,channel)=>{var scaleComponent=model.getScaleComponent(channel);scaleComponent&&(scaleComponent=scaleComponent.get("type"),(channel=model.vgField(channel,{expr:"datum",binSuffix:model.stack?.impute?"mid":void 0}))&&hasContinuousDomain(scaleComponent)&&(aggregator[channel]=!0));return aggregator},{});_ref=keys$jscomp$0(_ref);if(0<_ref.length){const op=invalid?"||":"\x26\x26";return _ref.map(field=>fieldInvalidPredicate(field,invalid)).join(` ${op} `)}}
function valueIfDefined(prop,value){if(void 0!==value)return{[prop]:signalOrValueRef(value)}}function onDelta$1(model,selCmpt,proj,size,signals){var name=selCmpt.name,anchor=name+"_translate_anchor";name+="_translate_delta";var channel=proj.channel;const hasScales=scaleBindings.defined(selCmpt);selCmpt=signals.filter(s=>s.name===proj.signals[hasScales?"data":"visual"])[0];size=model.getSizeSignalRef(size).signal;model=model.getScaleComponent(channel);signals=model.get("type");var reversed=model.get("reverse");
anchor=`${anchor}.extent_${channel}`;channel=`${hasScales?"x"===channel?reversed?"":"-":reversed?"-":"":""}${name}.${channel} / ${hasScales?`${size}`:`span(${anchor})`}`;reversed=hasScales?"log"===signals?"panLog":"symlog"===signals?"panSymlog":"pow"===signals?"panPow":"panLinear":"panLinear";model=hasScales?"pow"===signals?`, ${model.get("exponent")??1}`:"symlog"===signals?`, ${model.get("constant")??1}`:"":"";anchor=`${reversed}(${anchor}, ${channel}${model})`;selCmpt.on.push({events:{signal:name},
update:hasScales?anchor:`clampRange(${anchor}, 0, ${size})`})}function onDelta(model,selCmpt,proj,size,signals){var name=selCmpt.name,channel=proj.channel;const hasScales=scaleBindings.defined(selCmpt);selCmpt=signals.filter(s=>s.name===proj.signals[hasScales?"data":"visual"])[0];size=model.getSizeSignalRef(size).signal;signals=model.getScaleComponent(channel);const scaleType=signals.get("type"),base=hasScales?domain$jscomp$0(model,channel):selCmpt.name;model=name+"_zoom_delta";name=`${name}${"_zoom_anchor"}.${channel}`;
channel=hasScales?"log"===scaleType?"zoomLog":"symlog"===scaleType?"zoomSymlog":"pow"===scaleType?"zoomPow":"zoomLinear":"zoomLinear";signals=hasScales?"pow"===scaleType?`, ${signals.get("exponent")??1}`:"symlog"===scaleType?`, ${signals.get("constant")??1}`:"":"";name=`${channel}(${base}, ${name}, ${model}${signals})`;selCmpt.on.push({events:{signal:model},update:hasScales?name:`clampRange(${name}, 0, ${size})`})}function unitName(model){var {escape}=1<arguments.length&&void 0!==arguments[1]?arguments[1]:
{escape:!0};escape=escape?vega.stringValue(model.name):model.name;var JSCompiler_inline_result;for(JSCompiler_inline_result=model.parent;JSCompiler_inline_result&&!isFacetModel(JSCompiler_inline_result);)JSCompiler_inline_result=JSCompiler_inline_result.parent;if(JSCompiler_inline_result){const {facet}=JSCompiler_inline_result;for(const channel of FACET_CHANNELS)facet[channel]&&(escape+=` + '__facet_${channel}_' + (facet[${vega.stringValue(JSCompiler_inline_result.vgField(channel))}])`)}return escape}
function requiresSelectionId(model){return vals$jscomp$0(model.component.selection??{}).reduce((identifier,selCmpt)=>identifier||selCmpt.project.hasSelectionId,!1)}function disableDirectManipulation(selCmpt,selDef){!vega.isString(selDef.select)&&selDef.select.on||delete selCmpt.events;!vega.isString(selDef.select)&&selDef.select.clear||delete selCmpt.clear;!vega.isString(selDef.select)&&selDef.select.toggle||delete selCmpt.toggle}function getName(node){const name=[];if("Identifier"===node.type)return[node.name];
if("Literal"===node.type)return[node.value];"MemberExpression"===node.type&&(name.push(...getName(node.object)),name.push(...getName(node.property)));return name}function startsWithDatum(node){return"MemberExpression"===node.object.type?startsWithDatum(node.object):"datum"===node.object.name}function getDependentFields(expression){expression=vega.parseExpression(expression);const dependents=new Set;expression.visit(node=>{"MemberExpression"===node.type&&startsWithDatum(node)&&dependents.add(getName(node).slice(1).join("."))});
return dependents}function parseSelectionPredicate(model,pred,dfnode){var datum=3<arguments.length&&void 0!==arguments[3]?arguments[3]:"datum",name=vega.isString(pred)?pred:pred.param,vname=varName(name),store=vega.stringValue(vname+"_store");try{var selCmpt=model.getSelectionComponent(vname,name)}catch(e){return`!!${vname}`}selCmpt.project.timeUnit&&(name=dfnode??model.component.data.raw,vname=selCmpt.project.timeUnit.clone(),name.parent?vname.insertAsParentOf(name):name.parent=vname);name=selCmpt.project.hasSelectionId?
"vlSelectionIdTest(":"vlSelectionTest(";selCmpt="global"===selCmpt.resolve?")":`, ${vega.stringValue(selCmpt.resolve)})`;datum=`${name}${store}, ${datum}${selCmpt}`;store=`length(data(${store}))`;return!1===pred.empty?`${store} && ${datum}`:`!${store} || ${datum}`}function parseSelectionExtent(model,name,extent){const vname=varName(name),encoding=extent.encoding;let field=extent.field,selCmpt;try{selCmpt=model.getSelectionComponent(vname,name)}catch(e){return vname}encoding||field?encoding&&!field&&
(model=selCmpt.project.items.filter(p=>p.channel===encoding),!model.length||1<model.length?(field=selCmpt.project.items[0].field,warn((model.length?"Multiple ":"No ")+`matching ${vega.stringValue(encoding)} encoding found for selection ${vega.stringValue(extent.param)}. `+`Using "field": ${vega.stringValue(field)}.`)):field=model[0].field):(field=selCmpt.project.items[0].field,1<selCmpt.project.items.length&&warn('A "field" or "encoding" must be specified when using a selection as a scale domain. '+
`Using "field": ${vega.stringValue(field)}.`));return`${selCmpt.name}[${vega.stringValue(replacePathInField(field))}]`}function expression$jscomp$0(model,filterOp,node){return logicalExpr(filterOp,predicate=>vega.isString(predicate)?predicate:predicate?.param?parseSelectionPredicate(model,predicate,node):fieldFilterExpression(predicate))}function assembleTitle(title,config){if(title)return vega.isArray(title)&&!isText(title)?title.map(fieldDef=>titleFormatter(fieldDef,config)).join(", "):title}function setAxisEncode(axis,
part,vgProp,vgRef){axis.encode??(axis.encode={});let $jscomp$logical$assign$tmp730812712$7;($jscomp$logical$assign$tmp730812712$7=axis.encode)[part]??($jscomp$logical$assign$tmp730812712$7[part]={});let $jscomp$logical$assign$tmp730812712$8;($jscomp$logical$assign$tmp730812712$8=axis.encode[part]).update??($jscomp$logical$assign$tmp730812712$8.update={});axis.encode[part].update[vgProp]=vgRef}function assembleAxis(axisCmpt,kind,config){var opt=3<arguments.length&&void 0!==arguments[3]?arguments[3]:
{header:!1};const {disable,orient,scale,labelExpr,title,zindex,...axis}=axisCmpt.combine();if(!disable){for(const prop in axis){var propType=AXIS_PROPERTY_TYPE[prop],propValue=axis[prop];if(propType&&propType!==kind&&"both"!==propType)delete axis[prop];else if(propValue?.condition){const {condition,...valueOrSignalRef}=propValue;propValue=vega.array(condition);if(propType=CONDITIONAL_AXIS_PROP_INDEX[prop]){const {vgProp,part}=propType;propValue=[...propValue.map(c=>{const {test,...valueOrSignalCRef}=
c;return{test:expression$jscomp$0(null,test),...valueOrSignalCRef}}),valueOrSignalRef];setAxisEncode(axis,part,vgProp,propValue);delete axis[prop]}else null===propType&&(propValue={signal:propValue.map(c=>{const {test,...valueOrSignalCRef}=c;return`${expression$jscomp$0(null,test)} ? ${exprFromValueRefOrSignalRef(valueOrSignalCRef)} : `}).join("")+exprFromValueRefOrSignalRef(valueOrSignalRef)},axis[prop]=propValue)}else if(isSignalRef(propValue)&&(propType=CONDITIONAL_AXIS_PROP_INDEX[prop])){const {vgProp,
part}=propType;setAxisEncode(axis,part,vgProp,propValue);delete axis[prop]}contains(["labelAlign","labelBaseline"],prop)&&null===axis[prop]&&delete axis[prop]}if("grid"===kind){if(axis.grid){if(axis.encode){var {grid}=axis.encode;axis.encode={...(grid?{grid}:{})};isEmpty(axis.encode)&&delete axis.encode}return{scale,orient,...axis,domain:!1,labels:!1,aria:!1,maxExtent:0,minExtent:0,ticks:!1,zindex:getFirstDefined(zindex,0)}}}else if(opt.header||!axisCmpt.mainExtracted){void 0!==labelExpr&&(opt=labelExpr,
axis.encode?.labels?.update&&isSignalRef(axis.encode.labels.update.text)&&(opt=replaceAll(labelExpr,"datum.label",axis.encode.labels.update.text.signal)),setAxisEncode(axis,"labels","text",{signal:opt}));null===axis.labelAlign&&delete axis.labelAlign;if(axis.encode){for(grid of AXIS_PARTS)axisCmpt.hasAxisPart(grid)||delete axis.encode[grid];isEmpty(axis.encode)&&delete axis.encode}grid=assembleTitle(title,config);return{scale,orient,grid:!1,...(grid?{title:grid}:{}),...axis,...(!1===config.aria?{aria:!1}:
{}),zindex:getFirstDefined(zindex,0)}}}}function assembleAxisSignals(model){const {axes}=model.component,signals=[];for(const channel of POSITION_SCALE_CHANNELS)if(axes[channel])for(const axis of axes[channel])if(!axis.get("disable")&&!axis.get("gridScale")){const sizeType="x"===channel?"height":"width",update=model.getSizeSignalRef(sizeType).signal;sizeType!==update&&signals.push({name:sizeType,update})}return signals}function assembleAxes(axisComponents,config){const {x=[],y=[]}=axisComponents;
return[...x.map(a=>assembleAxis(a,"grid",config)),...y.map(a=>assembleAxis(a,"grid",config)),...x.map(a=>assembleAxis(a,"main",config)),...y.map(a=>assembleAxis(a,"main",config))].filter(a=>a)}function getAxisConfigFromConfigTypes(configTypes,config,channel,orient){return Object.assign.apply(null,[{},...configTypes.map(configType=>{if("axisOrient"===configType){configType="x"===channel?"bottom":"left";const orientConfig1=config["x"===channel?"axisBottom":"axisLeft"]||{},orientConfig2=config["x"===
channel?"axisTop":"axisRight"]||{},props=new Set([...keys$jscomp$0(orientConfig1),...keys$jscomp$0(orientConfig2)]),conditionalOrientAxisConfig={};for(const prop of props.values())conditionalOrientAxisConfig[prop]={signal:`${orient.signal} === "${configType}" ? ${signalOrStringValue(orientConfig1[prop])} : ${signalOrStringValue(orientConfig2[prop])}`};return conditionalOrientAxisConfig}return config[configType]})])}function getAxisConfigs(channel,scaleType,orient,config){var typeBasedConfigTypes=
"band"===scaleType?["axisDiscrete","axisBand"]:"point"===scaleType?["axisDiscrete","axisPoint"]:QUANTITATIVE_SCALES.has(scaleType)?["axisQuantitative"]:"time"===scaleType||"utc"===scaleType?["axisTemporal"]:[];const axisChannel="x"===channel?"axisX":"axisY";scaleType=isSignalRef(orient)?"axisOrient":`axis${titleCase(orient)}`;typeBasedConfigTypes=[...typeBasedConfigTypes,...typeBasedConfigTypes.map(c=>axisChannel+c.substr(4))];scaleType=["axis",scaleType,axisChannel];return{vlOnlyAxisConfig:getAxisConfigFromConfigTypes(typeBasedConfigTypes,
config,channel,orient),vgAxisConfig:getAxisConfigFromConfigTypes(scaleType,config,channel,orient),axisConfigStyle:getAxisConfigStyle([...scaleType,...typeBasedConfigTypes],config)}}function getAxisConfigStyle(axisConfigTypes,config){const toMerge=[{}];for(const configType of axisConfigTypes)if(axisConfigTypes=config[configType]?.style){axisConfigTypes=vega.array(axisConfigTypes);for(const s of axisConfigTypes)toMerge.push(config.style[s])}return Object.assign.apply(null,toMerge)}function getAxisConfig(property,
styleConfigIndex,style){let axisConfigs=3<arguments.length&&void 0!==arguments[3]?arguments[3]:{};const styleConfig=getStyleConfig(property,style,styleConfigIndex);if(void 0!==styleConfig)return{configFrom:"style",configValue:styleConfig};for(const configFrom of["vlOnlyAxisConfig","vgAxisConfig","axisConfigStyle"])if(void 0!==axisConfigs[configFrom]?.[property])return{configFrom,configValue:axisConfigs[configFrom][property]};return{}}function getLabelAngle(fieldOrDatumDef,axis,channel,styleConfig,
axisConfigs){const labelAngle=axis?.labelAngle;if(void 0!==labelAngle)return isSignalRef(labelAngle)?labelAngle:normalizeAngle(labelAngle);({configValue:axis}=getAxisConfig("labelAngle",styleConfig,axis?.style,axisConfigs));if(void 0!==axis)return normalizeAngle(axis);if("x"===channel&&contains(["nominal","ordinal"],fieldOrDatumDef.type)&&(!isFieldDef(fieldOrDatumDef)||!fieldOrDatumDef.timeUnit))return 270}function normalizeAngleExpr(angle){return`(((${angle.signal} % 360) + 360) % 360)`}function defaultLabelBaseline(angle,
orient,channel,alwaysIncludeMiddle){if(void 0!==angle)return"x"===channel?isSignalRef(angle)?(alwaysIncludeMiddle=normalizeAngleExpr(angle),orient=isSignalRef(orient)?`(${orient.signal} === "top")`:"top"===orient,{signal:`(45 < ${alwaysIncludeMiddle} && ${alwaysIncludeMiddle} < 135) || (225 < ${alwaysIncludeMiddle} && ${alwaysIncludeMiddle} < 315) ? "middle" :`+`(${alwaysIncludeMiddle} <= 45 || 315 <= ${alwaysIncludeMiddle}) === ${orient} ? "bottom" : "top"`}):45<angle&&135>angle||225<angle&&315>
angle?"middle":isSignalRef(orient)?{signal:`${orient.signal} ${45>=angle||315<=angle?"\x3d\x3d\x3d":"!\x3d\x3d"} "top" ? "bottom" : "top"`}:(45>=angle||315<=angle)===("top"===orient)?"bottom":"top":isSignalRef(angle)?(angle=normalizeAngleExpr(angle),orient=isSignalRef(orient)?`(${orient.signal} === "left")`:"left"===orient,{signal:`${angle} <= 45 || 315 <= ${angle} || (135 <= ${angle} && ${angle} <= 225) ? ${alwaysIncludeMiddle?'"middle"':"null"} : (45 <= ${angle} && ${angle} <= 135) === ${orient} ? "top" : "bottom"`}):
45>=angle||315<=angle||135<=angle&&225>=angle?alwaysIncludeMiddle?"middle":null:isSignalRef(orient)?{signal:`${orient.signal} ${45<=angle&&135>=angle?"\x3d\x3d\x3d":"!\x3d\x3d"} "left" ? "top" : "bottom"`}:(45<=angle&&135>=angle)===("left"===orient)?"top":"bottom"}function defaultLabelAlign(angle,orient,channel){if(void 0!==angle){var startAngle=(channel="x"===channel)?0:90,mainOrient=channel?"bottom":"left";return isSignalRef(angle)?(angle=normalizeAngleExpr(angle),orient=isSignalRef(orient)?`(${orient.signal} === "${mainOrient}")`:
orient===mainOrient,{signal:`(${startAngle?`(${angle} + 90)`:angle} % 180 === 0) ? ${channel?null:'"center"'} :`+`(${startAngle} < ${angle} && ${angle} < ${180+startAngle}) === ${orient} ? "left" : "right"`}):0===(angle+startAngle)%180?channel?null:"center":isSignalRef(orient)?{signal:`${`${orient.signal} ${startAngle<angle&&angle<180+startAngle?"\x3d\x3d\x3d":"!\x3d\x3d"} "${mainOrient}"`} ? "left" : "right"`}:(startAngle<angle&&angle<180+startAngle)===(orient===mainOrient)?"left":"right"}}function getFieldDefTitle(model,
channel){var channel2="x"===channel?"x2":"y2";channel=model.fieldDef(channel);model=model.fieldDef(channel2);channel2=channel?channel.title:void 0;model=model?model.title:void 0;if(channel2&&model)return mergeTitle(channel2,model);if(channel2)return channel2;if(model)return model;if(void 0!==channel2)return channel2;if(void 0!==model)return model}function sortArrayIndexField(fieldDef,channel,opt){return vgField(fieldDef,{prefix:channel,suffix:"sort_index",...(opt??{})})}function getHeaderChannel(channel,
orient){return contains(["top","bottom"],orient)?"column":contains(["left","right"],orient)?"row":"row"===channel?"row":"column"}function getHeaderProperty(prop,header,config,channel){return getFirstDefined((header||{})[prop],("row"===channel?config.headerRow:"column"===channel?config.headerColumn:config.headerFacet)[prop],config.header[prop])}function getHeaderProperties(properties,header,config,channel){const props={};for(const prop of properties)properties=getHeaderProperty(prop,header||{},config,
channel),void 0!==properties&&(props[prop]=properties);return props}function defaultHeaderGuideAlign(headerChannel,angle){switch(2<arguments.length&&void 0!==arguments[2]?arguments[2]:"middle"){case "start":return{align:"left"};case "end":return{align:"right"}}const align=defaultLabelAlign(angle,"row"===headerChannel?"left":"top","row"===headerChannel?"y":"x");return align?{align}:{}}function defaultHeaderGuideBaseline(angle,channel){return(angle=defaultLabelBaseline(angle,"row"===channel?"left":
"top","row"===channel?"y":"x",!0))?{baseline:angle}:{}}function assembleLabelTitle(facetFieldDef,channel,config){const {format,formatType,labelAngle,labelAnchor,labelOrient,labelExpr}=getHeaderProperties("format formatType labelAngle labelAnchor labelOrient labelExpr".split(" "),facetFieldDef.header,config,channel),titleTextExpr=formatSignalRef({fieldOrDatumDef:facetFieldDef,format,formatType,expr:"parent",config}).signal,headerChannel=getHeaderChannel(channel,labelOrient);return{text:{signal:labelExpr?
replaceAll(replaceAll(labelExpr,"datum.label",titleTextExpr),"datum.value",vgField(facetFieldDef,{expr:"parent"})):titleTextExpr},...("row"===channel?{orient:"left"}:{}),style:"guide-label",frame:"group",...defaultHeaderGuideBaseline(labelAngle,headerChannel),...defaultHeaderGuideAlign(headerChannel,labelAngle,labelAnchor),...assembleHeaderProperties(config,facetFieldDef,channel,HEADER_LABEL_PROPERTIES,HEADER_LABEL_PROPERTIES_MAP)}}function assembleHeaderProperties(config,facetFieldDef,channel,properties,
propertiesMap){const props={};for(const prop of properties)propertiesMap[prop]&&(properties=getHeaderProperty(prop,facetFieldDef?.header,config,channel),void 0!==properties&&(props[propertiesMap[prop]]=properties));return props}function assembleLayoutSignals(model){return[...sizeSignals(model,"width"),...sizeSignals(model,"height"),...sizeSignals(model,"childWidth"),...sizeSignals(model,"childHeight")]}function sizeSignals(model,sizeType){var channel="width"===sizeType?"x":"y",size=model.component.layoutSize.get(sizeType);
if(!size||"merged"===size)return[];sizeType=model.getSizeSignalRef(sizeType).signal;if("step"===size){if(size=model.getScaleComponent(channel)){var type=size.get("type");const range=size.get("range");if(hasDiscreteDomain(type)&&isVgRangeStep(range))return type=model.scaleName(channel),isFacetModel(model.parent)&&"independent"===model.parent.component.resolve.scale[channel]?[stepSignal(type,range)]:[stepSignal(type,range),{name:sizeType,update:sizeExpr(type,size,`domain('${type}').length`)}]}throw Error("layout size is step although width/height is not step.");
}return"container"==size?(channel=(size=sizeType.endsWith("width"))?"containerSize()[0]":"containerSize()[1]",model=getViewConfigContinuousSize(model.config.view,size?"width":"height"),model=`isFinite(${channel}) ? ${channel} : ${model}`,[{name:sizeType,init:model,on:[{update:model,events:"window:resize"}]}]):[{name:sizeType,value:size}]}function stepSignal(scaleName,range){scaleName=`${scaleName}_step`;return isSignalRef(range.step)?{name:scaleName,update:range.step.signal}:{name:scaleName,value:range.step}}
function sizeExpr(scaleName,scaleComponent,cardinality){const type=scaleComponent.get("type"),padding=scaleComponent.get("padding"),paddingOuter=getFirstDefined(scaleComponent.get("paddingOuter"),padding);scaleComponent=scaleComponent.get("paddingInner");return`bandspace(${cardinality}, ${signalOrStringValue("band"===type?void 0!==scaleComponent?scaleComponent:padding:1)}, ${signalOrStringValue(paddingOuter)}) * ${scaleName}_step`}function getSizeTypeFromLayoutSizeType(layoutSizeType){return"childWidth"===
layoutSizeType?"width":"childHeight"===layoutSizeType?"height":layoutSizeType}function guideEncodeEntry(encoding,model){return keys$jscomp$0(encoding).reduce((encode,channel)=>({...encode,...wrapCondition(model,encoding[channel],channel,def=>signalOrValueRef(def.value))}),{})}function defaultScaleResolve(channel,model){if(isFacetModel(model))return"theta"===channel?"independent":"shared";if(isLayerModel(model))return"shared";if("concat"===model?.type)return isXorY(channel)||"theta"===channel||"radius"===
channel?"independent":"shared";throw Error("invalid model type for resolve");}function parseGuideResolve(resolve,channel){const channelScaleResolve=resolve.scale[channel],guide=isXorY(channel)?"axis":"legend";return"independent"===channelScaleResolve?("shared"===resolve[guide][channel]&&warn(`Setting the scale to be independent for "${channel}" means we also have to set the guide (axis or legend) to be independent.`),"independent"):resolve[guide][channel]||"shared"}function getMaxValue(channelDef){return getConditionValue(channelDef,
(v,conditionalDef)=>Math.max(v,conditionalDef.value))}function getFirstConditionValue(channelDef){return getConditionValue(channelDef,(v,conditionalDef)=>getFirstDefined(v,conditionalDef.value))}function getConditionValue(channelDef,reducer){const condition=channelDef?.condition;if(condition&&(vega.isArray(condition)||isValueDef(condition)))return vega.array(channelDef.condition).reduce(reducer,channelDef.value);if(isValueDef(channelDef))return channelDef.value}function selectedCondition(model,legendCmpt,
fieldDef){model=legendCmpt.get("selections");if(model?.length){var field=vega.stringValue(fieldDef.field);return model.map(name=>`(!length(data(${vega.stringValue(varName(name)+"_store")})) || (${name}[${field}] && indexof(${name}[${field}], datum.value) >= 0))`).join(" || ")}}function gradientLengthSignal(model,sizeType,min,max){return{signal:`clamp(${model.getSizeSignalRef(sizeType).signal}, ${min}, ${max})`}}function parseLegend(model){if(isUnitModel(model)){var {encoding:encoding$jscomp$0}=model,
legendComponent={};for(JSCompiler_temp of["color",...LEGEND_SCALE_CHANNELS]){var def=getFieldOrDatumDef(encoding$jscomp$0[JSCompiler_temp]);if(def&&model.getScaleComponent(JSCompiler_temp)&&("shape"!==JSCompiler_temp||!isFieldDef(def)||"geojson"!==def.type)){a:{def=model;var channel$jscomp$0=JSCompiler_temp,legend$jscomp$0=def.legend(channel$jscomp$0);const {markDef,encoding,config}=def;var legendConfig$jscomp$0=config.legend;b:{var JSCompiler_inline_result=def;var channel$jscomp$1=channel$jscomp$0;
var JSCompiler_inline_result$jscomp$0=JSCompiler_inline_result.scaleName(channel$jscomp$1);if("trail"===JSCompiler_inline_result.mark){if("color"===channel$jscomp$1){JSCompiler_inline_result={stroke:JSCompiler_inline_result$jscomp$0};break b}if("size"===channel$jscomp$1){JSCompiler_inline_result={strokeWidth:JSCompiler_inline_result$jscomp$0};break b}}JSCompiler_inline_result="color"===channel$jscomp$1?JSCompiler_inline_result.markDef.filled?{fill:JSCompiler_inline_result$jscomp$0}:{stroke:JSCompiler_inline_result$jscomp$0}:
{[channel$jscomp$1]:JSCompiler_inline_result$jscomp$0}}JSCompiler_inline_result=new LegendComponent({},JSCompiler_inline_result);channel$jscomp$1=def.fieldDef(channel$jscomp$0)?.field;for(const selCmpt of vals$jscomp$0(def.component.selection??{}))if((JSCompiler_inline_result$jscomp$0=selCmpt.project.hasField[channel$jscomp$1]??selCmpt.project.hasChannel[channel$jscomp$0])&&legendBindings.defined(selCmpt)){var legendSelections=JSCompiler_inline_result.get("selections")??[];legendSelections.push(selCmpt.name);
JSCompiler_inline_result.set("selections",legendSelections,!1);JSCompiler_inline_result$jscomp$0.hasLegend=!0}channel$jscomp$1=void 0!==legend$jscomp$0?!legend$jscomp$0:legendConfig$jscomp$0.disable;JSCompiler_inline_result.set("disable",channel$jscomp$1,void 0!==legend$jscomp$0);if(channel$jscomp$1){def=JSCompiler_inline_result;break a}legend$jscomp$0=legend$jscomp$0||{};legendSelections=def.getScaleComponent(channel$jscomp$0).get("type");channel$jscomp$1=getFieldOrDatumDef(encoding[channel$jscomp$0]);
JSCompiler_inline_result$jscomp$0=isFieldDef(channel$jscomp$1)?normalizeTimeUnit(channel$jscomp$1.timeUnit)?.unit:void 0;var orient$jscomp$0=legend$jscomp$0.orient||config.legend.orient||"right";JSCompiler_inline_result$jscomp$0={legend:legend$jscomp$0,channel:channel$jscomp$0,timeUnit:JSCompiler_inline_result$jscomp$0,scaleType:legendSelections};var {legend:legend$jscomp$1}=JSCompiler_inline_result$jscomp$0;legend$jscomp$1=legend$jscomp$1.type;b:{let {channel,timeUnit,scaleType}=JSCompiler_inline_result$jscomp$0;
if(isColorChannel(channel)){if(contains(["quarter","month","day"],timeUnit)){JSCompiler_inline_result$jscomp$0="symbol";break b}if(CONTINUOUS_TO_CONTINUOUS_SCALES.has(scaleType)){JSCompiler_inline_result$jscomp$0="gradient";break b}}JSCompiler_inline_result$jscomp$0="symbol"}JSCompiler_inline_result$jscomp$0=getFirstDefined(legend$jscomp$1,JSCompiler_inline_result$jscomp$0);let {legendConfig,legendType,orient,legend}={legend:legend$jscomp$0,legendType:JSCompiler_inline_result$jscomp$0,orient:orient$jscomp$0,
legendConfig:legendConfig$jscomp$0};if(null==(legend$jscomp$1=legend.direction??legendConfig[legendType?"gradientDirection":"symbolDirection"]))b:{switch(orient){case "top":case "bottom":legend$jscomp$1="horizontal";break b;case "left":case "right":case "none":case void 0:break;default:legend$jscomp$1="gradient"===legendType?"horizontal":void 0;break b}legend$jscomp$1=void 0}legendConfig$jscomp$0={legend:legend$jscomp$0,channel:channel$jscomp$0,model:def,markDef,encoding,fieldOrDatumDef:channel$jscomp$1,
legendConfig:legendConfig$jscomp$0,config,scaleType:legendSelections,orient:orient$jscomp$0,legendType:JSCompiler_inline_result$jscomp$0,direction:legend$jscomp$1};for(const property of LEGEND_COMPONENT_PROPERTIES)if(!("gradient"===JSCompiler_inline_result$jscomp$0&&property.startsWith("symbol")||"symbol"===JSCompiler_inline_result$jscomp$0&&property.startsWith("gradient"))&&(legendSelections=property in legendRules?legendRules[property](legendConfig$jscomp$0):legend$jscomp$0[property],void 0!==legendSelections)){b:{orient$jscomp$0=
def.fieldDef(channel$jscomp$0);switch(property){case "disable":orient$jscomp$0=void 0!==legend$jscomp$0;break b;case "values":orient$jscomp$0=!!legend$jscomp$0?.values;break b;case "title":if("title"===property&&legendSelections===orient$jscomp$0?.title){orient$jscomp$0=!0;break b}}orient$jscomp$0=legendSelections===(legend$jscomp$0||{})[property]}(orient$jscomp$0||void 0===config.legend[property])&&JSCompiler_inline_result.set(property,legendSelections,orient$jscomp$0)}legendConfig$jscomp$0=legend$jscomp$0?.encoding??
{};legendSelections=JSCompiler_inline_result.get("selections");orient$jscomp$0={};channel$jscomp$0={fieldOrDatumDef:channel$jscomp$1,model:def,channel:channel$jscomp$0,legendCmpt:JSCompiler_inline_result,legendType:JSCompiler_inline_result$jscomp$0};for(const part of"labels legend title symbols gradient entries".split(" "))JSCompiler_inline_result$jscomp$0=guideEncodeEntry(legendConfig$jscomp$0[part]??{},def),JSCompiler_inline_result$jscomp$0=part in legendEncodeRules?legendEncodeRules[part](JSCompiler_inline_result$jscomp$0,
channel$jscomp$0):JSCompiler_inline_result$jscomp$0,void 0===JSCompiler_inline_result$jscomp$0||isEmpty(JSCompiler_inline_result$jscomp$0)||(orient$jscomp$0[part]={...(legendSelections?.length&&isFieldDef(channel$jscomp$1)?{name:`${varName(channel$jscomp$1.field)}_legend_${part}`}:{}),...(legendSelections?.length?{interactive:!!legendSelections}:{}),update:JSCompiler_inline_result$jscomp$0});isEmpty(orient$jscomp$0)||JSCompiler_inline_result.set("encode",orient$jscomp$0,!!legend$jscomp$0?.encoding);
def=JSCompiler_inline_result}legendComponent[JSCompiler_temp]=def}}var JSCompiler_temp=legendComponent}else{const {legends,resolve}=model.component;for(encoding$jscomp$0 of model.children){parseLegend(encoding$jscomp$0);for(legendComponent of keys$jscomp$0(encoding$jscomp$0.component.legends))resolve.legend[legendComponent]=parseGuideResolve(model.component.resolve,legendComponent),"shared"===resolve.legend[legendComponent]&&(legends[legendComponent]=mergeLegendComponent(legends[legendComponent],
encoding$jscomp$0.component.legends[legendComponent]),legends[legendComponent]||(resolve.legend[legendComponent]="independent",delete legends[legendComponent]))}for(def of keys$jscomp$0(legends))for(legend$jscomp$0 of model.children)legend$jscomp$0.component.legends[def]&&"shared"===resolve.legend[def]&&delete legend$jscomp$0.component.legends[def];JSCompiler_temp=legends}return model.component.legends=JSCompiler_temp}function mergeLegendComponent(mergedLegend,childLegend){if(!mergedLegend)return childLegend.clone();
var mergedOrient=mergedLegend.getWithExplicit("orient");const childOrient=childLegend.getWithExplicit("orient");if(!mergedOrient.explicit||!childOrient.explicit||mergedOrient.value===childOrient.value){var typeMerged=!1;for(const prop of LEGEND_COMPONENT_PROPERTIES)mergedOrient=mergeValuesWithExplicit(mergedLegend.getWithExplicit(prop),childLegend.getWithExplicit(prop),prop,"legend",(v1,v2)=>{switch(prop){case "symbolType":return v1="circle"===v2.value?v2:v1,v1;case "title":return mergeTitleComponent(v1,
v2);case "type":return typeMerged=!0,makeImplicit("symbol")}return defaultTieBreaker(v1,v2,prop,"legend")}),mergedLegend.setWithExplicit(prop,mergedOrient);typeMerged&&(mergedLegend.implicit?.encode?.gradient&&deleteNestedProperty(mergedLegend.implicit,["encode","gradient"]),mergedLegend.explicit?.encode?.gradient&&deleteNestedProperty(mergedLegend.explicit,["encode","gradient"]));return mergedLegend}}function assembleLegends(model){const legendComponentIndex=model.component.legends,legendByDomain=
{};for(const channel of keys$jscomp$0(legendComponentIndex)){var scaleComponent=model.getScaleComponent(channel);scaleComponent=stringify(scaleComponent.get("domains"));if(legendByDomain[scaleComponent])for(const mergedLegendComponent of legendByDomain[scaleComponent])mergeLegendComponent(mergedLegendComponent,legendComponentIndex[channel])||legendByDomain[scaleComponent].push(legendComponentIndex[channel]);else legendByDomain[scaleComponent]=[legendComponentIndex[channel].clone()]}return vals$jscomp$0(legendByDomain).flat().map(l=>
{{var config=model.config;const {disable,labelExpr,selections,...legend}=l.combine();if(disable)var JSCompiler_inline_result=void 0;else{!1===config.aria&&void 0==legend.aria&&(legend.aria=!1);if(legend.encode?.symbols){l=legend.encode.symbols.update;!l.fill||"transparent"===l.fill.value||l.stroke||legend.stroke||(l.stroke={value:"transparent"});for(var property of LEGEND_SCALE_CHANNELS)legend[property]&&delete l[property]}legend.title||delete legend.title;if(void 0!==labelExpr){l=labelExpr;legend.encode?.labels?.update&&
isSignalRef(legend.encode.labels.update.text)&&(l=replaceAll(labelExpr,"datum.label",legend.encode.labels.update.text.signal));property=legend;l={signal:l};property.encode??(property.encode={});(JSCompiler_inline_result=property.encode).labels??(JSCompiler_inline_result.labels={});let $jscomp$inline_2780;($jscomp$inline_2780=property.encode.labels).update??($jscomp$inline_2780.update={});property.encode.labels.update.text=l}JSCompiler_inline_result=legend}}return JSCompiler_inline_result}).filter(l=>
void 0!==l)}function assembleProjectionsForModelAndChildren(model){return model.children.reduce((projections,child)=>projections.concat(child.assembleProjections()),assembleProjectionForModel(model))}function assembleProjectionForModel(model){var component=model.component.projection;if(!component||component.merged)return[];const projection=component.combine(),{name}=projection;if(component.data){const size={signal:`[${component.size.map(ref=>ref.signal).join(", ")}]`};component=component.data.reduce((sources,
data)=>{data=isSignalRef(data)?data.signal:`data('${model.lookupDataSource(data)}')`;sources.includes(data)||sources.push(data);return sources},[]);if(0>=component.length)throw Error("Projection's fit didn't find any data sources");return[{name,size,fit:{signal:1<component.length?`[${component.join(", ")}]`:component[0]},...projection}]}return[{name,translate:{signal:"[width / 2, height / 2]"},...projection}]}function parseProjection(model){var JSCompiler_temp_const=model.component;if(isUnitModel(model))if(model.hasProjection){const proj=
replaceExprRef(model.specifiedProjection);var fit=!(proj&&(null!=proj.scale||null!=proj.translate));const size=fit?[model.getSizeSignalRef("width"),model.getSizeSignalRef("height")]:void 0;if(fit){fit=[];const {encoding}=model;for(JSCompiler_temp of[["longitude","latitude"],["longitude2","latitude2"]])(getFieldOrDatumDef(encoding[JSCompiler_temp[0]])||getFieldOrDatumDef(encoding[JSCompiler_temp[1]]))&&fit.push({signal:model.getName(`geojson_${fit.length}`)});model.channelHasField("shape")&&"geojson"===
model.typedFieldDef("shape").type&&fit.push({signal:model.getName(`geojson_${fit.length}`)});0===fit.length&&fit.push(model.requestDataName(DataSourceType.Main));var JSCompiler_temp=fit}else JSCompiler_temp=void 0;model=new ProjectionComponent(model.projectionName(!0),{...(replaceExprRef(model.config.projection)??{}),...(proj??{})},size,JSCompiler_temp);model.get("type")||model.set("type","equalEarth",!1)}else model=void 0;else model=parseNonUnitProjections(model);JSCompiler_temp_const.projection=
model}function mergeIfNoConflict(first,second){const allPropertiesShared=every(PROJECTION_PROPERTIES,prop=>!vega.hasOwnProperty(first.explicit,prop)&&!vega.hasOwnProperty(second.explicit,prop)||vega.hasOwnProperty(first.explicit,prop)&&vega.hasOwnProperty(second.explicit,prop)&&deepEqual(first.get(prop),second.get(prop))?!0:!1);if(deepEqual(first.size,second.size)){if(allPropertiesShared)return first;if(deepEqual(first.explicit,{}))return second;if(deepEqual(second.explicit,{}))return first}return null}
function parseNonUnitProjections(model){if(0!==model.children.length){var nonUnitProjection;for(var child$jscomp$0 of model.children)parseProjection(child$jscomp$0);child$jscomp$0=every(model.children,child=>{if(child=child.component.projection){if(nonUnitProjection)return(child=mergeIfNoConflict(nonUnitProjection,child))&&(nonUnitProjection=child),!!child;nonUnitProjection=child}return!0});if(nonUnitProjection&&child$jscomp$0){child$jscomp$0=model.projectionName(!0);const modelProjection=new ProjectionComponent(child$jscomp$0,
nonUnitProjection.specifiedProjection,nonUnitProjection.size,duplicate(nonUnitProjection.data));for(const child of model.children)if(model=child.component.projection)model.isFit&&modelProjection.data.push(...child.component.projection.data),child.renameProjection(model.get("name"),child$jscomp$0),model.merged=!0;return modelProjection}}}function getBinSignalName(model,field,bin){bin=normalizeBin(bin,void 0)??{};field=`${binToString(bin)}_${field}`;return model.getName(`${field}_bins`)}function createBinComponent(t,
bin,model){let as;as="as"in t?vega.isString(t.as)?[t.as,`${t.as}_end`]:[t.as[0],t.as[1]]:[vgField(t,{forAs:!0}),vgField(t,{binSuffix:"end",forAs:!0})];bin={...normalizeBin(bin,void 0)};var JSCompiler_inline_result=t.field;JSCompiler_inline_result=`${binToString(bin)}_${JSCompiler_inline_result}`;var JSCompiler_inline_result$jscomp$0={signal:model.getName(`${JSCompiler_inline_result}_bins`),extentSignal:model.getName(`${JSCompiler_inline_result}_extent`)};const {signal,extentSignal}=JSCompiler_inline_result$jscomp$0;
if(bin.extent?.param){var span=bin.extent;span=parseSelectionExtent(model,span.param,span);delete bin.extent}return{key:JSCompiler_inline_result,binComponent:{bin,field:t.field,as:[as],...(signal?{signal}:{}),...(extentSignal?{extentSignal}:{}),...(span?{span}:{})}}}function unquote(pattern){return pattern.startsWith("'")&&pattern.endsWith("'")||pattern.startsWith('"')&&pattern.endsWith('"')?pattern.slice(1,-1):pattern}function parseExpression(field,parse){field=accessPathWithDatum(field);if("number"===
parse)return`toNumber(${field})`;if("boolean"===parse)return`toBoolean(${field})`;if("string"===parse)return`toString(${field})`;if("date"===parse)return`toDate(${field})`;if("flatten"===parse)return field;if(parse.startsWith("date:"))return parse=unquote(parse.slice(5,parse.length)),`timeParse(${field},'${parse}')`;if(parse.startsWith("utc:"))return parse=unquote(parse.slice(4,parse.length)),`utcParse(${field},'${parse}')`;warn(`Unrecognized parse "${parse}".`);return null}function getImplicitFromFilterTransform(transform){const implicit=
{};forEachLeaf(transform.filter,filter=>{if(isFieldPredicate(filter)){let val=null;filter?.field&&void 0!==filter.equal?val=signalRefOrValue(filter.equal):filter?.field&&void 0!==filter.lte?val=signalRefOrValue(filter.lte):filter?.field&&void 0!==filter.lt?val=signalRefOrValue(filter.lt):filter?.field&&void 0!==filter.gt?val=signalRefOrValue(filter.gt):filter?.field&&void 0!==filter.gte?val=signalRefOrValue(filter.gte):isFieldRangePredicate(filter)?val=filter.range[0]:isFieldOneOfPredicate(filter)&&
(val=(filter.oneOf??filter["in"])[0]);val&&(isDateTime(val)?implicit[filter.field]="date":vega.isNumber(val)?implicit[filter.field]="number":vega.isString(val)&&(implicit[filter.field]="string"));filter.timeUnit&&(implicit[filter.field]="date")}});return implicit}function getImplicitFromEncoding(model){function add(fieldDef){if(isFieldOrDatumDefForTimeFormat(fieldDef))implicit[fieldDef.field]="date";else{var JSCompiler_temp;if(JSCompiler_temp="quantitative"===fieldDef.type)JSCompiler_temp=fieldDef.aggregate,
JSCompiler_temp=vega.isString(JSCompiler_temp)&&contains(["min","max"],JSCompiler_temp);JSCompiler_temp?implicit[fieldDef.field]="number":1<accessPathDepth(fieldDef.field)?fieldDef.field in implicit||(implicit[fieldDef.field]="flatten"):isScaleFieldDef(fieldDef)&&isSortField(fieldDef.sort)&&1<accessPathDepth(fieldDef.sort.field)&&(fieldDef.sort.field in implicit||(implicit[fieldDef.sort.field]="flatten"))}}const implicit={};(isUnitModel(model)||isFacetModel(model))&&model.forEachFieldDef((fieldDef,
channel)=>{isTypedFieldDef(fieldDef)?add(fieldDef):(channel=getMainRangeChannel(channel),channel=model.fieldDef(channel),add({...fieldDef,type:channel.type}))});if(isUnitModel(model)){const {mark,markDef,encoding}=model;if(isPathMark(mark)&&!model.encoding.order){const dimensionChannelDef=encoding["horizontal"===markDef.orient?"y":"x"];!isFieldDef(dimensionChannelDef)||"quantitative"!==dimensionChannelDef.type||dimensionChannelDef.field in implicit||(implicit[dimensionChannelDef.field]="number")}}return implicit}
function isDataSourceNode(node){return node instanceof SourceNode||node instanceof GraticuleNode||node instanceof SequenceNode}function getStackByFields(model){return model.stack.stackBy.reduce((fields,by)=>{(by=vgField(by.fieldDef))&&fields.push(by);return fields},[])}function isValidAsArray(as){return vega.isArray(as)&&as.every(s=>vega.isString(s))&&1<as.length}function cloneSubtree(facet){function clone(node){if(!(node instanceof FacetNode)){const copy=node.clone();if(copy instanceof OutputNode){const newName=
"scale_"+copy.getSource();copy.setSource(newName);facet.model.component.data.outputNodes[newName]=copy}else(copy instanceof AggregateNode||copy instanceof StackNode||copy instanceof WindowTransformNode||copy instanceof JoinAggregateTransformNode)&&copy.addDimensions(facet.fields);for(const n of node.children.flatMap(clone))n.parent=copy;return[copy]}return node.children.flatMap(clone)}return clone}function moveFacetDown(node){if(node instanceof FacetNode)if(1!==node.numChildren()||node.children[0]instanceof
OutputNode){var facetMain=node.model.component.data.main;moveMainDownToFacet(facetMain);const cloner=cloneSubtree(node);node=node.children.map(cloner).flat();for(const c of node)c.parent=facetMain}else facetMain=node.children[0],(facetMain instanceof AggregateNode||facetMain instanceof StackNode||facetMain instanceof WindowTransformNode||facetMain instanceof JoinAggregateTransformNode)&&facetMain.addDimensions(node.fields),facetMain.swapWithParent(),moveFacetDown(node);else node.children.map(moveFacetDown)}
function moveMainDownToFacet(node){if(node instanceof OutputNode&&node.type===DataSourceType.Main&&1===node.numChildren()){const child=node.children[0];child instanceof FacetNode||(child.swapWithParent(),moveMainDownToFacet(node))}}function checkLinks(nodes){for(const node of nodes){for(const child of node.children)if(child.parent!==node)return!1;if(!checkLinks(node.children))return!1}return!0}function runOptimizer(optimizer,nodes){let modified=!1;for(const node of nodes)modified=optimizer.optimize(node)||
modified;return modified}function optimizationDataflowHelper(dataComponent,model,firstPass){let roots=dataComponent.sources,modified=!1;modified=runOptimizer(new RemoveUnnecessaryOutputNodes,roots)||modified;modified=runOptimizer(new RemoveUnnecessaryIdentifierNodes(model),roots)||modified;roots=roots.filter(r=>0<r.numChildren());modified=runOptimizer(new RemoveUnusedSubtrees,roots)||modified;roots=roots.filter(r=>0<r.numChildren());firstPass||(modified=runOptimizer(new MoveParseUp,roots)||modified,
modified=runOptimizer(new MergeBins(model),roots)||modified,modified=runOptimizer(new RemoveDuplicateTimeUnits,roots)||modified,modified=runOptimizer(new MergeParse,roots)||modified,modified=runOptimizer(new MergeAggregates,roots)||modified,modified=runOptimizer(new MergeTimeUnits,roots)||modified,modified=runOptimizer(new MergeIdenticalNodes,roots)||modified,modified=runOptimizer(new MergeOutputs,roots)||modified);dataComponent.sources=roots;return modified}function parseUnitScaleDomain(model$jscomp$0){const localScaleComponents=
model$jscomp$0.component.scales;for(const channel of keys$jscomp$0(localScaleComponents)){var model=model$jscomp$0,channel$jscomp$0=channel,scaleType=model.getScaleComponent(channel$jscomp$0).get("type"),{encoding}=model;var JSCompiler_inline_result=model.scaleDomain(channel$jscomp$0);var fieldDef=model.typedFieldDef(channel$jscomp$0),scaleConfig=model.config.scale;if("unaggregated"===JSCompiler_inline_result){const {valid,reason}=canUseUnaggregatedDomain(fieldDef,scaleType);valid||(warn(reason),
JSCompiler_inline_result=void 0)}else void 0===JSCompiler_inline_result&&scaleConfig.useUnaggregatedDomain&&({valid:fieldDef}=canUseUnaggregatedDomain(fieldDef,scaleType),fieldDef&&(JSCompiler_inline_result="unaggregated"));JSCompiler_inline_result!==model.scaleDomain(channel$jscomp$0)&&(model.specifiedScales[channel$jscomp$0]={...model.specifiedScales[channel$jscomp$0],domain:JSCompiler_inline_result});model="x"===channel$jscomp$0&&getFieldOrDatumDef(encoding.x2)?getFieldOrDatumDef(encoding.x)?mergeValuesWithExplicit(parseSingleChannelDomain(scaleType,
JSCompiler_inline_result,model,"x"),parseSingleChannelDomain(scaleType,JSCompiler_inline_result,model,"x2"),"domain","scale",domainsTieBreaker):parseSingleChannelDomain(scaleType,JSCompiler_inline_result,model,"x2"):"y"===channel$jscomp$0&&getFieldOrDatumDef(encoding.y2)?getFieldOrDatumDef(encoding.y)?mergeValuesWithExplicit(parseSingleChannelDomain(scaleType,JSCompiler_inline_result,model,"y"),parseSingleChannelDomain(scaleType,JSCompiler_inline_result,model,"y2"),"domain","scale",domainsTieBreaker):
parseSingleChannelDomain(scaleType,JSCompiler_inline_result,model,"y2"):parseSingleChannelDomain(scaleType,JSCompiler_inline_result,model,channel$jscomp$0);localScaleComponents[channel].setWithExplicit("domains",model);channel$jscomp$0=model$jscomp$0.component.scales[channel];encoding=model$jscomp$0.specifiedScales[channel].domain;scaleType=model$jscomp$0.fieldDef(channel)?.bin;encoding=encoding?.param&&encoding;scaleType=vega.isObject(scaleType)&&scaleType.extent?.param&&scaleType.extent;(encoding||
scaleType)&&channel$jscomp$0.set("selectionExtent",encoding??scaleType,!0);if(model$jscomp$0.component.data.isFaceted){for(channel$jscomp$0=model$jscomp$0;!isFacetModel(channel$jscomp$0)&&channel$jscomp$0.parent;)channel$jscomp$0=channel$jscomp$0.parent;if("shared"===channel$jscomp$0.component.resolve.scale[channel])for(const domain of model.value)isDataRefDomain(domain)&&(domain.data="scale_"+domain.data.replace("scale_",""))}}}function parseNonUnitScaleDomain(model$jscomp$0){for(var child$jscomp$0 of model$jscomp$0.children){var model=
child$jscomp$0;isUnitModel(model)?parseUnitScaleDomain(model):parseNonUnitScaleDomain(model)}model=model$jscomp$0.component.scales;for(const channel of keys$jscomp$0(model)){let domains;child$jscomp$0=null;for(const child of model$jscomp$0.children){var childComponent=child.component.scales[channel];childComponent&&(domains=void 0===domains?childComponent.getWithExplicit("domains"):mergeValuesWithExplicit(domains,childComponent.getWithExplicit("domains"),"domains","scale",domainsTieBreaker),childComponent=
childComponent.get("selectionExtent"),child$jscomp$0&&childComponent&&child$jscomp$0.param!==childComponent.param&&warn("The same selection must be used to override scale domains in a layered view."),child$jscomp$0=childComponent)}model[channel].setWithExplicit("domains",domains);child$jscomp$0&&model[channel].set("selectionExtent",child$jscomp$0,!0)}}function mapDomainToDataSignal(domain,type,timeUnit){return domain.map(v=>({signal:`{data: ${valueExpr(v,{timeUnit,type})}}`}))}function convertDomainIfItIsDateTime(domain,
type,timeUnit){timeUnit=normalizeTimeUnit(timeUnit)?.unit;return"temporal"===type||timeUnit?mapDomainToDataSignal(domain,type,timeUnit):[domain]}function parseSingleChannelDomain(scaleType,domain,model,channel){var {encoding}=model;encoding=getFieldOrDatumDef(encoding[channel]);const {type}=encoding,timeUnit=encoding.timeUnit;if(domain?.unionWith)return channel=parseSingleChannelDomain(scaleType,void 0,model,channel),domain=convertDomainIfItIsDateTime(domain.unionWith,type,timeUnit),makeExplicit([...domain,
...channel.value]);if(isSignalRef(domain))return makeExplicit([domain]);if(domain&&"unaggregated"!==domain&&!domain?.param)return makeExplicit(convertDomainIfItIsDateTime(domain,type,timeUnit));var stack=model.stack;if(stack&&channel===stack.fieldChannel){if("normalize"===stack.offset)return makeImplicit([[0,1]]);domain=model.requestDataName(DataSourceType.Main);return makeImplicit([{data:domain,field:model.vgField(channel,{suffix:"start"})},{data:domain,field:model.vgField(channel,{suffix:"end"})}])}stack=
SCALE_CHANNEL_INDEX[channel]&&isFieldDef(encoding)?domainSort(model,channel,scaleType):void 0;if(isDatumDef(encoding))return channel=convertDomainIfItIsDateTime([encoding.datum],type,timeUnit),makeImplicit(channel);if("unaggregated"===domain)return channel=model.requestDataName(DataSourceType.Main),{field:domain}=encoding,makeImplicit([{data:channel,field:vgField({field:domain,aggregate:"min"})},{data:channel,field:vgField({field:domain,aggregate:"max"})}]);if(isBinning(encoding.bin)){if(hasDiscreteDomain(scaleType))return"bin-ordinal"===
scaleType?makeImplicit([]):makeImplicit([{data:isBoolean(stack)?model.requestDataName(DataSourceType.Main):model.requestDataName(DataSourceType.Raw),field:model.vgField(channel,binRequiresRange(encoding,channel)?{binSuffix:"range"}:{}),sort:!0!==stack&&vega.isObject(stack)?stack:{field:model.vgField(channel,{}),op:"min"}}]);({bin:domain}=encoding);if(isBinning(domain)){const binSignal=getBinSignalName(model,encoding.field,domain);return makeImplicit([new SignalRefWrapper(()=>{const signal=model.getSignalName(binSignal);
return`[${signal}.start, ${signal}.stop]`})])}return makeImplicit([{data:model.requestDataName(DataSourceType.Main),field:model.vgField(channel,{})}])}return encoding.timeUnit&&contains(["time","utc"],scaleType)&&hasBandEnd(encoding,isUnitModel(model)?model.encoding[getSecondaryRangeChannel(channel)]:void 0,model.markDef,model.config)?(domain=model.requestDataName(DataSourceType.Main),makeImplicit([{data:domain,field:model.vgField(channel)},{data:domain,field:model.vgField(channel,{suffix:"end"})}])):
stack?makeImplicit([{data:isBoolean(stack)?model.requestDataName(DataSourceType.Main):model.requestDataName(DataSourceType.Raw),field:model.vgField(channel),sort:stack}]):makeImplicit([{data:model.requestDataName(DataSourceType.Main),field:model.vgField(channel)}])}function normalizeSortField(sort,isStackedMeasure){const {op,field,order}=sort;return{op:op??(isStackedMeasure?"sum":"min"),...(field?{field:replacePathInField(field)}:{}),...(order?{order}:{})}}function domainSort(model,channel,scaleType){if(hasDiscreteDomain(scaleType)){var fieldDef=
model.fieldDef(channel);scaleType=fieldDef.sort;if(isSortArray(scaleType))return{op:"min",field:sortArrayIndexField(fieldDef,channel),order:"ascending"};({stack:fieldDef}=model);var stackDimensions=fieldDef?new Set([...fieldDef.groupbyFields,...fieldDef.stackBy.map(s=>s.fieldDef.field)]):void 0;if(isSortField(scaleType))return model=fieldDef&&!stackDimensions.has(scaleType.field),normalizeSortField(scaleType,model);if(scaleType?.encoding){const {encoding,order}=scaleType;model=model.fieldDef(encoding);
const {aggregate,field}=model;channel=fieldDef&&!stackDimensions.has(field);if(isArgminDef(aggregate)||isArgmaxDef(aggregate))return normalizeSortField({field:vgField(model),order},channel);if(isAggregateOp(aggregate)||!aggregate)return normalizeSortField({op:aggregate,field,order},channel)}else{if("descending"===scaleType)return{op:"min",field:model.vgField(channel),order:"descending"};if(contains(["ascending",void 0],scaleType))return!0}}}function canUseUnaggregatedDomain(fieldDef,scaleType){const {aggregate,
type}=fieldDef;return aggregate?vega.isString(aggregate)&&!SHARED_DOMAIN_OPS.has(aggregate)?{valid:!1,reason:`Unaggregated domain not applicable for "${aggregate}" since it produces values outside the origin domain of the source data.`}:"quantitative"===type&&"log"===scaleType?{valid:!1,reason:`Unaggregated domain is currently unsupported for log scale (${stringify(fieldDef)}).`}:{valid:!0}:{valid:!1,reason:`Using unaggregated domain with raw field has no effect (${stringify(fieldDef)}).`}}function domainsTieBreaker(v1,
v2$jscomp$0,property,propertyOf){if(v1.explicit&&v2$jscomp$0.explicit){var v2=v2$jscomp$0.value;property=`Conflicting ${propertyOf.toString()} property "${property.toString()}" (${stringify(v1.value)} and ${stringify(v2)}). Using the union of the two domains.`;warn(property)}return{explicit:v1.explicit,value:[...v1.value,...v2$jscomp$0.value]}}function mergeDomains(domains){var uniqueDomains=unique(domains.map(domain=>{if(isDataRefDomain(domain)){const {sort:_s,...domainWithoutSort}=domain;return domainWithoutSort}return domain}),
hash),sorts=unique(domains.map(d=>{if(isDataRefDomain(d))return d=d.sort,void 0===d||isBoolean(d)||("op"in d&&"count"===d.op&&delete d.field,"ascending"===d.order&&delete d.order),d}).filter(s=>void 0!==s),hash);if(0!==uniqueDomains.length){if(1===uniqueDomains.length){uniqueDomains=domains[0];if(isDataRefDomain(uniqueDomains)&&0<sorts.length){var sort=sorts[0];1<sorts.length?(warn("Domains that should be unioned has conflicting sort properties. Sort will be set to true."),sort=!0):vega.isObject(sort)&&
"field"in sort&&uniqueDomains.field===sort.field&&(sort=sort.order?{order:sort.order}:!0);return{...uniqueDomains,sort}}return uniqueDomains}sorts=unique(sorts.map(s=>{if(isBoolean(s)||!("op"in s)||vega.isString(s.op)&&s.op in MULTIDOMAIN_SORT_OP_INDEX)return s;warn(`Dropping sort property ${stringify(s)} as unioned domains only support boolean or op "count", "min", and "max".`);return!0}),hash);1===sorts.length?sort=sorts[0]:1<sorts.length&&(warn("Domains that should be unioned has conflicting sort properties. Sort will be set to true."),
sort=!0);sorts=unique(domains.map(d=>isDataRefDomain(d)?d.data:null),x=>x);return 1===sorts.length&&null!==sorts[0]?{data:sorts[0],fields:uniqueDomains.map(d=>d.field),...(sort?{sort}:{})}:{fields:uniqueDomains,...(sort?{sort}:{})}}}function getFieldFromDomain(domain){if(isDataRefDomain(domain)&&vega.isString(domain.field))return domain.field;var JSCompiler_inline_result=vega.isArray(domain)?!1:"fields"in domain&&!("data"in domain);if(JSCompiler_inline_result){let field;for(const nonUnionDomain of domain.fields)if(isDataRefDomain(nonUnionDomain)&&
vega.isString(nonUnionDomain.field))if(!field)field=nonUnionDomain.field;else if(field!==nonUnionDomain.field)return warn("Detected faceted independent scales that union domain of multiple fields from different data sources. We will use the first field. The result view size may be incorrect."),field;warn("Detected faceted independent scales that union domain of the same fields from different source. We will assume that this is the same field from a different fork of the same data source. However, if this is not the case, the result view size may be incorrect.");
return field}JSCompiler_inline_result=vega.isArray(domain)?!1:"fields"in domain&&"data"in domain;if(JSCompiler_inline_result)return warn("Detected faceted independent scales that union domain of multiple fields from the same data source. We will use the first field. The result view size may be incorrect."),domain=domain.fields[0],vega.isString(domain)?domain:void 0}function assembleDomain(model,channel){channel=model.component.scales[channel].get("domains").map(domain=>{isDataRefDomain(domain)&&(domain.data=
model.lookupDataSource(domain.data));return domain});return mergeDomains(channel)}function assembleScales(model){return isLayerModel(model)||"concat"===model?.type?model.children.reduce((scales,child)=>scales.concat(assembleScales(child)),assembleScalesForModel(model)):assembleScalesForModel(model)}function assembleScalesForModel(model){return keys$jscomp$0(model.component.scales).reduce((scales,channel)=>{var scaleComponent=model.component.scales[channel];if(scaleComponent.merged)return scales;var scale=
scaleComponent.combine();const {name,type,selectionExtent,domains:_d,range:_r,reverse,...otherScaleProps}=scale;scale=scale.range;isXorY(channel)?isVgRangeStep(scale)&&(scale={step:{signal:`${name}_step`}}):vega.isObject(scale)&&isDataRefDomain(scale)&&(scale={...scale,data:model.lookupDataSource(scale.data)});channel=assembleDomain(model,channel);if(selectionExtent){const parsedExtent=parseSelectionExtent(model,selectionExtent.param,selectionExtent);scaleComponent={signal:hasContinuousDomain(scaleComponent.get("type"))&&
vega.isArray(channel)&&channel[0]>channel[1]?`isValid(${parsedExtent}) && reverse(${parsedExtent})`:parsedExtent}}else scaleComponent=null;scales.push({name,type,...(channel?{domain:channel}:{}),...(scaleComponent?{domainRaw:scaleComponent}:{}),range:scale,...(void 0!==reverse?{reverse}:{}),...otherScaleProps});return scales},[])}function getBinStepSignal(model,channel){var fieldDef=model.fieldDef(channel);if(fieldDef?.bin){const {bin,field}=fieldDef;fieldDef=getSizeChannel(channel);const sizeSignal=
model.getName(fieldDef);if(vega.isObject(bin)&&bin.binned&&void 0!==bin.step)return new SignalRefWrapper(()=>{var scaleName=model.scaleName(channel);scaleName=`(domain("${scaleName}")[1] - domain("${scaleName}")[0]) / ${bin.step}`;return`${model.getSignalName(sizeSignal)} / (${scaleName})`});if(isBinning(bin)){const binSignal=getBinSignalName(model,field,bin);return new SignalRefWrapper(()=>{var updatedName=model.getSignalName(binSignal);updatedName=`(${updatedName}.stop - ${updatedName}.start) / ${updatedName}.step`;
return`${model.getSignalName(sizeSignal)} / (${updatedName})`})}}}function parseRangeForChannel(channel,model){const specifiedScale=model.specifiedScales[channel];var {size}=model,scaleType=model.getScaleComponent(channel).get("type");for(var property of RANGE_PROPERTIES)if(void 0!==specifiedScale[property]){const supportedByScaleType=scaleTypeSupportProperty(scaleType,property),channelIncompatability=channelScalePropertyIncompatability(channel,property);if(supportedByScaleType)if(channelIncompatability)warn(channelIncompatability);
else switch(property){case "range":scaleType=specifiedScale.range;if(vega.isArray(scaleType)){if(isXorY(channel))return makeExplicit(scaleType.map(v=>{if("width"===v||"height"===v){v=model.getName(v);const getSignalName=model.getSignalName.bind(model);return SignalRefWrapper.fromName(getSignalName,v)}return v}))}else if(vega.isObject(scaleType))return makeExplicit({data:model.requestDataName(DataSourceType.Main),field:scaleType.field,sort:{op:"min",field:model.vgField(channel)}});return makeExplicit(scaleType);
case "scheme":return makeExplicit(parseScheme(specifiedScale[property]))}else warn(scalePropertyNotWorkWithScaleType(scaleType,property,channel))}property="x"===channel||"xOffset"===channel?"width":"height";size=size[property];if(isStep(size))if(isXorY(channel))if(hasDiscreteDomain(scaleType)){if(size=getPositionStep(size,model,channel))return makeExplicit({step:size})}else warn(stepDropped(property));else if(channel in OFFSET_SCALE_CHANNEL_INDEX&&"band"===model.getScaleComponent("xOffset"===channel?
"x":"y").get("type")&&(size=getOffsetStep(size,scaleType)))return makeExplicit(size);const {rangeMin,rangeMax}=specifiedScale;channel=defaultRange(channel,model);return(void 0!==rangeMin||void 0!==rangeMax)&&scaleTypeSupportProperty(scaleType,"rangeMin")&&vega.isArray(channel)&&2===channel.length?makeExplicit([rangeMin??channel[0],rangeMax??channel[1]]):makeImplicit(channel)}function parseScheme(scheme){return!vega.isString(scheme)&&scheme.name?{scheme:scheme.name,...omit(scheme,["name"])}:{scheme}}
function defaultRange(channel,model){const {size,config,mark,encoding}=model;var getSignalName=model.getSignalName.bind(model),{type}=getFieldOrDatumDef(encoding[channel]);const scaleType=model.getScaleComponent(channel).get("type"),{domain,domainMid}=model.specifiedScales[channel];switch(channel){case "x":case "y":if(contains(["point","band"],scaleType)&&(type=getDiscretePositionSize(channel,size,config.view),isStep(type)))return{step:getPositionStep(type,model,channel)};type=getSizeChannel(channel);
type=model.getName(type);return"y"===channel&&hasContinuousDomain(scaleType)?[SignalRefWrapper.fromName(getSignalName,type),0]:[0,SignalRefWrapper.fromName(getSignalName,type)];case "xOffset":case "yOffset":return getOffsetRange(channel,model,scaleType);case "size":return getSignalName=model.component.scales[channel].get("zero"),getSignalName=sizeRangeMin(mark,getSignalName,config),type=sizeRangeMax(mark,size,model,config),CONTINUOUS_TO_DISCRETE_SCALES.has(scaleType)?interpolateRange(getSignalName,
type,defaultContinuousToDiscreteCount(scaleType,config,domain,channel)):[getSignalName,type];case "theta":return[0,2*Math.PI];case "angle":return[0,360];case "radius":return[0,new SignalRefWrapper(()=>{const w=model.getSignalName("width"),h=model.getSignalName("height");return`min(${w},${h})/2`})];case "strokeWidth":return[config.scale.minStrokeWidth,config.scale.maxStrokeWidth];case "strokeDash":return[[1,0],[4,2],[2,1],[1,1],[1,2,4,2]];case "shape":return"symbol";case "color":case "fill":case "stroke":return"ordinal"===
scaleType?"nominal"===type?"category":"ordinal":void 0!==domainMid?"diverging":"rect"===mark||"geoshape"===mark?"heatmap":"ramp";case "opacity":case "fillOpacity":case "strokeOpacity":return[config.scale.minOpacity,config.scale.maxOpacity]}}function getPositionStep(step,model,channel){var {encoding}=model,mergedScaleCmpt=model.getScaleComponent(channel);channel=getOffsetScaleChannel(channel);const offsetDef=encoding[channel];return"offset"===getStepFor({step,offsetIsDiscrete:isFieldOrDatumDef(offsetDef)&&
isDiscrete$1(offsetDef.type)})&&channelHasFieldOrDatum(encoding,channel)?(encoding=model.getScaleComponent(channel),model=`domain('${model.scaleName(channel)}').length`,"band"===encoding.get("type")&&(channel=encoding.get("paddingInner")??encoding.get("padding")??0,encoding=encoding.get("paddingOuter")??encoding.get("padding")??0,model=`bandspace(${model}, ${channel}, ${encoding})`),encoding=mergedScaleCmpt.get("paddingInner")??mergedScaleCmpt.get("padding"),step=step.step,mergedScaleCmpt=model,model=
encoding,model=isSignalRef(model)?model.signal:vega.stringValue(model),{signal:`${step} * ${mergedScaleCmpt} / (1-${model})`}):step.step}function getOffsetStep(step,offsetScaleType){if("offset"===getStepFor({step,offsetIsDiscrete:hasDiscreteDomain(offsetScaleType)}))return{step:step.step}}function getOffsetRange(channel,model,offsetScaleType){const positionChannel="xOffset"===channel?"x":"y",positionScaleType=model.getScaleComponent(positionChannel).get("type"),positionScaleName=model.scaleName(positionChannel);
return"band"===positionScaleType?(channel=getDiscretePositionSize(positionChannel,model.size,model.config.view),isStep(channel)&&(offsetScaleType=getOffsetStep(channel,offsetScaleType))?offsetScaleType:[0,{signal:`bandwidth('${positionScaleName}')`}]):never(`Cannot use ${channel} scale if ${positionChannel} scale is not discrete.`)}function getDiscretePositionSize(channel,size,viewConfig){channel="x"===channel?"width":"height";return(size=size[channel])?size:getViewConfigDiscreteSize(viewConfig,channel)}
function defaultContinuousToDiscreteCount(scaleType,config,domain,channel){switch(scaleType){case "quantile":return config.scale.quantileCount;case "quantize":return config.scale.quantizeCount;case "threshold":if(void 0!==domain&&vega.isArray(domain))return domain.length+1;warn(`Domain for ${channel} is required for threshold scale.`);return 3}}function interpolateRange(rangeMin,rangeMax,cardinality){const f=()=>{const rMax=signalOrStringValue(rangeMax),rMin=signalOrStringValue(rangeMin),step=`(${rMax} - ${rMin}) / (${cardinality} - 1)`;
return`sequence(${rMin}, ${rMax} + ${step}, ${step})`};return isSignalRef(rangeMax)?new SignalRefWrapper(f):{signal:f()}}function sizeRangeMin(mark,zero,config){if(zero)return isSignalRef(zero)?{signal:`${zero.signal} ? 0 : ${sizeRangeMin(mark,!1,config)}`}:0;switch(mark){case "bar":case "tick":return config.scale.minBandSize;case "line":case "trail":case "rule":return config.scale.minStrokeWidth;case "text":return config.scale.minFontSize;case "point":case "square":case "circle":return config.scale.minSize}throw Error(incompatibleChannel("size",
mark));}function sizeRangeMax(mark,size,model,config){model={x:getBinStepSignal(model,"x"),y:getBinStepSignal(model,"y")};switch(mark){case "bar":case "tick":if(void 0!==config.scale.maxBandSize)return config.scale.maxBandSize;const min=minXYStep(size,model,config.view);return vega.isNumber(min)?min-1:new SignalRefWrapper(()=>`${min.signal} - 1`);case "line":case "trail":case "rule":return config.scale.maxStrokeWidth;case "text":return config.scale.maxFontSize;case "point":case "square":case "circle":if(config.scale.maxSize)return config.scale.maxSize;
const pointStep=minXYStep(size,model,config.view);return vega.isNumber(pointStep)?Math.pow(.95*pointStep,2):new SignalRefWrapper(()=>`pow(${.95} * ${pointStep.signal}, 2)`)}throw Error(incompatibleChannel("size",mark));}function minXYStep(size,xyStepSignals,viewConfig){const widthStep=isStep(size.width)?size.width.step:getViewConfigDiscreteStep(viewConfig,"width"),heightStep=isStep(size.height)?size.height.step:getViewConfigDiscreteStep(viewConfig,"height");return xyStepSignals.x||xyStepSignals.y?
new SignalRefWrapper(()=>`min(${[xyStepSignals.x?xyStepSignals.x.signal:widthStep,xyStepSignals.y?xyStepSignals.y.signal:heightStep].join(", ")})`):Math.min(widthStep,heightStep)}function parseScaleProperty(model,property){if(isUnitModel(model)){const localScaleComponents=model.component.scales,{config,encoding,markDef,specifiedScales}=model;for(const channel of keys$jscomp$0(localScaleComponents)){var specifiedScale=specifiedScales[channel];const localScaleCmpt=localScaleComponents[channel];var mergedScaleCmpt=
model.getScaleComponent(channel),fieldOrDatumDef=getFieldOrDatumDef(encoding[channel]),specifiedValue=specifiedScale[property];const scaleType=mergedScaleCmpt.get("type"),scalePadding=mergedScaleCmpt.get("padding");mergedScaleCmpt=mergedScaleCmpt.get("paddingInner");const supportedByScaleType=scaleTypeSupportProperty(scaleType,property),channelIncompatability=channelScalePropertyIncompatability(channel,property);void 0!==specifiedValue&&(supportedByScaleType?channelIncompatability&&warn(channelIncompatability):
warn(scalePropertyNotWorkWithScaleType(scaleType,property,channel)));if(supportedByScaleType&&void 0===channelIncompatability)if(void 0!==specifiedValue)switch(specifiedValue=fieldOrDatumDef.timeUnit,fieldOrDatumDef=fieldOrDatumDef.type,property){case "domainMax":case "domainMin":isDateTime(specifiedScale[property])||"temporal"===fieldOrDatumDef||specifiedValue?localScaleCmpt.set(property,{signal:valueExpr(specifiedScale[property],{type:fieldOrDatumDef,timeUnit:specifiedValue})},!0):localScaleCmpt.set(property,
specifiedScale[property],!0);break;default:localScaleCmpt.copyKeyFromObject(property,specifiedScale)}else specifiedScale=property in scaleRules?scaleRules[property]({model,channel,fieldOrDatumDef,scaleType,scalePadding,scalePaddingInner:mergedScaleCmpt,domain:specifiedScale.domain,domainMin:specifiedScale.domainMin,domainMax:specifiedScale.domainMax,markDef,config,hasNestedOffsetScale:channelHasNestedOffsetScale(encoding,channel),hasSecondaryRangeChannel:!!encoding[getSecondaryRangeChannel(channel)]}):
config.scale[property],void 0!==specifiedScale&&localScaleCmpt.set(property,specifiedScale,!1)}}else parseNonUnitScaleProperty(model,property)}function parseScaleRange(model){if(isUnitModel(model)){const localScaleComponents=model.component.scales;for(const channel of SCALE_CHANNELS){const localScaleCmpt=localScaleComponents[channel];if(!localScaleCmpt)continue;const rangeWithExplicit=parseRangeForChannel(channel,model);localScaleCmpt.setWithExplicit("range",rangeWithExplicit)}}else parseNonUnitScaleProperty(model,
"range")}function parseNonUnitScaleProperty(model,property){const localScaleComponents=model.component.scales;for(var child$jscomp$0 of model.children)"range"===property?parseScaleRange(child$jscomp$0):parseScaleProperty(child$jscomp$0,property);for(const channel of keys$jscomp$0(localScaleComponents)){let valueWithExplicit;for(const child of model.children)if(child$jscomp$0=child.component.scales[channel])child$jscomp$0=child$jscomp$0.getWithExplicit(property),valueWithExplicit=mergeValuesWithExplicit(valueWithExplicit,
child$jscomp$0,property,"scale",tieBreakByComparing((v1,v2)=>{switch(property){case "range":if(v1.step&&v2.step)return v1.step-v2.step}return 0}));localScaleComponents[channel].setWithExplicit(property,valueWithExplicit)}}function bins$jscomp$1(model,fieldDef){const bin=fieldDef.bin;if(isBinning(bin)){const binSignal=getBinSignalName(model,fieldDef.field,bin);return new SignalRefWrapper(()=>model.getSignalName(binSignal))}if(isBinned(bin)&&vega.isObject(bin)&&void 0!==bin.step)return{step:bin.step}}
function paddingInner(paddingValue,channel,mark,scaleType,scaleConfig){let hasNestedOffsetScale=5<arguments.length&&void 0!==arguments[5]?arguments[5]:!1;if(void 0===paddingValue){if(isXorY(channel)){const {bandPaddingInner,barBandPaddingInner,rectBandPaddingInner,bandWithNestedOffsetPaddingInner}=scaleConfig;return hasNestedOffsetScale?bandWithNestedOffsetPaddingInner:getFirstDefined(bandPaddingInner,"bar"===mark?barBandPaddingInner:rectBandPaddingInner)}if(channel in OFFSET_SCALE_CHANNEL_INDEX&&
scaleType===ScaleType.BAND)return scaleConfig.offsetBandPaddingInner}}function paddingOuter$jscomp$0(paddingValue,channel,scaleType,paddingInnerValue,scaleConfig){let hasNestedOffsetScale=5<arguments.length&&void 0!==arguments[5]?arguments[5]:!1;if(void 0===paddingValue)if(isXorY(channel)){const {bandPaddingOuter,bandWithNestedOffsetPaddingOuter}=scaleConfig;if(hasNestedOffsetScale)return bandWithNestedOffsetPaddingOuter;if(scaleType===ScaleType.BAND)return getFirstDefined(bandPaddingOuter,isSignalRef(paddingInnerValue)?
{signal:`${paddingInnerValue.signal}/2`}:paddingInnerValue/2)}else if(channel in OFFSET_SCALE_CHANNEL_INDEX){if(scaleType===ScaleType.POINT)return.5;if(scaleType===ScaleType.BAND)return scaleConfig.offsetBandPaddingOuter}}function scaleType$jscomp$2(specifiedScale,channel,fieldDef,mark){const defaultScaleType=defaultType(channel,fieldDef,mark,4<arguments.length&&void 0!==arguments[4]?arguments[4]:!1),{type}=specifiedScale;if(!SCALE_CHANNEL_INDEX[channel])return null;if(void 0!==type){if(!channelSupportScaleType(channel,
type))return warn(`Channel "${channel}" does not work with "${type}" scale. We are using "${defaultScaleType}" scale instead.`),defaultScaleType;var JSCompiler_temp;if(JSCompiler_temp=isFieldDef(fieldDef))JSCompiler_temp=fieldDef.type,JSCompiler_temp=!(contains(["ordinal","nominal"],JSCompiler_temp)?void 0===type||hasDiscreteDomain(type):"temporal"===JSCompiler_temp?contains([ScaleType.TIME,ScaleType.UTC,void 0],type):"quantitative"===JSCompiler_temp?QUANTITATIVE_SCALES.has(type)||CONTINUOUS_TO_DISCRETE_SCALES.has(type)||
void 0===type:1);return JSCompiler_temp?(warn(`FieldDef does not work with "${type}" scale. We are using "${defaultScaleType}" scale instead.`),defaultScaleType):type}return defaultScaleType}function defaultType(channel,fieldDef,mark,hasNestedOffsetScale){switch(fieldDef.type){case "nominal":case "ordinal":if(isColorChannel(channel)||"discrete"===rangeType(channel))return"shape"===channel&&"ordinal"===fieldDef.type&&warn(discreteChannelCannotEncode(channel,"ordinal")),"ordinal";if(isXorY(channel)||
channel in OFFSET_SCALE_CHANNEL_INDEX){if(contains(["rect","bar","image","rule"],mark.type)||hasNestedOffsetScale)return"band"}else if("arc"===mark.type&&channel in POLAR_POSITION_SCALE_CHANNEL_INDEX)return"band";channel=mark[getSizeChannel(channel)];return isRelativeBandSize(channel)||isPositionFieldOrDatumDef(fieldDef)&&fieldDef.axis?.tickBand?"band":"point";case "temporal":if(!isColorChannel(channel)){if("discrete"===rangeType(channel))return warn(discreteChannelCannotEncode(channel,"temporal")),
"ordinal";if(isFieldDef(fieldDef)&&fieldDef.timeUnit&&normalizeTimeUnit(fieldDef.timeUnit).utc)return"utc"}return"time";case "quantitative":if(isColorChannel(channel)){if(isFieldDef(fieldDef)&&isBinning(fieldDef.bin))return"bin-ordinal"}else if("discrete"===rangeType(channel))return warn(discreteChannelCannotEncode(channel,"quantitative")),"ordinal";return"linear";case "geojson":return}throw Error(`Invalid field type "${fieldDef.type}".`);}function parseScales(model){let {ignoreRange}=1<arguments.length&&
void 0!==arguments[1]?arguments[1]:{};parseScaleCore(model);isUnitModel(model)?parseUnitScaleDomain(model):parseNonUnitScaleDomain(model);for(const prop of NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTIES)parseScaleProperty(model,prop);ignoreRange||parseScaleRange(model)}function parseScaleCore(model){if(isUnitModel(model)){var JSCompiler_temp_const=model.component;const {encoding,mark,markDef}=model;var scaleComponents={};for(var channel of SCALE_CHANNELS){var fieldOrDatumDef=getFieldOrDatumDef(encoding[channel]);
if(!fieldOrDatumDef||mark!==GEOSHAPE||"shape"!==channel||"geojson"!==fieldOrDatumDef.type){var specifiedScale=fieldOrDatumDef&&fieldOrDatumDef.scale;if(channel in OFFSET_SCALE_CHANNEL_INDEX){var mainChannel=getMainChannelFromOffsetChannel(channel);if(!channelHasNestedOffsetScale(encoding,mainChannel)){specifiedScale&&warn(`${channel} encoding has no scale, so specified scale is ignored.`);continue}}fieldOrDatumDef&&null!==specifiedScale&&!1!==specifiedScale&&(specifiedScale??(specifiedScale={}),mainChannel=
channelHasNestedOffsetScale(encoding,channel),fieldOrDatumDef=scaleType$jscomp$2(specifiedScale,channel,fieldOrDatumDef,markDef,mainChannel),scaleComponents[channel]=new ScaleComponent(model.scaleName(`${channel}`,!0),{value:fieldOrDatumDef,explicit:specifiedScale.type===fieldOrDatumDef}))}}JSCompiler_temp_const.scales=scaleComponents}else{channel=model.component;specifiedScale=model.component.scales={};fieldOrDatumDef={};const resolve=model.component.resolve;for(mainChannel of model.children){parseScaleCore(mainChannel);
for(var channel$jscomp$0 of keys$jscomp$0(mainChannel.component.scales)){let $jscomp$inline_1935,$jscomp$inline_1936;($jscomp$inline_1935=resolve.scale)[$jscomp$inline_1936=channel$jscomp$0]??($jscomp$inline_1935[$jscomp$inline_1936]=defaultScaleResolve(channel$jscomp$0,model));if("shared"===resolve.scale[channel$jscomp$0]){const explicitScaleType=fieldOrDatumDef[channel$jscomp$0],childScaleType=mainChannel.component.scales[channel$jscomp$0].getWithExplicit("type");if(explicitScaleType){const scaleCategory1=
SCALE_CATEGORY_INDEX[explicitScaleType.value],scaleCategory2=SCALE_CATEGORY_INDEX[childScaleType.value];scaleCategory1===scaleCategory2||"ordinal-position"===scaleCategory1&&"time"===scaleCategory2||"ordinal-position"===scaleCategory2&&"time"===scaleCategory1?fieldOrDatumDef[channel$jscomp$0]=mergeValuesWithExplicit(explicitScaleType,childScaleType,"type","scale",scaleTypeTieBreaker):(resolve.scale[channel$jscomp$0]="independent",delete fieldOrDatumDef[channel$jscomp$0])}else fieldOrDatumDef[channel$jscomp$0]=
childScaleType}}}for(JSCompiler_temp_const of keys$jscomp$0(fieldOrDatumDef)){mainChannel=model.scaleName(JSCompiler_temp_const,!0);specifiedScale[JSCompiler_temp_const]=new ScaleComponent(mainChannel,fieldOrDatumDef[JSCompiler_temp_const]);for(scaleComponents of model.children)if(channel$jscomp$0=scaleComponents.component.scales[JSCompiler_temp_const])scaleComponents.renameScale(channel$jscomp$0.get("name"),mainChannel),channel$jscomp$0.merged=!0}channel.scales=specifiedScale}}function isUnitModel(model){return"unit"===
model?.type}function isFacetModel(model){return"facet"===model?.type}function isLayerModel(model){return"layer"===model?.type}function makeWalkTree(data){function walkTree(node,dataSource){node instanceof SourceNode&&!(node.isGenerator||"url"in node.data)&&(data.push(dataSource),dataSource={name:null,source:dataSource.name,transform:[]});node instanceof ParseNode&&(node.parent instanceof SourceNode&&!dataSource.source?(dataSource.format={...(dataSource.format??{}),parse:node.assembleFormatParse()},
dataSource.transform.push(...node.assembleTransforms(!0))):dataSource.transform.push(...node.assembleTransforms()));if(node instanceof FacetNode)dataSource.name||(dataSource.name=`data_${datasetIndex++}`),!dataSource.source||0<dataSource.transform.length?(data.push(dataSource),node.data=dataSource.name):node.data=dataSource.source,data.push(...node.assemble());else switch((node instanceof GraticuleNode||node instanceof SequenceNode||node instanceof FilterInvalidNode||node instanceof FilterNode||node instanceof
CalculateNode||node instanceof GeoPointNode||node instanceof AggregateNode||node instanceof LookupNode||node instanceof WindowTransformNode||node instanceof JoinAggregateTransformNode||node instanceof FoldTransformNode||node instanceof FlattenTransformNode||node instanceof DensityTransformNode||node instanceof LoessTransformNode||node instanceof QuantileTransformNode||node instanceof RegressionTransformNode||node instanceof IdentifierNode||node instanceof SampleTransformNode||node instanceof PivotTransformNode)&&
dataSource.transform.push(node.assemble()),(node instanceof BinNode||node instanceof TimeUnitNode||node instanceof ImputeNode||node instanceof StackNode||node instanceof GeoJSONNode)&&dataSource.transform.push(...node.assemble()),node instanceof OutputNode&&(dataSource.source&&0===dataSource.transform.length?node.setSource(dataSource.source):node.parent instanceof OutputNode?node.setSource(dataSource.name):(dataSource.name||(dataSource.name=`data_${datasetIndex++}`),node.setSource(dataSource.name),
1===node.numChildren()&&(data.push(dataSource),dataSource={name:null,source:dataSource.name,transform:[]}))),node.numChildren()){case 0:node instanceof OutputNode&&(!dataSource.source||0<dataSource.transform.length)&&data.push(dataSource);break;case 1:walkTree(node.children[0],dataSource);break;default:dataSource.name||(dataSource.name=`data_${datasetIndex++}`);let source=dataSource.name;!dataSource.source||0<dataSource.transform.length?data.push(dataSource):source=dataSource.source;for(const child of node.children)walkTree(child,
{name:null,source,transform:[]})}}let datasetIndex=0;return walkTree}function assembleFacetData(root){const data=[],walkTree=makeWalkTree(data);for(const child of root.children)walkTree(child,{source:root.name,name:null,transform:[]});return data}function assembleRootData(dataComponent,datasets){const data=[];var walkTree=makeWalkTree(data);let sourceIndex=0;for(const root of dataComponent.sources){root.hasName()||(root.dataName=`source_${sourceIndex++}`);const newData=root.assemble();walkTree(root,
newData)}for(const d of data)0===d.transform.length&&delete d.transform;walkTree=0;for(const [i,d]of data.entries())0!==(d.transform??[]).length||d.source||data.splice(walkTree++,0,data.splice(i,1)[0]);for(const d of data)for(const t of d.transform??[])"lookup"===t.type&&(t.from=dataComponent.outputNodes[t.from].getSource());for(const d of data)d.name in datasets&&(d.values=datasets[d.name]);return data}function makeHeaderComponent(model,channel,labels){channel="row"===channel?"height":"width";return{labels,
sizeSignal:model.child.component.layoutSize.get(channel)?model.child.getSizeSignalRef(channel):void 0,axes:[]}}function mergeChildAxis(model,channel){var {child}=model;if(child.component.axes[channel]){const {layoutHeaders,resolve}=model.component;resolve.axis[channel]=parseGuideResolve(resolve,channel);if("shared"===resolve.axis[channel]){const headerChannel="x"===channel?"column":"row",layoutHeader=layoutHeaders[headerChannel];for(const axisComponent of child.component.axes[channel]){channel=axisComponent.get("orient");
channel="top"===channel||"left"===channel||isSignalRef(channel)?"header":"footer";let $jscomp$logical$assign$tmp730812712$21,$jscomp$logical$assign$tmpindex730812712$21;($jscomp$logical$assign$tmp730812712$21=layoutHeader)[$jscomp$logical$assign$tmpindex730812712$21=channel]??($jscomp$logical$assign$tmp730812712$21[$jscomp$logical$assign$tmpindex730812712$21]=[makeHeaderComponent(model,headerChannel,!1)]);(child=assembleAxis(axisComponent,"main",model.config,{header:!0}))&&layoutHeader[channel][0].axes.push(child);
axisComponent.mainExtracted=!0}}}}function parseChildrenLayoutSize(model){for(const child of model.children)child.parseLayoutSize()}function parseNonUnitLayoutSizeForChannel(model,layoutSizeType){const sizeType=getSizeTypeFromLayoutSizeType(layoutSizeType),channel=getPositionScaleChannel(sizeType),resolve=model.component.resolve,layoutSizeCmpt=model.component.layoutSize;let mergedSize;for(const child of model.children){const childSize=child.component.layoutSize.getWithExplicit(sizeType),scaleResolve=
resolve.scale[channel]??defaultScaleResolve(channel,model);if("independent"===scaleResolve&&"step"===childSize.value){mergedSize=void 0;break}if(mergedSize){if("independent"===scaleResolve&&mergedSize.value!==childSize.value){mergedSize=void 0;break}mergedSize=mergeValuesWithExplicit(mergedSize,childSize,sizeType,"")}else mergedSize=childSize}if(mergedSize){for(const child of model.children)model.renameSignal(child.getName(sizeType),model.getName(layoutSizeType)),child.component.layoutSize.set(sizeType,
"merged",!1);layoutSizeCmpt.setWithExplicit(layoutSizeType,mergedSize)}else layoutSizeCmpt.setWithExplicit(layoutSizeType,{explicit:!1,value:void 0})}function defaultUnitSize(model,sizeType){const config=model.config;var scaleComponent=model.getScaleComponent("width"===sizeType?"x":"y");if(scaleComponent)return model=scaleComponent.get("type"),scaleComponent=scaleComponent.get("range"),hasDiscreteDomain(model)?(sizeType=getViewConfigDiscreteSize(config.view,sizeType),isVgRangeStep(scaleComponent)||
isStep(sizeType)?"step":sizeType):getViewConfigContinuousSize(config.view,sizeType);if(model.hasProjection||"arc"===model.mark)return getViewConfigContinuousSize(config.view,sizeType);sizeType=getViewConfigDiscreteSize(config.view,sizeType);return isStep(sizeType)?sizeType.step:sizeType}function facetSortFieldName(fieldDef,sort,opt){return vgField(sort,{suffix:`by_${vgField(fieldDef)}`,...(opt??{})})}function findSource(data,sources){for(const other of sources){sources=other.data;if(data.name&&other.hasName()&&
data.name!==other.dataName)continue;const formatMesh=data.format?.mesh;var otherFeature=sources.format?.feature;if(formatMesh&&otherFeature)continue;const formatFeature=data.format?.feature;if(!formatFeature&&!otherFeature||formatFeature===otherFeature)if(otherFeature=sources.format?.mesh,!formatMesh&&!otherFeature||formatMesh===otherFeature)if("values"in data&&"values"in sources){if(deepEqual(data.values,sources.values))return other}else if("url"in data&&"url"in sources){if(data.url===sources.url)return other}else if(isNamedData(data)&&
data.name===other.dataName)return other}return null}function parseRoot(model,sources){if(model.data||!model.parent){if(null===model.data)return model=new SourceNode({values:[]}),sources.push(model),model;const existingSource=findSource(model.data,sources);if(existingSource)return isGenerator(model.data)||(existingSource.data.format=mergeDeep({},model.data.format,existingSource.data.format)),!existingSource.hasName()&&model.data.name&&(existingSource.dataName=model.data.name),existingSource;model=
new SourceNode(model.data);sources.push(model);return model}return model.parent.component.data.facetRoot?model.parent.component.data.facetRoot:model.parent.component.data.main}function parseData(model){var head=parseRoot(model,model.component.data.sources);const {outputNodes,outputNodeRefCounts}=model.component.data;var data=model.data;const ancestorParse=data&&(isGenerator(data)||"url"in data||"values"in data)||!model.parent?new AncestorParse:model.parent.component.data.ancestorParse.clone();isGenerator(data)?
("sequence"in data?head=new SequenceNode(head,data.sequence):"graticule"in data&&(head=new GraticuleNode(head,data.graticule)),ancestorParse.parseNothing=!0):null===data?.format?.parse&&(ancestorParse.parseNothing=!0);head=ParseNode.makeExplicit(head,model,ancestorParse)??head;head=new IdentifierNode(head);data=model.parent&&isLayerModel(model.parent);(isUnitModel(model)||isFacetModel(model))&&data&&(head=BinNode.makeFromEncoding(head,model)??head);if(0<model.transforms.length){let lookupCounter=
0;for(var t of model.transforms){let derivedType=void 0;var transformNode=void 0;if("calculate"in t)transformNode=head=new CalculateNode(head,t),derivedType="derived";else if("filter"in t)transformNode=getImplicitFromFilterTransform(t),transformNode=head=ParseNode.makeWithAncestors(head,{},transformNode,ancestorParse)??head,head=new FilterNode(head,model,t.filter);else if("bin"in t)transformNode=head=BinNode.makeFromTransform(head,t,model),derivedType="number";else if("timeUnit"in t)derivedType="date",
void 0===ancestorParse.getWithExplicit(t.field).value&&(head=new ParseNode(head,{[t.field]:derivedType}),ancestorParse.set(t.field,derivedType,!1)),transformNode=head=TimeUnitNode.makeFromTransform(head,t);else if("aggregate"in t)transformNode=head=AggregateNode.makeFromTransform(head,t),derivedType="number",requiresSelectionId(model)&&(head=new IdentifierNode(head));else if("lookup"in t)transformNode=head=LookupNode.make(head,model,t,lookupCounter++),derivedType="derived";else if("window"in t)transformNode=
head=new WindowTransformNode(head,t),derivedType="number";else if("joinaggregate"in t)transformNode=head=new JoinAggregateTransformNode(head,t),derivedType="number";else if("stack"in t)transformNode=head=StackNode.makeFromTransform(head,t),derivedType="derived";else if("fold"in t)transformNode=head=new FoldTransformNode(head,t),derivedType="derived";else if("flatten"in t)transformNode=head=new FlattenTransformNode(head,t),derivedType="derived";else if("pivot"in t)transformNode=head=new PivotTransformNode(head,
t),derivedType="derived";else if("sample"in t)head=new SampleTransformNode(head,t);else if("impute"in t)transformNode=head=ImputeNode.makeFromTransform(head,t),derivedType="derived";else if("density"in t)transformNode=head=new DensityTransformNode(head,t),derivedType="derived";else if("quantile"in t)transformNode=head=new QuantileTransformNode(head,t),derivedType="derived";else if("regression"in t)transformNode=head=new RegressionTransformNode(head,t),derivedType="derived";else if("loess"in t)transformNode=
head=new LoessTransformNode(head,t),derivedType="derived";else{warn(`Ignoring an invalid transform: ${stringify(t)}.`);continue}if(transformNode&&void 0!==derivedType)for(var field$jscomp$0 of transformNode.producedFields()??[])ancestorParse.set(field$jscomp$0,derivedType,!1)}}t={};if(isUnitModel(model)&&model.component.selection)for(var name of keys$jscomp$0(model.component.selection)){field$jscomp$0=model.component.selection[name];for(var proj of field$jscomp$0.project.items)!proj.channel&&1<accessPathDepth(proj.field)&&
(t[proj.field]="flatten")}name=getImplicitFromEncoding(model);head=ParseNode.makeWithAncestors(head,{},{...t,...name},ancestorParse)??head;isUnitModel(model)&&(head=GeoJSONNode.parseAll(head,model),head=GeoPointNode.parseAll(head,model));if(isUnitModel(model)||isFacetModel(model))data||(head=BinNode.makeFromEncoding(head,model)??head),head=TimeUnitNode.makeFromEncoding(head,model)??head,head=CalculateNode.parseAllForSortIndex(head,model);name=model.getDataName(DataSourceType.Raw);data=new OutputNode(head,
name,DataSourceType.Raw,outputNodeRefCounts);head=outputNodes[name]=data;if(isUnitModel(model)){if(name=AggregateNode.makeFromEncoding(head,model))head=name,requiresSelectionId(model)&&(head=new IdentifierNode(head));head=ImputeNode.makeFromEncoding(head,model)??head;head=StackNode.makeFromEncoding(head,model)??head}isUnitModel(model)&&(head=FilterInvalidNode.make(head,model)??head);proj=model.getDataName(DataSourceType.Main);name=new OutputNode(head,proj,DataSourceType.Main,outputNodeRefCounts);
head=outputNodes[proj]=name;if(isUnitModel(model))for(const [selection,selCmpt]of entries$1(model.component.selection??{}))proj=model.getName(`lookup_${selection}`),model.component.data.outputNodes[proj]=selCmpt.materialized=new OutputNode(new FilterNode(name,model,{param:selection}),proj,DataSourceType.Lookup,model.component.data.outputNodeRefCounts);t=null;if(isFacetModel(model)){proj=model.getName("facet");{t=head;const {row,column}=model.facet;if(row&&column){field$jscomp$0=null;for(JSCompiler_inline_result of[row,
column])if(isSortField(JSCompiler_inline_result.sort)){const {field,op="min"}=JSCompiler_inline_result.sort;t=field$jscomp$0=new JoinAggregateTransformNode(t,{joinaggregate:[{op,field,as:facetSortFieldName(JSCompiler_inline_result,JSCompiler_inline_result.sort,{forAs:!0})}],groupby:[vgField(JSCompiler_inline_result)]})}var JSCompiler_inline_result=field$jscomp$0}else JSCompiler_inline_result=null}t=new FacetNode(JSCompiler_inline_result??head,model,proj,name.getSource());outputNodes[proj]=t}return{...model.component.data,
outputNodes,outputNodeRefCounts,raw:data,main:name,facetRoot:t,ancestorParse}}function labels$jscomp$0(model,channel,specifiedLabelsSpec){const {encoding,config}=model,fieldOrDatumDef=getFieldOrDatumDef(encoding[channel])??getFieldOrDatumDef(encoding[getSecondaryRangeChannel(channel)]);model=model.axis(channel)||{};const {format,formatType}=model;if(isCustomFormatType(formatType))return{text:formatCustomType({fieldOrDatumDef,field:"datum.value",format,formatType,config}),...specifiedLabelsSpec};if(void 0===
format&&void 0===formatType&&config.customFormatTypes){if("quantitative"===fieldOrDatumDef?.type){if(isPositionFieldOrDatumDef(fieldOrDatumDef)&&"normalize"===fieldOrDatumDef.stack&&config.normalizedNumberFormatType)return{text:formatCustomType({fieldOrDatumDef,field:"datum.value",format:config.normalizedNumberFormat,formatType:config.normalizedNumberFormatType,config}),...specifiedLabelsSpec};if(config.numberFormatType)return{text:formatCustomType({fieldOrDatumDef,field:"datum.value",format:config.numberFormat,
formatType:config.numberFormatType,config}),...specifiedLabelsSpec}}if("temporal"===fieldOrDatumDef?.type&&config.timeFormatType&&isFieldDef(fieldOrDatumDef)&&!fieldOrDatumDef.timeUnit)return{text:formatCustomType({fieldOrDatumDef,field:"datum.value",format:config.timeFormat,formatType:config.timeFormatType,config}),...specifiedLabelsSpec}}return specifiedLabelsSpec}function parseUnitAxes(model){return POSITION_SCALE_CHANNELS.reduce((axis,channel)=>{model.component.scales[channel]&&(axis[channel]=
[parseAxis(channel,model)]);return axis},{})}function mergeAxisComponents(mergedAxisCmpts,childAxisCmpts){if(mergedAxisCmpts){if(mergedAxisCmpts.length!==childAxisCmpts.length)return;const length=mergedAxisCmpts.length;for(let i=0;i<length;i++){const merged=mergedAxisCmpts[i],child=childAxisCmpts[i];if(!!merged!==!!child)return;if(merged&&child){const mergedOrient=merged.getWithExplicit("orient"),childOrient=child.getWithExplicit("orient");if(mergedOrient.explicit&&childOrient.explicit&&mergedOrient.value!==
childOrient.value)return;mergedAxisCmpts[i]=mergeAxisComponent(merged,child)}}}else return childAxisCmpts.map(axisComponent=>axisComponent.clone());return mergedAxisCmpts}function mergeAxisComponent(merged,child){for(const prop of AXIS_COMPONENT_PROPERTIES){const mergedValueWithExplicit=mergeValuesWithExplicit(merged.getWithExplicit(prop),child.getWithExplicit(prop),prop,"axis",(v1,v2)=>{switch(prop){case "title":return mergeTitleComponent(v1,v2);case "gridScale":return{explicit:v1.explicit,value:getFirstDefined(v1.value,
v2.value)}}return defaultTieBreaker(v1,v2,prop,"axis")});merged.setWithExplicit(prop,mergedValueWithExplicit)}return merged}function isExplicit(value,property,axis,model,channel){if("disable"===property)return void 0!==axis;axis=axis||{};switch(property){case "titleAngle":case "labelAngle":return value===(isSignalRef(axis.labelAngle)?axis.labelAngle:normalizeAngle(axis.labelAngle));case "values":return!!axis.values;case "encode":return!!axis.encoding||!!axis.labelAngle;case "title":if(value===getFieldDefTitle(model,
channel))return!0}return value===axis[property]}function parseAxis(channel,model){let axis=model.axis(channel);const axisComponent=new AxisComponent;var fieldOrDatumDef=getFieldOrDatumDef(model.encoding[channel]);const {mark,config}=model;var orient=axis?.orient||config["x"===channel?"axisX":"axisY"]?.orient||config.axis?.orient||("x"===channel?"bottom":"left"),scaleType=model.getScaleComponent(channel).get("type"),axisConfigs=getAxisConfigs(channel,scaleType,orient,model.config),disable=void 0!==
axis?!axis:getAxisConfig("disable",config.style,axis?.style,axisConfigs).configValue;axisComponent.set("disable",disable,void 0!==axis);if(disable)return axisComponent;axis=axis||{};disable=getLabelAngle(fieldOrDatumDef,axis,channel,config.style,axisConfigs);fieldOrDatumDef={fieldOrDatumDef,axis,channel,model,scaleType,orient,labelAngle:disable,mark,config};for(const property of AXIS_COMPONENT_PROPERTIES)if(orient=property in axisRules?axisRules[property](fieldOrDatumDef):AXIS_PROPERTIES_INDEX[property]?
axis[property]:void 0,scaleType=void 0!==orient,disable=isExplicit(orient,property,axis,model,channel),scaleType&&disable)axisComponent.set(property,orient,disable);else{const {configValue,configFrom}=AXIS_PROPERTIES_INDEX[property]&&"values"!==property?getAxisConfig(property,config.style,axis.style,axisConfigs):{},hasConfigValue=void 0!==configValue;scaleType&&!hasConfigValue?axisComponent.set(property,orient,disable):("vgAxisConfig"!==configFrom||propsToAlwaysIncludeConfig.has(property)&&hasConfigValue||
configValue?.condition||isSignalRef(configValue))&&axisComponent.set(property,configValue,!1)}const axisEncoding=axis.encoding??{};axisConfigs=AXIS_PARTS.reduce((e,part)=>{if(!axisComponent.hasAxisPart(part))return e;var axisEncodingPart=guideEncodeEntry(axisEncoding[part]??{},model);axisEncodingPart="labels"===part?labels$jscomp$0(model,channel,axisEncodingPart):axisEncodingPart;void 0===axisEncodingPart||isEmpty(axisEncodingPart)||(e[part]={update:axisEncodingPart});return e},{});isEmpty(axisConfigs)||
axisComponent.set("encode",axisConfigs,!!axis.encoding||void 0!==axis.labelAngle);return axisComponent}function initLayoutSize(_ref){let {encoding,size}=_ref;for(const channel of POSITION_SCALE_CHANNELS)_ref=getSizeChannel(channel),isStep(size[_ref])&&isContinuousFieldOrDatumDef(encoding[channel])&&(delete size[_ref],warn(stepDropped(_ref)));return size}function initMarkdef(originalMarkDef,encoding,config){originalMarkDef=replaceExprRef(originalMarkDef);var specifiedOrient=getMarkPropOrConfig("orient",
originalMarkDef,config);originalMarkDef.orient=orient$jscomp$1(originalMarkDef.type,encoding,specifiedOrient);void 0!==specifiedOrient&&specifiedOrient!==originalMarkDef.orient&&warn(`Specified orient "${originalMarkDef.orient}" overridden with "${specifiedOrient}".`);if("bar"===originalMarkDef.type&&originalMarkDef.orient&&(specifiedOrient=getMarkPropOrConfig("cornerRadiusEnd",originalMarkDef,config),void 0!==specifiedOrient)){const newProps="horizontal"===originalMarkDef.orient&&encoding.x2||"vertical"===
originalMarkDef.orient&&encoding.y2?["cornerRadius"]:BAR_CORNER_RADIUS_INDEX[originalMarkDef.orient];for(var newProp of newProps)originalMarkDef[newProp]=specifiedOrient;void 0!==originalMarkDef.cornerRadiusEnd&&delete originalMarkDef.cornerRadiusEnd}void 0===getMarkPropOrConfig("opacity",originalMarkDef,config)&&(newProp=contains([POINT,TICK,CIRCLE,SQUARE],originalMarkDef.type)&&!isAggregate$1(encoding)?.7:void 0,originalMarkDef.opacity=newProp);void 0===getMarkPropOrConfig("cursor",originalMarkDef,
config)&&(encoding=encoding.href||originalMarkDef.href||getMarkPropOrConfig("href",originalMarkDef,config)?"pointer":originalMarkDef.cursor,originalMarkDef.cursor=encoding);return originalMarkDef}function defaultFilled(markDef,config,_ref){({graticule:_ref}=_ref);if(_ref)return!1;config=getMarkConfig("filled",markDef,config);markDef=markDef.type;return getFirstDefined(config,markDef!==POINT&&markDef!==LINE&&markDef!==RULE)}function orient$jscomp$1(mark,encoding,specifiedOrient){switch(mark){case POINT:case CIRCLE:case SQUARE:case TEXT:case RECT:case IMAGE:return}const {x,
y,x2,y2}=encoding;switch(mark){case BAR:if(isFieldDef(x)&&(isBinned(x.bin)||isFieldDef(y)&&y.aggregate&&!x.aggregate))break;if(isFieldDef(y)&&(isBinned(y.bin)||isFieldDef(x)&&x.aggregate&&!y.aggregate))return"horizontal";if(y2||x2){if(specifiedOrient)return specifiedOrient;if(!x2){if((isFieldDef(x)&&"quantitative"===x.type&&!isBinning(x.bin)||isNumericDataDef(x))&&isFieldDef(y)&&isBinned(y.bin))return"horizontal";break}if(!y2){if((isFieldDef(y)&&"quantitative"===y.type&&!isBinning(y.bin)||isNumericDataDef(y))&&
isFieldDef(x)&&isBinned(x.bin))break;return"horizontal"}}case RULE:if(!(!x2||isFieldDef(x)&&isBinned(x.bin)||!y2||isFieldDef(y)&&isBinned(y.bin)))return;case AREA:if(y2){if(isFieldDef(y)&&isBinned(y.bin))return"horizontal";break}else if(x2)if(isFieldDef(x)&&isBinned(x.bin))break;else return"horizontal";else if(mark===RULE)if(x&&!y)break;else if(y&&!x)return"horizontal";case LINE:case TICK:encoding=isContinuousFieldOrDatumDef(x);const yIsContinuous=isContinuousFieldOrDatumDef(y);if(specifiedOrient)return specifiedOrient;
if(encoding&&!yIsContinuous)return"tick"!==mark?"horizontal":"vertical";if(!encoding&&yIsContinuous)return"tick"!==mark?"vertical":"horizontal";if(encoding&&yIsContinuous){specifiedOrient="temporal"===x.type;encoding="temporal"===y.type;if(specifiedOrient&&!encoding)return"tick"!==mark?"vertical":"horizontal";if(!specifiedOrient&&encoding)return"tick"!==mark?"horizontal":"vertical";if(!x.aggregate&&y.aggregate)return"tick"!==mark?"vertical":"horizontal";if(x.aggregate&&!y.aggregate)return"tick"!==
mark?"horizontal":"vertical"}else return}return"vertical"}function encodeEntry(model,fixedShape){var JSCompiler_temp_const={...baseEncodeEntry(model,{align:"ignore",baseline:"ignore",color:"include",size:"include",orient:"ignore",theta:"ignore"})},JSCompiler_temp_const$jscomp$0={...pointPosition("x",model,{defaultPos:"mid"})},JSCompiler_temp_const$jscomp$1={...pointPosition("y",model,{defaultPos:"mid"})},JSCompiler_temp_const$jscomp$2={...nonPosition("size",model)},JSCompiler_temp_const$jscomp$3=
{...nonPosition("angle",model)};model=fixedShape?{shape:{value:fixedShape}}:nonPosition("shape",model);return{...JSCompiler_temp_const,...JSCompiler_temp_const$jscomp$0,...JSCompiler_temp_const$jscomp$1,...JSCompiler_temp_const$jscomp$2,...JSCompiler_temp_const$jscomp$3,...model}}function parseMarkGroups(model){if(contains([LINE,AREA,TRAIL],model.mark)){var details=pathGroupingFields(model.mark,model.encoding);if(0<details.length)return getPathGroups(model,details)}else if(model.mark===BAR&&(details=
VG_CORNERRADIUS_CHANNELS.some(prop=>getMarkPropOrConfig(prop,model.markDef,model.config)),model.stack&&!model.fieldDef("size")&&details))return getGroupsForStackedBarWithCornerRadius(model);return getMarkGroup(model)}function getPathGroups(model,details){return[{name:model.getName("pathgroup"),type:"group",from:{facet:{name:"faceted_path_"+model.requestDataName(DataSourceType.Main),data:model.requestDataName(DataSourceType.Main),groupby:details}},encode:{update:{width:{field:{group:"width"}},height:{field:{group:"height"}}}},
marks:getMarkGroup(model,{fromPrefix:"faceted_path_"})}]}function getGroupsForStackedBarWithCornerRadius(model){const [mark]=getMarkGroup(model,{fromPrefix:"stack_group_"}),fieldScale=model.scaleName(model.stack.fieldChannel),stackField=function(){return model.vgField(model.stack.fieldChannel,0<arguments.length&&void 0!==arguments[0]?arguments[0]:{})};var stackFieldGroup=(func,expr)=>{expr=[stackField({prefix:"min",suffix:"start",expr}),stackField({prefix:"max",suffix:"start",expr}),stackField({prefix:"min",
suffix:"end",expr}),stackField({prefix:"max",suffix:"end",expr})];return`${func}(${expr.map(field=>`scale('${fieldScale}',${field})`).join(",")})`};let innerGroupUpdate;"x"===model.stack.fieldChannel?(stackFieldGroup={...pick(mark.encode.update,["y","yc","y2","height",...VG_CORNERRADIUS_CHANNELS]),x:{signal:stackFieldGroup("min","datum")},x2:{signal:stackFieldGroup("max","datum")},clip:{value:!0}},innerGroupUpdate={x:{field:{group:"x"},mult:-1},height:{field:{group:"height"}}},mark.encode.update=
{...omit(mark.encode.update,["y","yc","y2"]),height:{field:{group:"height"}}}):(stackFieldGroup={...pick(mark.encode.update,["x","xc","x2","width"]),y:{signal:stackFieldGroup("min","datum")},y2:{signal:stackFieldGroup("max","datum")},clip:{value:!0}},innerGroupUpdate={y:{field:{group:"y"},mult:-1},width:{field:{group:"width"}}},mark.encode.update={...omit(mark.encode.update,["x","xc","x2"]),width:{field:{group:"width"}}});for(var key of VG_CORNERRADIUS_CHANNELS){var configValue$jscomp$0=getMarkConfig(key,
model.markDef,model.config);mark.encode.update[key]?(stackFieldGroup[key]=mark.encode.update[key],delete mark.encode.update[key]):configValue$jscomp$0&&(stackFieldGroup[key]=signalOrValueRef(configValue$jscomp$0));configValue$jscomp$0&&(mark.encode.update[key]={value:0})}key=[];if(0<model.stack.groupbyChannels?.length)for(const groupbyChannel of model.stack.groupbyChannels){configValue$jscomp$0=model.fieldDef(groupbyChannel);const field=vgField(configValue$jscomp$0);field&&key.push(field);(configValue$jscomp$0?.bin||
configValue$jscomp$0?.timeUnit)&&key.push(vgField(configValue$jscomp$0,{binSuffix:"end"}))}stackFieldGroup="stroke strokeWidth strokeJoin strokeCap strokeDash strokeDashOffset strokeMiterLimit strokeOpacity".split(" ").reduce((encode,prop)=>{if(mark.encode.update[prop])return{...encode,[prop]:mark.encode.update[prop]};const configValue=getMarkConfig(prop,model.markDef,model.config);return void 0!==configValue?{...encode,[prop]:signalOrValueRef(configValue)}:encode},stackFieldGroup);stackFieldGroup.stroke&&
(stackFieldGroup.strokeForeground={value:!0},stackFieldGroup.strokeOffset={value:0});return[{type:"group",from:{facet:{data:model.requestDataName(DataSourceType.Main),name:"stack_group_"+model.requestDataName(DataSourceType.Main),groupby:key,aggregate:{fields:[stackField({suffix:"start"}),stackField({suffix:"start"}),stackField({suffix:"end"}),stackField({suffix:"end"})],ops:["min","max","min","max"]}}},encode:{update:stackFieldGroup},marks:[{type:"group",encode:{update:innerGroupUpdate},marks:[mark]}]}]}
function getSort(model){const {encoding,stack,mark,markDef,config}=model;var order=encoding.order;if(!(!vega.isArray(order)&&isValueDef(order)&&isNullOrFalse(order.value)||!order&&isNullOrFalse(getMarkPropOrConfig("order",markDef,config)))){if((vega.isArray(order)||isFieldDef(order))&&!stack)return sortParams(order,{expr:"datum"});if(isPathMark(mark)){const dimensionChannel="horizontal"===markDef.orient?"y":"x",dimensionChannelDef=encoding[dimensionChannel];if(isFieldDef(dimensionChannelDef)){order=
dimensionChannelDef.sort;if(vega.isArray(order))return{field:vgField(dimensionChannelDef,{prefix:dimensionChannel,suffix:"sort_index",expr:"datum"})};if(isSortField(order))return{field:vgField({aggregate:isAggregate$1(model.encoding)?order.op:void 0,field:order.field},{expr:"datum"})};if(order?.encoding)return model=model.fieldDef(order.encoding),{field:vgField(model,{expr:"datum"}),order:order.order};if(null!==order)return{field:vgField(dimensionChannelDef,{binSuffix:model.stack?.impute?"mid":void 0,
expr:"datum"})}}}}}function getMarkGroup(model){let opt=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{fromPrefix:""};const {mark,markDef,encoding,config}=model;var JSCompiler_temp_const=markDef.clip;var JSCompiler_inline_result=model.getScaleComponent("x");var yScale=model.getScaleComponent("y");JSCompiler_inline_result=JSCompiler_inline_result?.get("selectionExtent")||yScale?.get("selectionExtent")?!0:void 0;yScale=model.component.projection;JSCompiler_temp_const=getFirstDefined(JSCompiler_temp_const,
JSCompiler_inline_result,yScale&&!yScale.isFit?!0:void 0);JSCompiler_inline_result=[].concat(markDef.type,markDef.style??[]);yScale=encoding.key;const sort=getSort(model);var JSCompiler_inline_result$jscomp$0;if(model.component.selection){for(var parentCount=JSCompiler_inline_result$jscomp$0=keys$jscomp$0(model.component.selection).length,parent=model.parent;parent&&0===parentCount;)parentCount=keys$jscomp$0(parent.component.selection).length,parent=parent.parent;JSCompiler_inline_result$jscomp$0=
parentCount?{interactive:0<JSCompiler_inline_result$jscomp$0||!!model.encoding.tooltip}:null}else JSCompiler_inline_result$jscomp$0=null;parentCount=getMarkPropOrConfig("aria",markDef,config);parent=markCompiler[mark].postEncodingTransform?markCompiler[mark].postEncodingTransform(model):null;return[{name:model.getName("marks"),type:markCompiler[mark].vgMark,...(JSCompiler_temp_const?{clip:!0}:{}),...(JSCompiler_inline_result?{style:JSCompiler_inline_result}:{}),...(yScale?{key:yScale.field}:{}),...(sort?
{sort}:{}),...(JSCompiler_inline_result$jscomp$0?JSCompiler_inline_result$jscomp$0:{}),...(!1===parentCount?{aria:parentCount}:{}),from:{data:opt.fromPrefix+model.requestDataName(DataSourceType.Main)},encode:{update:markCompiler[mark].encodeEntry(model)},...(parent?{transform:parent}:{})}]}function buildModel(spec,parent,parentGivenName,unitSize,config){if("facet"in spec)return new FacetModel(spec,parent,parentGivenName,config);if("layer"in spec)return new LayerModel(spec,parent,parentGivenName,unitSize,
config);if(isUnitSpec(spec))return new UnitModel(spec,parent,parentGivenName,unitSize,config);if("vconcat"in spec||"hconcat"in spec||"concat"in spec)return new ConcatModel(spec,parent,parentGivenName,config);throw Error(invalidSpec(spec));}function assembleTopLevelModel(model,topLevelProperties){var datasets=2<arguments.length&&void 0!==arguments[2]?arguments[2]:{};let usermeta=3<arguments.length?arguments[3]:void 0;const vgConfig=model.config?stripAndRedirectConfig(model.config):void 0;datasets=
[].concat(model.assembleSelectionData([]),assembleRootData(model.component.data,datasets));const projections=model.assembleProjections(),title=model.assembleTitle(),style=model.assembleGroupStyle(),encodeEntry=model.assembleGroupEncodeEntry(!0);let layoutSignals=model.assembleLayoutSignals();layoutSignals=layoutSignals.filter(signal=>"width"!==signal.name&&"height"!==signal.name||void 0===signal.value?!0:(topLevelProperties[signal.name]=+signal.value,!1));const {params,...otherTopLevelProps}=topLevelProperties;
return{$schema:"https://vega.github.io/schema/vega/v5.json",...(model.description?{description:model.description}:{}),...otherTopLevelProps,...(title?{title}:{}),...(style?{style}:{}),...(encodeEntry?{encode:{update:encodeEntry}}:{}),data:datasets,...(0<projections.length?{projections}:{}),...model.assembleGroup([...layoutSignals,...model.assembleSelectionTopLevelSignals([]),...assembleParameterSignals(params)]),...(vgConfig?{config:vgConfig}:{}),...(usermeta?{usermeta}:{})}}var cloneExports={};(function(module){var clone$jscomp$0=
function(){function _instanceof(obj,type){return null!=type&&obj instanceof type}function clone(parent$jscomp$0,circular,depth$jscomp$0,prototype,includeNonEnumerable){function _clone(parent,depth){if(null===parent)return null;if(0===depth||"object"!=typeof parent)return parent;if(_instanceof(parent,nativeMap))var child=new nativeMap;else if(_instanceof(parent,nativeSet))child=new nativeSet;else if(_instanceof(parent,nativePromise))child=new nativePromise(function(resolve,reject){parent.then(function(value){resolve(_clone(value,
depth-1))},function(err){reject(_clone(err,depth-1))})});else if(clone.__isArray(parent))child=[];else if(clone.__isRegExp(parent))child=new RegExp(parent.source,__getRegExpFlags(parent)),parent.lastIndex&&(child.lastIndex=parent.lastIndex);else if(clone.__isDate(parent))child=new Date(parent.getTime());else{if(useBuffer&&Buffer.isBuffer(parent))return child=Buffer.allocUnsafe?Buffer.allocUnsafe(parent.length):new Buffer(parent.length),parent.copy(child),child;if(_instanceof(parent,Error))child=Object.create(parent);
else if("undefined"==typeof prototype){var proto=Object.getPrototypeOf(parent);child=Object.create(proto)}else child=Object.create(prototype),proto=prototype}if(circular){var index=allParents.indexOf(parent);if(-1!=index)return allChildren[index];allParents.push(parent);allChildren.push(child)}_instanceof(parent,nativeMap)&&parent.forEach(function(value,key){key=_clone(key,depth-1);value=_clone(value,depth-1);child.set(key,value)});_instanceof(parent,nativeSet)&&parent.forEach(function(value){value=
_clone(value,depth-1);child.add(value)});for(var i in parent){var attrs;proto&&(attrs=Object.getOwnPropertyDescriptor(proto,i));attrs&&null==attrs.set||(child[i]=_clone(parent[i],depth-1))}if(Object.getOwnPropertySymbols)for(index=Object.getOwnPropertySymbols(parent),i=0;i<index.length;i++)if(attrs=index[i],proto=Object.getOwnPropertyDescriptor(parent,attrs),!proto||proto.enumerable||includeNonEnumerable)child[attrs]=_clone(parent[attrs],depth-1),proto.enumerable||Object.defineProperty(child,attrs,
{enumerable:!1});if(includeNonEnumerable)for(index=Object.getOwnPropertyNames(parent),i=0;i<index.length;i++)attrs=index[i],proto=Object.getOwnPropertyDescriptor(parent,attrs),proto&&proto.enumerable||(child[attrs]=_clone(parent[attrs],depth-1),Object.defineProperty(child,attrs,{enumerable:!1}));return child}"object"===typeof circular&&(depth$jscomp$0=circular.depth,prototype=circular.prototype,includeNonEnumerable=circular.includeNonEnumerable,circular=circular.circular);var allParents=[],allChildren=
[],useBuffer="undefined"!=typeof Buffer;"undefined"==typeof circular&&(circular=!0);"undefined"==typeof depth$jscomp$0&&(depth$jscomp$0=Infinity);return _clone(parent$jscomp$0,depth$jscomp$0)}function __objToStr(o){return Object.prototype.toString.call(o)}function __getRegExpFlags(re){var flags="";re.global&&(flags+="g");re.ignoreCase&&(flags+="i");re.multiline&&(flags+="m");return flags}try{var nativeMap=Map}catch(_){nativeMap=function(){}}try{var nativeSet=Set}catch(_){nativeSet=function(){}}try{var nativePromise=
Promise}catch(_){nativePromise=function(){}}clone.clonePrototype=function(parent){if(null===parent)return null;var c=function(){};c.prototype=parent;return new c};clone.__objToStr=__objToStr;clone.__isDate=function(o){return"object"===typeof o&&"[object Date]"===__objToStr(o)};clone.__isArray=function(o){return"object"===typeof o&&"[object Array]"===__objToStr(o)};clone.__isRegExp=function(o){return"object"===typeof o&&"[object RegExp]"===__objToStr(o)};clone.__getRegExpFlags=__getRegExpFlags;return clone}();
module.exports&&(module.exports=clone$jscomp$0)})({get exports(){return cloneExports},set exports(v){cloneExports=v}});var fastJsonStableStringify=function(data,opts){opts||(opts={});"function"===typeof opts&&(opts={cmp:opts});var cycles="boolean"===typeof opts.cycles?opts.cycles:!1,cmp=opts.cmp&&function(f){return function(node){return function(a,b){return f({key:a,value:node[a]},{key:b,value:node[b]})}}}(opts.cmp),seen=[];return function stringify(node){node&&node.toJSON&&"function"===typeof node.toJSON&&
(node=node.toJSON());if(void 0!==node){if("number"==typeof node)return isFinite(node)?""+node:"null";if("object"!==typeof node)return JSON.stringify(node);var i;if(Array.isArray(node)){var out="[";for(i=0;i<node.length;i++)i&&(out+=","),out+=stringify(node[i])||"null";return out+"]"}if(null===node)return"null";if(-1!==seen.indexOf(node)){if(cycles)return JSON.stringify("__cycle__");throw new TypeError("Converting circular structure to JSON");}var seenIndex=seen.push(node)-1,keys=Object.keys(node).sort(cmp&&
cmp(node));out="";for(i=0;i<keys.length;i++){var key=keys[i],value=stringify(node[key]);value&&(out&&(out+=","),out+=JSON.stringify(key)+":"+value)}seen.splice(seenIndex,1);return"{"+out+"}"}}(data)};const deepEqual=function equal(a,b){if(a===b)return!0;if(a&&b&&"object"==typeof a&&"object"==typeof b){if(a.constructor!==b.constructor)return!1;var i;if(Array.isArray(a)){var length=a.length;if(length!=b.length)return!1;for(i=length;0!==i--;)if(!equal(a[i],b[i]))return!1;return!0}if(a.constructor===
RegExp)return a.source===b.source&&a.flags===b.flags;if(a.valueOf!==Object.prototype.valueOf)return a.valueOf()===b.valueOf();if(a.toString!==Object.prototype.toString)return a.toString()===b.toString();var keys=Object.keys(a);length=keys.length;if(length!==Object.keys(b).length)return!1;for(i=length;0!==i--;)if(!Object.prototype.hasOwnProperty.call(b,keys[i]))return!1;for(i=length;0!==i--;)if(length=keys[i],!equal(a[length],b[length]))return!1;return!0}return a!==a&&b!==b},duplicate=cloneExports;
Set.prototype.toJSON=function(){return`Set(${[...this].map(x=>fastJsonStableStringify(x)).join(",")})`};const stringify=fastJsonStableStringify,keys$jscomp$0=Object.keys,vals$jscomp$0=Object.values,entries$1=Object.entries;let idCounter=42;const POLAR_POSITION_CHANNEL_INDEX={theta:1,theta2:1,radius:1,radius2:1},GEO_POSIITON_CHANNEL_INDEX={longitude:1,longitude2:1,latitude:1,latitude2:1},GEOPOSITION_CHANNELS=keys$jscomp$0(GEO_POSIITON_CHANNEL_INDEX),UNIT_CHANNEL_INDEX={x:1,y:1,x2:1,y2:1,...POLAR_POSITION_CHANNEL_INDEX,
...GEO_POSIITON_CHANNEL_INDEX,xOffset:1,yOffset:1,color:1,fill:1,stroke:1,opacity:1,fillOpacity:1,strokeOpacity:1,strokeWidth:1,strokeDash:1,size:1,angle:1,shape:1,order:1,text:1,detail:1,key:1,tooltip:1,href:1,url:1,description:1},FACET_CHANNEL_INDEX={row:1,column:1,facet:1},FACET_CHANNELS=keys$jscomp$0(FACET_CHANNEL_INDEX),CHANNEL_INDEX={...UNIT_CHANNEL_INDEX,...FACET_CHANNEL_INDEX},CHANNELS=keys$jscomp$0(CHANNEL_INDEX),{order:_o,detail:_d,tooltip:_tt1,...SINGLE_DEF_CHANNEL_INDEX}=CHANNEL_INDEX,
{row:_r,column:_c,facet:_f,...SINGLE_DEF_UNIT_CHANNEL_INDEX}=SINGLE_DEF_CHANNEL_INDEX,SECONDARY_RANGE_CHANNEL="x2 y2 latitude2 longitude2 theta2 radius2".split(" "),UNIT_CHANNELS=keys$jscomp$0(UNIT_CHANNEL_INDEX),{x:_x,y:_y,x2:_x2,y2:_y2,xOffset:_xo,yOffset:_yo,latitude:_latitude,longitude:_longitude,latitude2:_latitude2,longitude2:_longitude2,theta:_theta,theta2:_theta2,radius:_radius,radius2:_radius2,...NONPOSITION_CHANNEL_INDEX}=UNIT_CHANNEL_INDEX,NONPOSITION_CHANNELS=keys$jscomp$0(NONPOSITION_CHANNEL_INDEX),
POSITION_SCALE_CHANNEL_INDEX={x:1,y:1},POSITION_SCALE_CHANNELS=keys$jscomp$0(POSITION_SCALE_CHANNEL_INDEX),POLAR_POSITION_SCALE_CHANNEL_INDEX={theta:1,radius:1},POLAR_POSITION_SCALE_CHANNELS=keys$jscomp$0(POLAR_POSITION_SCALE_CHANNEL_INDEX),OFFSET_SCALE_CHANNEL_INDEX={xOffset:1,yOffset:1},{text:_t,tooltip:_tt,href:_hr,url:_u,description:_al,detail:_dd,key:_k,order:_oo,...NONPOSITION_SCALE_CHANNEL_INDEX}=NONPOSITION_CHANNEL_INDEX,NONPOSITION_SCALE_CHANNELS=keys$jscomp$0(NONPOSITION_SCALE_CHANNEL_INDEX),
SCALE_CHANNEL_INDEX={...POSITION_SCALE_CHANNEL_INDEX,...POLAR_POSITION_SCALE_CHANNEL_INDEX,...OFFSET_SCALE_CHANNEL_INDEX,...NONPOSITION_SCALE_CHANNEL_INDEX},SCALE_CHANNELS=keys$jscomp$0(SCALE_CHANNEL_INDEX),ALL_MARKS={arc:"always",area:"always",bar:"always",circle:"always",geoshape:"always",image:"always",line:"always",rule:"always",point:"always",rect:"always",square:"always",trail:"always",text:"always",tick:"always"},{geoshape:_g,...ALL_MARKS_EXCEPT_GEOSHAPE}=ALL_MARKS,AGGREGATE_OP_INDEX={argmax:1,
argmin:1,average:1,count:1,distinct:1,product:1,max:1,mean:1,median:1,min:1,missing:1,q1:1,q3:1,ci0:1,ci1:1,stderr:1,stdev:1,stdevp:1,sum:1,valid:1,values:1,variance:1,variancep:1},MULTIDOMAIN_SORT_OP_INDEX={count:1,min:1,max:1},COUNTING_OPS=new Set(["count","valid","missing","distinct"]),SUM_OPS=new Set(["count","sum","distinct","valid","missing"]),SHARED_DOMAIN_OPS=new Set("mean average median q1 q3 min max".split(" ")),VG_MARK_CONFIGS=keys$jscomp$0({aria:1,description:1,ariaRole:1,ariaRoleDescription:1,
blend:1,opacity:1,fill:1,fillOpacity:1,stroke:1,strokeCap:1,strokeWidth:1,strokeOpacity:1,strokeDash:1,strokeDashOffset:1,strokeJoin:1,strokeOffset:1,strokeMiterLimit:1,startAngle:1,endAngle:1,padAngle:1,innerRadius:1,outerRadius:1,size:1,shape:1,interpolate:1,tension:1,orient:1,align:1,baseline:1,text:1,dir:1,dx:1,dy:1,ellipsis:1,limit:1,radius:1,theta:1,angle:1,font:1,fontSize:1,fontWeight:1,fontStyle:1,lineBreak:1,lineHeight:1,cursor:1,href:1,tooltip:1,cornerRadius:1,cornerRadiusTopLeft:1,cornerRadiusTopRight:1,
cornerRadiusBottomLeft:1,cornerRadiusBottomRight:1,aspect:1,width:1,height:1,url:1,smooth:1}),VG_MARK_INDEX={arc:1,area:1,group:1,image:1,line:1,path:1,rect:1,rule:1,shape:1,symbol:1,text:1,trail:1},VG_CORNERRADIUS_CHANNELS=["cornerRadius","cornerRadiusTopLeft","cornerRadiusTopRight","cornerRadiusBottomLeft","cornerRadiusBottomRight"],main=vega.logger(vega.Warn);let current=main;const MONTHS="january february march april may june july august september october november december".split(" "),SHORT_MONTHS=
MONTHS.map(m=>m.substr(0,3)),DAYS="sunday monday tuesday wednesday thursday friday saturday".split(" "),SHORT_DAYS=DAYS.map(d=>d.substr(0,3)),LOCAL_SINGLE_TIMEUNIT_INDEX={year:1,quarter:1,month:1,week:1,day:1,dayofyear:1,date:1,hours:1,minutes:1,seconds:1,milliseconds:1},TIMEUNIT_PARTS=keys$jscomp$0(LOCAL_SINGLE_TIMEUNIT_INDEX),VEGALITE_TIMEFORMAT={"year-month":"%b %Y ","year-month-date":"%b %d, %Y "},ScaleType={LINEAR:"linear",LOG:"log",POW:"pow",SQRT:"sqrt",SYMLOG:"symlog",IDENTITY:"identity",SEQUENTIAL:"sequential",
TIME:"time",UTC:"utc",QUANTILE:"quantile",QUANTIZE:"quantize",THRESHOLD:"threshold",BIN_ORDINAL:"bin-ordinal",ORDINAL:"ordinal",POINT:"point",BAND:"band"},SCALE_CATEGORY_INDEX={linear:"numeric",log:"numeric",pow:"numeric",sqrt:"numeric",symlog:"numeric",identity:"numeric",sequential:"numeric",time:"time",utc:"time",ordinal:"ordinal","bin-ordinal":"bin-ordinal",point:"ordinal-position",band:"ordinal-position",quantile:"discretizing",quantize:"discretizing",threshold:"discretizing"},SCALE_PRECEDENCE_INDEX=
{linear:0,log:1,pow:1,sqrt:1,symlog:1,identity:1,sequential:1,time:0,utc:0,point:10,band:11,ordinal:0,"bin-ordinal":0,quantile:0,quantize:0,threshold:0},QUANTITATIVE_SCALES=new Set(["linear","log","pow","sqrt","symlog"]),CONTINUOUS_TO_CONTINUOUS_SCALES=new Set([...QUANTITATIVE_SCALES,"time","utc"]),CONTINUOUS_TO_DISCRETE_SCALES=new Set(["quantile","quantize","threshold"]),CONTINUOUS_DOMAIN_SCALES=new Set([...CONTINUOUS_TO_CONTINUOUS_SCALES,...CONTINUOUS_TO_DISCRETE_SCALES,"sequential","identity"]),
DISCRETE_DOMAIN_SCALES=new Set(["ordinal","bin-ordinal","point","band"]),{type:type$jscomp$0,domain:domain$1,range:range$jscomp$0,rangeMax,rangeMin,scheme:scheme$jscomp$0,...NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTY_INDEX}={type:1,domain:1,domainMax:1,domainMin:1,domainMid:1,align:1,range:1,rangeMax:1,rangeMin:1,scheme:1,bins:1,reverse:1,round:1,clamp:1,nice:1,base:1,exponent:1,constant:1,interpolate:1,zero:1,padding:1,paddingInner:1,paddingOuter:1},NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTIES=keys$jscomp$0(NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTY_INDEX),
Mark={arc:"arc",area:"area",bar:"bar",image:"image",line:"line",point:"point",rect:"rect",rule:"rule",text:"text",tick:"tick",trail:"trail",circle:"circle",square:"square",geoshape:"geoshape"},ARC=Mark.arc,AREA=Mark.area,BAR=Mark.bar,IMAGE=Mark.image,LINE=Mark.line,POINT=Mark.point,RECT=Mark.rect,RULE=Mark.rule,TEXT=Mark.text,TICK=Mark.tick,TRAIL=Mark.trail,CIRCLE=Mark.circle,SQUARE=Mark.square,GEOSHAPE=Mark.geoshape,PRIMITIVE_MARKS=new Set(keys$jscomp$0(Mark)),FILL_STROKE_CONFIG="stroke strokeWidth strokeDash strokeDashOffset strokeOpacity strokeJoin strokeMiterLimit fill fillOpacity".split(" "),
VL_ONLY_MARK_CONFIG_PROPERTIES=keys$jscomp$0({color:1,filled:1,invalid:1,order:1,radius2:1,theta2:1,timeUnitBandSize:1,timeUnitBandPosition:1}),MARK_CONFIGS=keys$jscomp$0({mark:1,arc:1,area:1,bar:1,circle:1,image:1,line:1,point:1,rect:1,rule:1,square:1,text:1,tick:1,trail:1,geoshape:1}),BAR_CORNER_RADIUS_INDEX={horizontal:["cornerRadiusTopRight","cornerRadiusBottomRight"],vertical:["cornerRadiusTopLeft","cornerRadiusTopRight"]},SORT_BY_CHANNEL_INDEX={x:1,y:1,color:1,fill:1,stroke:1,strokeWidth:1,
size:1,shape:1,fillOpacity:1,strokeOpacity:1,opacity:1,text:1},defaultTitleFormatter=(fieldDef,config)=>{switch(config.fieldTitle){case "plain":return fieldDef.field;case "functional":{const {aggregate,bin,timeUnit,field}=fieldDef;isArgmaxDef(aggregate)?fieldDef=`${field} for argmax(${aggregate.argmax})`:isArgminDef(aggregate)?fieldDef=`${field} for argmin(${aggregate.argmin})`:(fieldDef=normalizeTimeUnit(timeUnit),fieldDef=(fieldDef=aggregate||fieldDef?.unit||fieldDef?.maxbins&&"timeunit"||isBinning(bin)&&
"bin")?`${fieldDef.toUpperCase()}(${field})`:field)}return fieldDef;default:return verbalTitleFormatter(fieldDef,config)}};let titleFormatter=defaultTitleFormatter;const COMPATIBLE={compatible:!0},CONDITIONAL_AXIS_PROP_INDEX={labelAlign:{part:"labels",vgProp:"align"},labelBaseline:{part:"labels",vgProp:"baseline"},labelColor:{part:"labels",vgProp:"fill"},labelFont:{part:"labels",vgProp:"font"},labelFontSize:{part:"labels",vgProp:"fontSize"},labelFontStyle:{part:"labels",vgProp:"fontStyle"},labelFontWeight:{part:"labels",
vgProp:"fontWeight"},labelOpacity:{part:"labels",vgProp:"opacity"},labelOffset:null,labelPadding:null,gridColor:{part:"grid",vgProp:"stroke"},gridDash:{part:"grid",vgProp:"strokeDash"},gridDashOffset:{part:"grid",vgProp:"strokeDashOffset"},gridOpacity:{part:"grid",vgProp:"opacity"},gridWidth:{part:"grid",vgProp:"strokeWidth"},tickColor:{part:"ticks",vgProp:"stroke"},tickDash:{part:"ticks",vgProp:"strokeDash"},tickDashOffset:{part:"ticks",vgProp:"strokeDashOffset"},tickOpacity:{part:"ticks",vgProp:"opacity"},
tickSize:null,tickWidth:{part:"ticks",vgProp:"strokeWidth"}},AXIS_PARTS=["domain","grid","labels","ticks","title"],AXIS_PROPERTY_TYPE={grid:"grid",gridCap:"grid",gridColor:"grid",gridDash:"grid",gridDashOffset:"grid",gridOpacity:"grid",gridScale:"grid",gridWidth:"grid",orient:"main",bandPosition:"both",aria:"main",description:"main",domain:"main",domainCap:"main",domainColor:"main",domainDash:"main",domainDashOffset:"main",domainOpacity:"main",domainWidth:"main",format:"main",formatType:"main",labelAlign:"main",
labelAngle:"main",labelBaseline:"main",labelBound:"main",labelColor:"main",labelFlush:"main",labelFlushOffset:"main",labelFont:"main",labelFontSize:"main",labelFontStyle:"main",labelFontWeight:"main",labelLimit:"main",labelLineHeight:"main",labelOffset:"main",labelOpacity:"main",labelOverlap:"main",labelPadding:"main",labels:"main",labelSeparation:"main",maxExtent:"main",minExtent:"main",offset:"both",position:"main",tickCap:"main",tickColor:"main",tickDash:"main",tickDashOffset:"main",tickMinStep:"both",
tickOffset:"both",tickOpacity:"main",tickRound:"both",ticks:"main",tickSize:"main",tickWidth:"both",title:"main",titleAlign:"main",titleAnchor:"main",titleAngle:"main",titleBaseline:"main",titleColor:"main",titleFont:"main",titleFontSize:"main",titleFontStyle:"main",titleFontWeight:"main",titleLimit:"main",titleLineHeight:"main",titleOpacity:"main",titlePadding:"main",titleX:"main",titleY:"main",encode:"both",scale:"both",tickBand:"both",tickCount:"both",tickExtra:"both",translate:"both",values:"both",
zindex:"both"},COMMON_AXIS_PROPERTIES_INDEX={orient:1,aria:1,bandPosition:1,description:1,domain:1,domainCap:1,domainColor:1,domainDash:1,domainDashOffset:1,domainOpacity:1,domainWidth:1,format:1,formatType:1,grid:1,gridCap:1,gridColor:1,gridDash:1,gridDashOffset:1,gridOpacity:1,gridWidth:1,labelAlign:1,labelAngle:1,labelBaseline:1,labelBound:1,labelColor:1,labelFlush:1,labelFlushOffset:1,labelFont:1,labelFontSize:1,labelFontStyle:1,labelFontWeight:1,labelLimit:1,labelLineHeight:1,labelOffset:1,labelOpacity:1,
labelOverlap:1,labelPadding:1,labels:1,labelSeparation:1,maxExtent:1,minExtent:1,offset:1,position:1,tickBand:1,tickCap:1,tickColor:1,tickCount:1,tickDash:1,tickDashOffset:1,tickExtra:1,tickMinStep:1,tickOffset:1,tickOpacity:1,tickRound:1,ticks:1,tickSize:1,tickWidth:1,title:1,titleAlign:1,titleAnchor:1,titleAngle:1,titleBaseline:1,titleColor:1,titleFont:1,titleFontSize:1,titleFontStyle:1,titleFontWeight:1,titleLimit:1,titleLineHeight:1,titleOpacity:1,titlePadding:1,titleX:1,titleY:1,translate:1,
values:1,zindex:1},AXIS_PROPERTIES_INDEX={...COMMON_AXIS_PROPERTIES_INDEX,style:1,labelExpr:1,encoding:1},AXIS_CONFIGS=keys$jscomp$0({axis:1,axisBand:1,axisBottom:1,axisDiscrete:1,axisLeft:1,axisPoint:1,axisQuantitative:1,axisRight:1,axisTemporal:1,axisTop:1,axisX:1,axisXBand:1,axisXDiscrete:1,axisXPoint:1,axisXQuantitative:1,axisXTemporal:1,axisY:1,axisYBand:1,axisYDiscrete:1,axisYPoint:1,axisYQuantitative:1,axisYTemporal:1});class CompositeMarkNormalizer{constructor(name,run){this.name=name;this.run=
run}hasMatchingType(spec){return isUnitSpec(spec)?(spec=spec.mark,(isMarkDef(spec)?spec.type:spec)===this.name):!1}}const boxPlotNormalizer=new CompositeMarkNormalizer("boxplot",normalizeBoxPlot),errorBarNormalizer=new CompositeMarkNormalizer("errorbar",normalizeErrorBar),errorBandNormalizer=new CompositeMarkNormalizer("errorband",normalizeErrorBand),compositeMarkRegistry={};add$jscomp$0("boxplot",normalizeBoxPlot,["box","median","outliers","rule","ticks"]);add$jscomp$0("errorbar",normalizeErrorBar,
["ticks","rule"]);add$jscomp$0("errorband",normalizeErrorBand,["band","borders"]);const VL_ONLY_LEGEND_CONFIG=["gradientHorizontalMaxLength","gradientHorizontalMinLength","gradientVerticalMaxLength","gradientVerticalMinLength","unselectedOpacity"],HEADER_TITLE_PROPERTIES_MAP={titleAlign:"align",titleAnchor:"anchor",titleAngle:"angle",titleBaseline:"baseline",titleColor:"color",titleFont:"font",titleFontSize:"fontSize",titleFontStyle:"fontStyle",titleFontWeight:"fontWeight",titleLimit:"limit",titleLineHeight:"lineHeight",
titleOrient:"orient",titlePadding:"offset"},HEADER_LABEL_PROPERTIES_MAP={labelAlign:"align",labelAnchor:"anchor",labelAngle:"angle",labelBaseline:"baseline",labelColor:"color",labelFont:"font",labelFontSize:"fontSize",labelFontStyle:"fontStyle",labelFontWeight:"fontWeight",labelLimit:"limit",labelLineHeight:"lineHeight",labelOrient:"orient",labelPadding:"offset"},HEADER_TITLE_PROPERTIES=keys$jscomp$0(HEADER_TITLE_PROPERTIES_MAP),HEADER_LABEL_PROPERTIES=keys$jscomp$0(HEADER_LABEL_PROPERTIES_MAP),HEADER_CONFIGS=
keys$jscomp$0({header:1,headerRow:1,headerColumn:1,headerFacet:1}),LEGEND_SCALE_CHANNELS="size shape fill stroke strokeDash strokeWidth opacity".split(" "),COMPOSITION_LAYOUT_PROPERTIES=keys$jscomp$0({align:1,bounds:1,center:1,columns:1,spacing:1}),defaultConfig={background:"white",padding:5,timeFormat:"%b %d, %Y",countTitle:"Count of Records",view:{continuousWidth:200,continuousHeight:200,step:20},mark:{color:"#4c78a8",invalid:"filter",timeUnitBandSize:1},arc:{},area:{},bar:{binSpacing:1,continuousBandSize:5,
timeUnitBandPosition:.5},circle:{},geoshape:{},image:{},line:{},point:{},rect:{binSpacing:0,continuousBandSize:5,timeUnitBandPosition:.5},rule:{color:"black"},square:{},text:{color:"black"},tick:{thickness:1},trail:{},boxplot:{size:14,extent:1.5,box:{},median:{color:"white"},outliers:{},rule:{},ticks:null},errorbar:{center:"mean",rule:!0,ticks:!1},errorband:{band:{opacity:.3},borders:!1},scale:{pointPadding:.5,barBandPaddingInner:.1,rectBandPaddingInner:0,bandWithNestedOffsetPaddingInner:.2,bandWithNestedOffsetPaddingOuter:.2,
minBandSize:2,minFontSize:8,maxFontSize:40,minOpacity:.3,maxOpacity:.8,minSize:9,minStrokeWidth:1,maxStrokeWidth:4,quantileCount:4,quantizeCount:4,zero:!0},projection:{},legend:{gradientHorizontalMaxLength:200,gradientHorizontalMinLength:100,gradientVerticalMaxLength:200,gradientVerticalMinLength:64,unselectedOpacity:.35},header:{titlePadding:10,labelPadding:10},headerColumn:{},headerRow:{},headerFacet:{},selection:{point:{on:"click",fields:["_vgsid_"],toggle:"event.shiftKey",resolve:"global",clear:"dblclick"},
interval:{on:"[mousedown, window:mouseup] \x3e window:mousemove!",encodings:["x","y"],translate:"[mousedown, window:mouseup] \x3e window:mousemove!",zoom:"wheel!",mark:{fill:"#333",fillOpacity:.125,stroke:"white"},resolve:"global",clear:"dblclick"}},style:{},title:{},facet:{spacing:20},concat:{spacing:20},normalizedNumberFormat:".0%"},tab10="#4c78a8 #f58518 #e45756 #72b7b2 #54a24b #eeca3b #b279a2 #ff9da6 #9d755d #bab0ac".split(" "),DEFAULT_FONT_SIZE={text:11,guideLabel:10,guideTitle:11,groupTitle:13,
groupSubtitle:12},DEFAULT_COLOR={blue:tab10[0],orange:tab10[1],red:tab10[2],teal:tab10[3],green:tab10[4],yellow:tab10[5],purple:tab10[6],pink:tab10[7],brown:tab10[8],gray0:"#000",gray1:"#111",gray2:"#222",gray3:"#333",gray4:"#444",gray5:"#555",gray6:"#666",gray7:"#777",gray8:"#888",gray9:"#999",gray10:"#aaa",gray11:"#bbb",gray12:"#ccc",gray13:"#ddd",gray14:"#eee",gray15:"#fff"},configPropsWithExpr=[...MARK_CONFIGS,...AXIS_CONFIGS,...HEADER_CONFIGS,"background","padding","legend","lineBreak","scale",
"style","title","view"],MARK_STYLES=new Set(["view",...PRIMITIVE_MARKS]),VL_ONLY_CONFIG_PROPERTIES="color fontSize background padding facet concat numberFormat numberFormatType normalizedNumberFormat normalizedNumberFormatType timeFormat countTitle header axisQuantitative axisTemporal axisDiscrete axisPoint axisXBand axisXPoint axisXDiscrete axisXQuantitative axisXTemporal axisYBand axisYPoint axisYDiscrete axisYQuantitative axisYTemporal scale selection overlay".split(" "),VL_ONLY_ALL_MARK_SPECIFIC_CONFIG_PROPERTY_INDEX=
{view:["continuousWidth","continuousHeight","discreteWidth","discreteHeight","step"],area:["line","point"],bar:["binSpacing","continuousBandSize","discreteBandSize"],rect:["binSpacing","continuousBandSize","discreteBandSize"],line:["point"],tick:["bandSize","thickness"]};class SpecMapper{map(spec,params){return"facet"in spec?this.mapFacet(spec,params):"repeat"in spec?this.mapRepeat(spec,params):"hconcat"in spec?this.mapHConcat(spec,params):"vconcat"in spec?this.mapVConcat(spec,params):"concat"in spec?
this.mapConcat(spec,params):this.mapLayerOrUnit(spec,params)}mapLayerOrUnit(spec,params){if("layer"in spec)return this.mapLayer(spec,params);if(isUnitSpec(spec))return this.mapUnit(spec,params);throw Error(invalidSpec(spec));}mapLayer(spec,params){return{...spec,layer:spec.layer.map(subspec=>this.mapLayerOrUnit(subspec,params))}}mapHConcat(spec,params){return{...spec,hconcat:spec.hconcat.map(subspec=>this.map(subspec,params))}}mapVConcat(spec,params){return{...spec,vconcat:spec.vconcat.map(subspec=>
this.map(subspec,params))}}mapConcat(spec,params){const {concat,...rest}=spec;return{...rest,concat:concat.map(subspec=>this.map(subspec,params))}}mapFacet(spec,params){return{...spec,spec:this.map(spec.spec,params)}}mapRepeat(spec,params){return{...spec,spec:this.map(spec.spec,params)}}}const STACK_OFFSET_INDEX={zero:1,center:1,normalize:1},STACKABLE_MARKS=new Set([ARC,BAR,AREA,RULE,POINT,CIRCLE,SQUARE,LINE,TEXT,TICK]),STACK_BY_DEFAULT_MARKS=new Set([BAR,AREA,ARC]);class PathOverlayNormalizer{constructor(){_defineProperty(this,
"name","path-overlay")}hasMatchingType(spec,config){if(isUnitSpec(spec)){const {mark,encoding}=spec;spec=isMarkDef(mark)?mark:{type:mark};switch(spec.type){case "line":case "rule":case "trail":return!!getPointOverlay(spec,config[spec.type],encoding);case "area":return!!getPointOverlay(spec,config[spec.type],encoding)||!!getLineOverlay(spec,config[spec.type])}}return!1}run(spec,normParams,normalize){var {config}=normParams;const {params,projection,mark:mark$jscomp$0,encoding:e,...outerSpec}=spec;spec=
normalizeEncoding(e,config);const markDef=isMarkDef(mark$jscomp$0)?mark$jscomp$0:{type:mark$jscomp$0},pointOverlay=getPointOverlay(markDef,config[markDef.type],spec),lineOverlay="area"===markDef.type&&getLineOverlay(markDef,config[markDef.type]);const {point:_point,line:_line,...mark$jscomp$1}={...("area"===markDef.type&&void 0===markDef.opacity&&void 0===markDef.fillOpacity?{opacity:.7}:{}),...markDef};var JSCompiler_inline_result=1<keys$jscomp$0(mark$jscomp$1).length?mark$jscomp$1:mark$jscomp$1.type;
JSCompiler_inline_result=[{...(params?{params}:{}),mark:JSCompiler_inline_result,encoding:omit(spec,["shape"])}];const stackProps=stack$jscomp$1(markDef,spec);let overlayEncoding=spec;if(stackProps){const {fieldChannel:stackFieldChannel,offset}=stackProps;overlayEncoding={...spec,[stackFieldChannel]:{...spec[stackFieldChannel],...(offset?{stack:offset}:{})}}}overlayEncoding=omit(overlayEncoding,["y2","x2"]);lineOverlay&&JSCompiler_inline_result.push({...(projection?{projection}:{}),mark:{type:"line",
...pick(markDef,["clip","interpolate","tension","tooltip"]),...lineOverlay},encoding:overlayEncoding});pointOverlay&&JSCompiler_inline_result.push({...(projection?{projection}:{}),mark:{type:"point",opacity:1,filled:!0,...pick(markDef,["clip","tooltip"]),...pointOverlay},encoding:overlayEncoding});for(const mark of["line","area","rule","trail"])config[mark]&&(config={...config,[mark]:omit(config[mark],["point","line"])});return normalize({...outerSpec,layer:JSCompiler_inline_result},{...normParams,
config})}}class RuleForRangedLineNormalizer{constructor(){_defineProperty(this,"name","RuleForRangedLine")}hasMatchingType(spec){if(isUnitSpec(spec)){const {encoding,mark}=spec;if("line"===mark||isMarkDef(mark)&&"line"===mark.type)for(const channel of SECONDARY_RANGE_CHANNEL)if(spec=getMainRangeChannel(channel),spec=encoding[spec],encoding[channel]&&(isFieldDef(spec)&&!isBinned(spec.bin)||isDatumDef(spec)))return!0}return!1}run(spec,params,normalize){const {encoding,mark}=spec;var hasX2=!!encoding.x2;
warn(`Line mark is for continuous lines and thus cannot be used with ${hasX2&&encoding.y2?"x2 and y2":hasX2?"x2":"y2"}. We will use the rule mark (line segments) instead.`);return normalize({...spec,mark:vega.isObject(mark)?{...mark,type:"rule"}:"rule"},params)}}class CoreNormalizer extends SpecMapper{constructor(){super(...arguments);_defineProperty(this,"nonFacetUnitNormalizers",[boxPlotNormalizer,errorBarNormalizer,errorBandNormalizer,new PathOverlayNormalizer,new RuleForRangedLineNormalizer])}map(spec,
params){if(isUnitSpec(spec)){const hasRow=channelHasField(spec.encoding,"row"),hasColumn=channelHasField(spec.encoding,"column"),hasFacet=channelHasField(spec.encoding,"facet");if(hasRow||hasColumn||hasFacet)return this.mapFacetedUnit(spec,params)}return super.map(spec,params)}mapUnit(spec,params){const {parentEncoding,parentProjection}=params;var encoding=replaceRepeaterInEncoding(spec.encoding,params.repeater);spec={...spec,...(encoding?{encoding}:{})};if(parentEncoding||parentProjection)return this.mapUnitWithParentEncodingOrProjection(spec,
params);encoding=this.mapLayerOrUnit.bind(this);for(const unitNormalizer of this.nonFacetUnitNormalizers)if(unitNormalizer.hasMatchingType(spec,params.config))return unitNormalizer.run(spec,params,encoding);return spec}mapRepeat(spec,params){return!vega.isArray(spec.repeat)&&spec.repeat.layer?this.mapLayerRepeat(spec,params):this.mapNonLayerRepeat(spec,params)}mapLayerRepeat(spec,params){const {repeat,spec:childSpec,...rest}=spec,{row,column,layer}=repeat,{repeater={},repeaterPrefix=""}=params;return row||
column?this.mapRepeat({...spec,repeat:{...(row?{row}:{}),...(column?{column}:{})},spec:{repeat:{layer},spec:childSpec}},params):{...rest,layer:layer.map(layerValue=>{var childRepeater={...repeater,layer:layerValue};layerValue=`${(childSpec.name||"")+repeaterPrefix}child__layer_${varName(layerValue)}`;childRepeater=this.mapLayerOrUnit(childSpec,{...params,repeater:childRepeater,repeaterPrefix:layerValue});childRepeater.name=layerValue;return childRepeater})}}mapNonLayerRepeat(spec,params){const {repeat,
spec:childSpec,data,...remainingProperties}=spec;!vega.isArray(repeat)&&spec.columns&&(spec=omit(spec,["columns"]),warn(columnsNotSupportByRowCol("repeat")));const concat=[],{repeater={},repeaterPrefix=""}=params,row=!vega.isArray(repeat)&&repeat.row||[repeater?repeater.row:null],column=!vega.isArray(repeat)&&repeat.column||[repeater?repeater.column:null];var repeatValues=vega.isArray(repeat)&&repeat||[repeater?repeater.repeat:null];for(const repeatValue of repeatValues)for(const rowValue of row)for(const columnValue of column){var childRepeater=
{repeat:repeatValue,row:rowValue,column:columnValue,layer:repeater.layer};repeatValues=(childSpec.name||"")+repeaterPrefix+"child__"+(vega.isArray(repeat)?`${varName(repeatValue)}`:(repeat.row?`row_${varName(rowValue)}`:"")+(repeat.column?`column_${varName(columnValue)}`:""));childRepeater=this.map(childSpec,{...params,repeater:childRepeater,repeaterPrefix:repeatValues});childRepeater.name=repeatValues;concat.push(omit(childRepeater,["data"]))}spec=vega.isArray(repeat)?spec.columns:repeat.column?
repeat.column.length:1;return{data:childSpec.data??data,align:"all",...remainingProperties,columns:spec,concat}}mapFacet(spec,params){const {facet}=spec;isFacetMapping(facet)&&spec.columns&&(spec=omit(spec,["columns"]),warn(columnsNotSupportByRowCol("facet")));return super.mapFacet(spec,params)}mapUnitWithParentEncodingOrProjection(spec,params){const {encoding,projection}=spec,{parentEncoding,parentProjection,config}=params,mergedProjection=mergeProjection({parentProjection,projection});params=mergeEncoding({parentEncoding,
encoding:replaceRepeaterInEncoding(encoding,params.repeater)});return this.mapUnit({...spec,...(mergedProjection?{projection:mergedProjection}:{}),...(params?{encoding:params}:{})},{config})}mapFacetedUnit(spec,normParams){const {row,column,facet,...encoding}=spec.encoding,{mark,width,projection,height,view,params,encoding:_,...outerSpec}=spec,{facetMapping,layout}=this.getFacetMappingAndLayout({row,column,facet},normParams);spec=replaceRepeaterInEncoding(encoding,normParams.repeater);return this.mapFacet({...outerSpec,
...layout,facet:facetMapping,spec:{...(width?{width}:{}),...(height?{height}:{}),...(view?{view}:{}),...(projection?{projection}:{}),mark,encoding:spec,...(params?{params}:{})}},normParams)}getFacetMappingAndLayout(facets,params){const {row,column,facet}=facets;if(row||column){facet&&(params=[...(row?["row"]:[]),...(column?["column"]:[])],params=`Facet encoding dropped as ${params.join(" and ")} ${1<params.length?"are":"is"} also specified.`,warn(params));params={};const layout={};for(const channel of["row",
"column"]){const def=facets[channel];if(def){const {align,center,spacing,columns,...defWithoutLayout}=def;params[channel]=defWithoutLayout;for(const prop of["align","center","spacing"])if(void 0!==def[prop]){let $jscomp$logical$assign$tmp730812712$0,$jscomp$logical$assign$tmpindex730812712$0;($jscomp$logical$assign$tmp730812712$0=layout)[$jscomp$logical$assign$tmpindex730812712$0=prop]??($jscomp$logical$assign$tmp730812712$0[$jscomp$logical$assign$tmpindex730812712$0]={});layout[prop][channel]=def[prop]}}}return{facetMapping:params,
layout}}const {align:align$jscomp$0,center:center$jscomp$0,spacing:spacing$jscomp$0,columns:columns$jscomp$0,...facetMapping}=facet;facets=(facets=params.repeater)?isFacetMapping(facetMapping)?replaceRepeaterInMapping(facetMapping,facets):replaceRepeaterInFieldDef(facetMapping,facets):facetMapping;return{facetMapping:facets,layout:{...(align$jscomp$0?{align:align$jscomp$0}:{}),...(center$jscomp$0?{center:center$jscomp$0}:{}),...(spacing$jscomp$0?{spacing:spacing$jscomp$0}:{}),...(columns$jscomp$0?
{columns:columns$jscomp$0}:{})}}}mapLayer(spec,_ref){let {parentEncoding,parentProjection,...otherParams}=_ref;const {encoding,projection,...rest}=spec;spec={...otherParams,parentEncoding:mergeEncoding({parentEncoding,encoding,layer:!0}),parentProjection:mergeProjection({parentProjection,projection})};return super.mapLayer(rest,spec)}}class SelectionCompatibilityNormalizer extends SpecMapper{map(spec,normParams){normParams.emptySelections??(normParams.emptySelections={});normParams.selectionPredicates??
(normParams.selectionPredicates={});spec=normalizeTransforms(spec,normParams);return super.map(spec,normParams)}mapLayerOrUnit(spec,normParams){spec=normalizeTransforms(spec,normParams);if(spec.encoding){const encoding={};for(const [channel,enc]of entries$1(spec.encoding))encoding[channel]=normalizeChannelDef(enc,normParams);spec={...spec,encoding}}return super.mapLayerOrUnit(spec,normParams)}mapUnit(spec,normParams){const {selection,...rest}=spec;return selection?{...rest,params:entries$1(selection).map(_ref=>
{let [name,selDef]=_ref;const {init:value,bind,empty,...select}=selDef;"single"===select.type?(select.type="point",select.toggle=!1):"multi"===select.type&&(select.type="point");normParams.emptySelections[name]="none"!==empty;for(const pred of vals$jscomp$0(normParams.selectionPredicates[name]??{}))pred.empty="none"!==empty;return{name,value,select,bind}})}:spec}}class TopLevelSelectionsNormalizer extends SpecMapper{map(spec,normParams){const selections=normParams.selections??[];if(spec.params&&!isUnitSpec(spec)){const params=
[];for(const param of spec.params)param?.select?selections.push(param):params.push(param);spec.params=params}normParams.selections=selections;return super.map(spec,addSpecNameToParams(spec,normParams))}mapUnit(spec,normParams){const selections=normParams.selections;if(!selections||!selections.length)return spec;const path=(normParams.path??[]).concat(spec.name);normParams=[];for(const selection of selections)if(selection.views&&selection.views.length)for(const view of selection.views)(vega.isString(view)&&
(view===spec.name||0<=path.indexOf(view))||vega.isArray(view)&&view.map(v=>path.indexOf(v)).every((v,i,arr)=>-1!==v&&(0===i||v>arr[i-1])))&&normParams.push(selection);else normParams.push(selection);normParams.length&&(spec.params=normParams);return spec}}for(const method of["mapFacet","mapRepeat","mapHConcat","mapVConcat","mapLayer"]){const proto=TopLevelSelectionsNormalizer.prototype[method];TopLevelSelectionsNormalizer.prototype[method]=function(spec,params){return proto.call(this,spec,addSpecNameToParams(spec,
params))}}const coreNormalizer=new CoreNormalizer,selectionCompatNormalizer=new SelectionCompatibilityNormalizer,topLevelSelectionNormalizer=new TopLevelSelectionsNormalizer,TOP_LEVEL_PROPERTIES=["background","padding"];class Split{constructor(){let implicit=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{};this.explicit=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{};this.implicit=implicit}clone(){return new Split(duplicate(this.explicit),duplicate(this.implicit))}combine(){return{...this.explicit,
...this.implicit}}get(key){return getFirstDefined(this.explicit[key],this.implicit[key])}getWithExplicit(key){return void 0!==this.explicit[key]?{explicit:!0,value:this.explicit[key]}:void 0!==this.implicit[key]?{explicit:!1,value:this.implicit[key]}:{explicit:!1,value:void 0}}setWithExplicit(key,_ref){let {value,explicit}=_ref;void 0!==value&&this.set(key,value,explicit)}set(key,value,explicit){delete this[explicit?"implicit":"explicit"][key];this[explicit?"explicit":"implicit"][key]=value;return this}copyKeyFromSplit(key,
_ref2){let {explicit,implicit}=_ref2;void 0!==explicit[key]?this.set(key,explicit[key],!0):void 0!==implicit[key]&&this.set(key,implicit[key],!1)}copyKeyFromObject(key,s){void 0!==s[key]&&this.set(key,s[key],!0)}copyAll(other){for(const key of keys$jscomp$0(other.combine())){const val=other.getWithExplicit(key);this.setWithExplicit(key,val)}}}class AncestorParse extends Split{constructor(){let explicit=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{},implicit=1<arguments.length&&void 0!==
arguments[1]?arguments[1]:{},parseNothing=2<arguments.length&&void 0!==arguments[2]?arguments[2]:!1;super(explicit,implicit);this.explicit=explicit;this.implicit=implicit;this.parseNothing=parseNothing}clone(){const clone=super.clone();clone.parseNothing=this.parseNothing;return clone}}let DataSourceType;(function(DataSourceType){DataSourceType[DataSourceType.Raw=0]="Raw";DataSourceType[DataSourceType.Main=1]="Main";DataSourceType[DataSourceType.Row=2]="Row";DataSourceType[DataSourceType.Column=3]=
"Column";DataSourceType[DataSourceType.Lookup=4]="Lookup"})(DataSourceType||(DataSourceType={}));class DataFlowNode{constructor(parent,debugName){this.debugName=debugName;_defineProperty(this,"_children",[]);_defineProperty(this,"_parent",null);_defineProperty(this,"_hash",void 0);parent&&(this.parent=parent)}clone(){throw Error("Cannot clone node");}get parent(){return this._parent}set parent(parent){(this._parent=parent)&&parent.addChild(this)}get children(){return this._children}numChildren(){return this._children.length}addChild(child,
loc){this._children.includes(child)?warn("Attempt to add the same child twice."):void 0!==loc?this._children.splice(loc,0,child):this._children.push(child)}removeChild(oldChild){oldChild=this._children.indexOf(oldChild);this._children.splice(oldChild,1);return oldChild}remove(){let loc=this._parent.removeChild(this);for(const child of this._children)child._parent=this._parent,this._parent.addChild(child,loc++)}insertAsParentOf(other){const parent=other.parent;parent.removeChild(this);this.parent=
parent;other.parent=this}swapWithParent(){const parent=this._parent,newParent=parent.parent;for(var child of this._children)child.parent=parent;this._children=[];parent.removeChild(this);child=parent.parent.removeChild(parent);this._parent=newParent;newParent.addChild(this,child);parent.parent=this}}class OutputNode extends DataFlowNode{clone(){const cloneObj=new this.constructor;cloneObj.debugName=`clone_${this.debugName}`;cloneObj._source=this._source;cloneObj._name=`clone_${this._name}`;cloneObj.type=
this.type;cloneObj.refCounts=this.refCounts;cloneObj.refCounts[cloneObj._name]=0;return cloneObj}constructor(parent,source,type,refCounts){super(parent,source);this.type=type;this.refCounts=refCounts;_defineProperty(this,"_source",void 0);_defineProperty(this,"_name",void 0);this._source=this._name=source;!this.refCounts||this._name in this.refCounts||(this.refCounts[this._name]=0)}dependentFields(){return new Set}producedFields(){return new Set}hash(){void 0===this._hash&&(this._hash=`Output ${uniqueId()}`);
return this._hash}getSource(){this.refCounts[this._name]++;return this._source}isRequired(){return!!this.refCounts[this._name]}setSource(source){this._source=source}}class TimeUnitNode extends DataFlowNode{clone(){return new TimeUnitNode(null,duplicate(this.formula))}constructor(parent,formula){super(parent);this.formula=formula}static makeFromEncoding(parent,model){model=model.reduceFieldDef((timeUnitComponent,fieldDef)=>{const {field,timeUnit}=fieldDef;timeUnit&&(fieldDef=vgField(fieldDef,{forAs:!0}),
timeUnitComponent[hash({as:fieldDef,field,timeUnit})]={as:fieldDef,field,timeUnit});return timeUnitComponent},{});return isEmpty(model)?null:new TimeUnitNode(parent,model)}static makeFromTransform(parent,t){const {timeUnit,...other}={...t};t=normalizeTimeUnit(timeUnit);t={...other,timeUnit:t};return new TimeUnitNode(parent,{[hash(t)]:t})}merge(other){this.formula={...this.formula};for(const key in other.formula)this.formula[key]||(this.formula[key]=other.formula[key]);for(const child of other.children)other.removeChild(child),
child.parent=this;other.remove()}removeFormulas(fields){const newFormula={};for(const [key,timeUnit]of entries$1(this.formula))fields.has(timeUnit.as)||(newFormula[key]=timeUnit);this.formula=newFormula}producedFields(){return new Set(vals$jscomp$0(this.formula).map(f=>f.as))}dependentFields(){return new Set(vals$jscomp$0(this.formula).map(f=>f.field))}hash(){return`TimeUnit ${hash(this.formula)}`}assemble(){const transforms=[];for(const f of vals$jscomp$0(this.formula)){const {field,as,timeUnit}=
f,{unit,utc,...params}=normalizeTimeUnit(timeUnit);transforms.push({field:replacePathInField(field),type:"timeunit",...(unit?{units:getTimeUnitParts(unit)}:{}),...(utc?{timezone:"utc"}:{}),...params,as:[as,`${as}_end`]})}return transforms}}class SelectionProjectionComponent{constructor(){_defineProperty(this,"hasChannel",void 0);_defineProperty(this,"hasField",void 0);_defineProperty(this,"hasSelectionId",void 0);_defineProperty(this,"timeUnit",void 0);_defineProperty(this,"items",void 0);for(var _len=
arguments.length,items=Array(_len),_key=0;_key<_len;_key++)items[_key]=arguments[_key];this.items=items;this.hasChannel={};this.hasField={};this.hasSelectionId=!1}}const scaleBindings={defined:selCmpt=>"interval"===selCmpt.type&&"global"===selCmpt.resolve&&selCmpt.bind&&"scales"===selCmpt.bind,parse:(model,selCmpt)=>{const bound=selCmpt.scales=[];for(const proj of selCmpt.project.items){var channel=proj.channel;if(!SCALE_CHANNEL_INDEX[channel])continue;const scaleType=(channel=model.getScaleComponent(channel))?
channel.get("type"):void 0;channel&&hasContinuousDomain(scaleType)?(channel.set("selectionExtent",{param:selCmpt.name,field:proj.field},!0),bound.push(proj)):warn("Scale bindings are currently only supported for scales with unbinned, continuous domains.")}},topLevelSignals:(model,selCmpt,signals)=>{const bound=selCmpt.scales.filter(proj=>0===signals.filter(s=>s.name===proj.signals.data).length);if(!model.parent||isTopLevelLayer(model)||0===bound.length)return signals;model=signals.filter(s=>s.name===
selCmpt.name)[0];let update=model.update;if(0<=update.indexOf("vlSelectionResolve"))model.update=`{${bound.map(proj=>`${vega.stringValue(replacePathInField(proj.field))}: ${proj.signals.data}`).join(", ")}}`;else{for(const proj of bound){const mapping=`${vega.stringValue(replacePathInField(proj.field))}: ${proj.signals.data}`;update.includes(mapping)||(update=`${update.substring(0,update.length-1)}, ${mapping}}`)}model.update=update}return signals.concat(bound.map(proj=>({name:proj.signals.data})))},
signals:(model,selCmpt,signals)=>{if(model.parent&&!isTopLevelLayer(model))for(const proj of selCmpt.scales)model=signals.filter(s=>s.name===proj.signals.data)[0],model.push="outer",delete model.value,delete model.update;return signals}},ALIGNED_X_CHANNEL={left:"x",center:"xc",right:"x2"},BASELINED_Y_CHANNEL={top:"y",middle:"yc",bottom:"y2"},ALWAYS_IGNORE=new Set(["aria","width","height"]),nearest={defined:selCmpt=>"point"===selCmpt.type&&selCmpt.nearest,parse:(model,selCmpt)=>{if(selCmpt.events)for(const s of selCmpt.events)s.markname=
model.getName("voronoi")},marks:(model,selCmpt,marks)=>{const {x,y}=selCmpt.project.hasChannel;selCmpt=model.mark;if(isPathMark(selCmpt))return warn(`The "nearest" transform is not supported for ${selCmpt} marks.`),marks;selCmpt={name:model.getName("voronoi"),type:"path",interactive:!0,from:{data:model.getName("marks")},encode:{update:{fill:{value:"transparent"},strokeWidth:{value:.35},stroke:{value:"transparent"},isVoronoi:{value:!0},...tooltip$jscomp$1(model,{reactiveGeom:!0})}},transform:[{type:"voronoi",
x:{expr:x||!y?"datum.datum.x || 0":"0"},y:{expr:y||!x?"datum.datum.y || 0":"0"},size:[model.getSizeSignalRef("width"),model.getSizeSignalRef("height")]}]};let index=0,exists=!1;marks.forEach((mark,i)=>{mark=mark.name??"";mark===model.component.mark[0].name?index=i:0<=mark.indexOf("voronoi")&&(exists=!0)});exists||marks.splice(index+1,0,selCmpt);return marks}},inputBindings={defined:selCmpt=>"point"===selCmpt.type&&"global"===selCmpt.resolve&&selCmpt.bind&&"scales"!==selCmpt.bind&&!isLegendBinding(selCmpt.bind),
parse:(model,selCmpt,selDef)=>disableDirectManipulation(selCmpt,selDef),topLevelSignals:(model,selCmpt,signals)=>{const name=selCmpt.name;model=selCmpt.project;const bind=selCmpt.bind,init=selCmpt.init&&selCmpt.init[0],datum=nearest.defined(selCmpt)?"(item().isVoronoi ? datum.datum : datum)":"datum";model.items.forEach((p,i)=>{const sgname=varName(`${name}_${p.field}`);signals.filter(s=>s.name===sgname).length||signals.unshift({name:sgname,...(init?{init:assembleInit(init[i])}:{value:null}),on:selCmpt.events?
[{events:selCmpt.events,update:`datum && item().mark.marktype !== 'group' ? ${datum}[${vega.stringValue(p.field)}] : null`}]:[],bind:bind[p.field]??bind[p.channel]??bind})});return signals},signals:(model,selCmpt,signals)=>{const name=selCmpt.name;var proj=selCmpt.project;model=signals.filter(s=>s.name===name+"_tuple")[0];selCmpt=name+"_tuple_fields";proj=proj.items.map(p=>varName(`${name}_${p.field}`));const valid=proj.map(v=>`${v} !== null`).join(" \x26\x26 ");proj.length&&(model.update=`${valid} ? {fields: ${selCmpt}, values: [${proj.join(", ")}]} : null`);
delete model.value;delete model.on;return signals}},toggle={defined:selCmpt=>"point"===selCmpt.type&&!!selCmpt.toggle,signals:(model,selCmpt,signals)=>signals.concat({name:selCmpt.name+"_toggle",value:!1,on:[{events:selCmpt.events,update:selCmpt.toggle}]}),modifyExpr:(model,selCmpt)=>{const tpl=selCmpt.name+"_tuple",signal=selCmpt.name+"_toggle";return`${signal} ? null : ${tpl}, `+("global"===selCmpt.resolve?`${signal} ? null : true, `:`${signal} ? null : {unit: ${unitName(model)}}, `)+`${signal} ? ${tpl} : null`}},
legendBindings={defined:selCmpt=>{const spec="global"===selCmpt.resolve&&selCmpt.bind&&isLegendBinding(selCmpt.bind);selCmpt=1===selCmpt.project.items.length&&"_vgsid_"!==selCmpt.project.items[0].field;spec&&!selCmpt&&warn("Legend bindings are only supported for selections over an individual field or encoding channel.");return spec&&selCmpt},parse:(model,selCmpt,selDef)=>{model=duplicate(selDef);model.select=vega.isString(model.select)?{type:model.select,toggle:selCmpt.toggle}:{...model.select,toggle:selCmpt.toggle};
disableDirectManipulation(selCmpt,model);if(vega.isObject(selDef.select)&&(selDef.select.on||selDef.select.clear))for(const evt of selCmpt.events)evt.filter=vega.array(evt.filter??[]),evt.filter.includes('event.item \x26\x26 indexof(event.item.mark.role, "legend") \x3c 0')||evt.filter.push('event.item \x26\x26 indexof(event.item.mark.role, "legend") \x3c 0');selDef=isLegendStreamBinding(selCmpt.bind)?selCmpt.bind.legend:"click";selDef=vega.isString(selDef)?vega.parseSelector(selDef,"view"):vega.array(selDef);
selCmpt.bind={legend:{merge:selDef}}},topLevelSignals:(model,selCmpt,signals)=>{model=selCmpt.name;const stream=isLegendStreamBinding(selCmpt.bind)&&selCmpt.bind.legend,markName=name=>s=>{s=duplicate(s);s.markname=name;return s};for(const proj of selCmpt.project.items){if(!proj.hasLegend)continue;var prefix=`${varName(proj.field)}_legend`;const sgName=`${model}_${prefix}`;0===signals.filter(s=>s.name===sgName).length&&(prefix=stream.merge.map(markName(`${prefix}_symbols`)).concat(stream.merge.map(markName(`${prefix}_labels`))).concat(stream.merge.map(markName(`${prefix}_entries`))),
signals.unshift({name:sgName,...(selCmpt.init?{}:{value:null}),on:[{events:prefix,update:"datum.value || item().items[0].items[0].datum.value",force:!0},{events:stream.merge,update:`!event.item || !datum ? null : ${sgName}`,force:!0}]}))}return signals},signals:(model,selCmpt,signals)=>{const name=selCmpt.name;var proj=selCmpt.project;model=signals.find(s=>s.name===name+"_tuple");var fields=name+"_tuple_fields";proj=proj.items.filter(p=>p.hasLegend).map(p=>varName(`${name}_${varName(p.field)}_legend`));
fields=`${proj.map(v=>`${v} !== null`).join(" \x26\x26 ")} ? {fields: ${fields}, values: [${proj.join(", ")}]} : null`;selCmpt.events&&0<proj.length?model.on.push({events:proj.map(signal=>({signal})),update:fields}):0<proj.length&&(model.update=fields,delete model.value,delete model.on);model=signals.find(s=>s.name===name+"_toggle");fields=isLegendStreamBinding(selCmpt.bind)&&selCmpt.bind.legend;model&&(selCmpt.events?model.on.push({...model.on[0],events:fields}):model.on[0].events=fields);return signals}},
selectionCompilers=[{defined:selCmpt=>"point"===selCmpt.type,signals:(model,selCmpt,signals)=>{const name=selCmpt.name,fieldsSg=name+"_tuple_fields";var project=selCmpt.project,brushes=vals$jscomp$0(model.component.selection??{}).reduce((acc,cmpt)=>"interval"===cmpt.type?acc.concat(cmpt.name+"_brush"):acc,[]).map(b=>`indexof(item().mark.name, '${b}') < 0`).join(" \x26\x26 ");brushes=`datum && item().mark.marktype !== 'group' && indexof(item().mark.role, 'legend') < 0${brushes?` && ${brushes}`:""}`;
let update=`unit: ${unitName(model)}, `;selCmpt.project.hasSelectionId?update+=`${"_vgsid_"}: ${"(item().isVoronoi ? datum.datum : datum)"}[${vega.stringValue("_vgsid_")}]`:(project=project.items.map(p=>model.fieldDef(p.channel)?.bin?`[${"(item().isVoronoi ? datum.datum : datum)"}[${vega.stringValue(model.vgField(p.channel,{}))}], `+`${"(item().isVoronoi ? datum.datum : datum)"}[${vega.stringValue(model.vgField(p.channel,{binSuffix:"end"}))}]]`:`${"(item().isVoronoi ? datum.datum : datum)"}[${vega.stringValue(p.field)}]`).join(", "),
update+=`fields: ${fieldsSg}, values: [${project}]`);selCmpt=selCmpt.events;return signals.concat([{name:name+"_tuple",on:selCmpt?[{events:selCmpt,update:`${brushes} ? {${update}} : null`,force:!0}]:[]}])}},{defined:selCmpt=>"interval"===selCmpt.type,signals:(model,selCmpt,signals)=>{const name=selCmpt.name;var fieldsSg=name+"_tuple_fields";const hasScales=scaleBindings.defined(selCmpt),init=selCmpt.init?selCmpt.init[0]:null,dataSignals=[],scaleTriggers=[];if(selCmpt.translate&&!hasScales){const filterExpr=
`!event.item || event.item.mark.name !== ${vega.stringValue(name+"_brush")}`;events$jscomp$0(selCmpt,(on,evt)=>{let $jscomp$logical$assign$tmp730812712$5;evt=vega.array(($jscomp$logical$assign$tmp730812712$5=evt.between[0]).filter??($jscomp$logical$assign$tmp730812712$5.filter=[]));evt.includes(filterExpr)||evt.push(filterExpr);return on})}selCmpt.project.items.forEach((proj,i)=>{const channel=proj.channel;if("x"!==channel&&"y"!==channel)warn("Interval selections only support x and y encoding channels.");
else{i=channelSignals(model,selCmpt,proj,init?init[i]:null);var dname=proj.signals.data;proj=proj.signals.visual;var scaleName=vega.stringValue(model.scaleName(channel)),scaleType=model.getScaleComponent(channel).get("type");scaleType=hasContinuousDomain(scaleType)?"+":"";signals.push(...i);dataSignals.push(dname);scaleTriggers.push({scaleName:model.scaleName(channel),expr:`(!isArray(${dname}) || `+`(${scaleType}invert(${scaleName}, ${proj})[0] === ${scaleType}${dname}[0] && `+`${scaleType}invert(${scaleName}, ${proj})[1] === ${scaleType}${dname}[1]))`})}});
!hasScales&&scaleTriggers.length&&signals.push({name:name+"_scale_trigger",value:{},on:[{events:scaleTriggers.map(t=>({scale:t.scaleName})),update:`${scaleTriggers.map(t=>t.expr).join(" \x26\x26 ")} ? ${name+"_scale_trigger"} : {}`}]});fieldsSg=`unit: ${unitName(model)}, fields: ${fieldsSg}, values`;return signals.concat({name:name+"_tuple",...(init?{init:`{${fieldsSg}: ${assembleInit(init)}}`}:{}),...(dataSignals.length?{on:[{events:[{signal:dataSignals.join(" || ")}],update:`${dataSignals.join(" \x26\x26 ")} ? {${fieldsSg}: [${dataSignals}]} : null`}]}:
{})})},marks:(model,selCmpt,marks)=>{const name=selCmpt.name,{x,y}=selCmpt.project.hasChannel,xvname=x?.signals.visual,yvname=y?.signals.visual,store=`data(${vega.stringValue(selCmpt.name+"_store")})`;if(scaleBindings.defined(selCmpt)||!x&&!y)return marks;const update={x:void 0!==x?{signal:`${xvname}[0]`}:{value:0},y:void 0!==y?{signal:`${yvname}[0]`}:{value:0},x2:void 0!==x?{signal:`${xvname}[1]`}:{field:{group:"width"}},y2:void 0!==y?{signal:`${yvname}[1]`}:{field:{group:"height"}}};if("global"===
selCmpt.resolve)for(const key of keys$jscomp$0(update))update[key]=[{test:`${store}.length && ${store}[0].unit === ${unitName(model)}`,...update[key]},{value:0}];const {fill,fillOpacity,cursor,...stroke}=selCmpt.mark;model=keys$jscomp$0(stroke).reduce((def,k)=>{def[k]=[{test:[void 0!==x&&`${xvname}[0] !== ${xvname}[1]`,void 0!==y&&`${yvname}[0] !== ${yvname}[1]`].filter(t=>t).join(" \x26\x26 "),value:stroke[k]},{value:null}];return def},{});return[{name:`${name+"_brush"}_bg`,type:"rect",clip:!0,encode:{enter:{fill:{value:fill},
fillOpacity:{value:fillOpacity}},update}},...marks,{name:name+"_brush",type:"rect",clip:!0,encode:{enter:{...(cursor?{cursor:{value:cursor}}:{}),fill:{value:"transparent"}},update:{...update,...model}}}]}},{defined:()=>!0,parse:(model,selCmpt,selDef)=>{const name=selCmpt.name,proj=selCmpt.project??(selCmpt.project=new SelectionProjectionComponent),parsed={},timeUnits={},signals=new Set,signalName=(p,range)=>{p="visual"===range?p.channel:p.field;let sg=varName(`${name}_${p}`);for(let counter=1;signals.has(sg);counter++)sg=
varName(`${name}_${p}_${counter}`);signals.add(sg);return{[range]:sg}},type=selCmpt.type;var cfg=model.config.selection[type];const init=void 0!==selDef.value?vega.array(selDef.value):null;let {fields,encodings}=vega.isObject(selDef.select)?selDef.select:{};if(!fields&&!encodings&&init)for(var initVal of init)if(vega.isObject(initVal))for(const key of keys$jscomp$0(initVal))SINGLE_DEF_UNIT_CHANNEL_INDEX[key]?(encodings||(encodings=[])).push(key):"interval"===type?(warn('Interval selections should be initialized using "x" and/or "y" keys.'),
encodings=cfg.encodings):(fields||(fields=[])).push(key);fields||encodings||(encodings=cfg.encodings,"fields"in cfg&&(fields=cfg.fields));for(const channel of encodings??[])(cfg=model.fieldDef(channel))?(selDef=cfg.field,cfg.aggregate?warn(`Cannot project a selection on encoding channel "${channel}" as it uses an aggregate function ("${cfg.aggregate}").`):selDef?(cfg.timeUnit&&(selDef=model.vgField(channel),initVal={timeUnit:cfg.timeUnit,as:selDef,field:cfg.field},timeUnits[hash(initVal)]=initVal),
parsed[selDef]||(initVal="E","interval"===type?(cfg=model.getScaleComponent(channel).get("type"),hasContinuousDomain(cfg)&&(initVal="R")):cfg.bin&&(initVal="R-RE"),cfg={field:selDef,channel,type:initVal},cfg.signals={...signalName(cfg,"data"),...signalName(cfg,"visual")},proj.items.push(parsed[selDef]=cfg),proj.hasField[selDef]=proj.hasChannel[channel]=parsed[selDef],proj.hasSelectionId=proj.hasSelectionId||"_vgsid_"===selDef)):warn(cannotProjectOnChannelWithoutField(channel))):warn(cannotProjectOnChannelWithoutField(channel));
for(const field of fields??[])proj.hasField[field]||(model={type:"E",field},model.signals={...signalName(model,"data")},proj.items.push(model),proj.hasField[field]=model,proj.hasSelectionId=proj.hasSelectionId||"_vgsid_"===field);init&&(selCmpt.init=init.map(v=>proj.items.map(p=>vega.isObject(v)?void 0!==v[p.channel]?v[p.channel]:v[p.field]:v)));isEmpty(timeUnits)||(proj.timeUnit=new TimeUnitNode(null,timeUnits))},signals:(model,selCmpt,allSignals)=>{const name=selCmpt.name+"_tuple_fields";return 0<
allSignals.filter(s=>s.name===name).length||selCmpt.project.hasSelectionId?allSignals:allSignals.concat({name,value:selCmpt.project.items.map(proj=>{const {signals,hasLegend,...rest}=proj;rest.field=replacePathInField(rest.field);return rest})})}},toggle,inputBindings,scaleBindings,legendBindings,{defined:selCmpt=>void 0!==selCmpt.clear&&!1!==selCmpt.clear,parse:(model,selCmpt)=>{selCmpt.clear&&(selCmpt.clear=vega.isString(selCmpt.clear)?vega.parseSelector(selCmpt.clear,"view"):selCmpt.clear)},topLevelSignals:(model,
selCmpt,signals)=>{if(inputBindings.defined(selCmpt))for(const proj of selCmpt.project.items)model=signals.findIndex(n=>n.name===varName(`${selCmpt.name}_${proj.field}`)),-1!==model&&signals[model].on.push({events:selCmpt.clear,update:"null"});return signals},signals:(model,selCmpt,signals)=>{function addClear(idx,update){-1!==idx&&signals[idx].on&&signals[idx].on.push({events:selCmpt.clear,update})}if("interval"===selCmpt.type)for(const proj of selCmpt.project.items)model=signals.findIndex(n=>n.name===
proj.signals.visual),addClear(model,"[0, 0]"),-1===model&&(model=signals.findIndex(n=>n.name===proj.signals.data),addClear(model,"null"));else model=signals.findIndex(n=>n.name===selCmpt.name+"_tuple"),addClear(model,"null"),toggle.defined(selCmpt)&&(model=signals.findIndex(n=>n.name===selCmpt.name+"_toggle"),addClear(model,"false"));return signals}},{defined:selCmpt=>"interval"===selCmpt.type&&selCmpt.translate,signals:(model,selCmpt,signals)=>{const name=selCmpt.name,hasScales=scaleBindings.defined(selCmpt),
anchor=name+"_translate_anchor",{x,y}=selCmpt.project.hasChannel;let events=vega.parseSelector(selCmpt.translate,"scope");hasScales||(events=events.map(e=>(e.between[0].markname=name+"_brush",e)));signals.push({name:anchor,value:{},on:[{events:events.map(e=>e.between[0]),update:"{x: x(unit), y: y(unit)"+(void 0!==x?`, extent_x: ${hasScales?domain$jscomp$0(model,"x"):`slice(${x.signals.visual})`}`:"")+(void 0!==y?`, extent_y: ${hasScales?domain$jscomp$0(model,"y"):`slice(${y.signals.visual})`}`:"")+
"}"}]},{name:name+"_translate_delta",value:{},on:[{events,update:`{x: ${anchor}.x - x(unit), y: ${anchor}.y - y(unit)}`}]});void 0!==x&&onDelta$1(model,selCmpt,x,"width",signals);void 0!==y&&onDelta$1(model,selCmpt,y,"height",signals);return signals}},{defined:selCmpt=>"interval"===selCmpt.type&&selCmpt.zoom,signals:(model,selCmpt,signals)=>{const name=selCmpt.name,hasScales=scaleBindings.defined(selCmpt),delta=name+"_zoom_delta",{x,y}=selCmpt.project.hasChannel,sx=vega.stringValue(model.scaleName("x")),
sy=vega.stringValue(model.scaleName("y"));let events=vega.parseSelector(selCmpt.zoom,"scope");hasScales||(events=events.map(e=>(e.markname=name+"_brush",e)));signals.push({name:name+"_zoom_anchor",on:[{events,update:hasScales?"{"+[sx?`x: invert(${sx}, x(unit))`:"",sy?`y: invert(${sy}, y(unit))`:""].filter(expr=>!!expr).join(", ")+"}":"{x: x(unit), y: y(unit)}"}]},{name:delta,on:[{events,force:!0,update:"pow(1.001, event.deltaY * pow(16, event.deltaMode))"}]});void 0!==x&&onDelta(model,selCmpt,x,"width",
signals);void 0!==y&&onDelta(model,selCmpt,y,"height",signals);return signals}},nearest];class FilterNode extends DataFlowNode{clone(){return new FilterNode(null,this.model,duplicate(this.filter))}constructor(parent,model,filter){super(parent);this.model=model;this.filter=filter;_defineProperty(this,"expr",void 0);_defineProperty(this,"_dependentFields",void 0);this.expr=expression$jscomp$0(this.model,this.filter,this);this._dependentFields=getDependentFields(this.expr)}dependentFields(){return this._dependentFields}producedFields(){return new Set}assemble(){return{type:"filter",
expr:this.expr}}hash(){return`Filter ${this.expr}`}}const axisRules={scale:_ref=>{let {model,channel}=_ref;return model.scaleName(channel)},format:_ref2=>{let {fieldOrDatumDef,config,axis}=_ref2;const {format,formatType}=axis;return guideFormat(fieldOrDatumDef,fieldOrDatumDef.type,format,formatType,config,!0)},formatType:_ref3=>{let {axis,fieldOrDatumDef,scaleType}=_ref3;({formatType:_ref3}=axis);return guideFormatType(_ref3,fieldOrDatumDef,scaleType)},grid:_ref4=>{let {fieldOrDatumDef,axis,scaleType}=
_ref4;var JSCompiler_temp;return null!=(JSCompiler_temp=axis.grid)?JSCompiler_temp:!hasDiscreteDomain(scaleType)&&isFieldDef(fieldOrDatumDef)&&!isBinning(fieldOrDatumDef?.bin)&&!isBinned(fieldOrDatumDef?.bin)},gridScale:_ref5=>{let {model,channel}=_ref5;_ref5="x"===channel?"y":"x";_ref5=model.getScaleComponent(_ref5)?model.scaleName(_ref5):void 0;return _ref5},labelAlign:_ref6=>{let {axis,labelAngle,orient,channel}=_ref6;return axis.labelAlign||defaultLabelAlign(labelAngle,orient,channel)},labelAngle:_ref7=>
{({labelAngle:_ref7}=_ref7);return _ref7},labelBaseline:_ref8=>{let {axis,labelAngle,orient,channel}=_ref8;return axis.labelBaseline||defaultLabelBaseline(labelAngle,orient,channel)},labelFlush:_ref9=>{let {axis,fieldOrDatumDef,channel}=_ref9;null==(_ref9=axis.labelFlush)&&(_ref9="x"===channel&&contains(["quantitative","temporal"],fieldOrDatumDef.type)?!0:void 0);return _ref9},labelOverlap:_ref10=>{let {axis,fieldOrDatumDef,scaleType}=_ref10;if(null==(_ref10=axis.labelOverlap)){_ref10=fieldOrDatumDef.type;
var hasTimeUnit=isFieldDef(fieldOrDatumDef)&&!!fieldOrDatumDef.timeUnit,sort=isFieldDef(fieldOrDatumDef)?fieldOrDatumDef.sort:void 0;_ref10=hasTimeUnit&&!vega.isObject(sort)||"nominal"!==_ref10&&"ordinal"!==_ref10?"log"===scaleType||"symlog"===scaleType?"greedy":!0:void 0}return _ref10},orient:_ref11=>{({orient:_ref11}=_ref11);return _ref11},tickCount:_ref12=>{let {channel,model,axis,fieldOrDatumDef:fieldOrDatumDef$jscomp$0,scaleType:scaleType$jscomp$0}=_ref12;_ref12=(_ref12="x"===channel?"width":
"y"===channel?"height":void 0)?model.getSizeSignalRef(_ref12):void 0;var JSCompiler_temp;if(null!=(JSCompiler_temp=axis.tickCount))_ref12=JSCompiler_temp;else a:{let {fieldOrDatumDef,scaleType,size,values:vals}={fieldOrDatumDef:fieldOrDatumDef$jscomp$0,scaleType:scaleType$jscomp$0,size:_ref12,values:axis.values};if(vals||hasDiscreteDomain(scaleType)||"log"===scaleType)_ref12=void 0;else{if(isFieldDef(fieldOrDatumDef)){if(isBinning(fieldOrDatumDef.bin)){_ref12={signal:`ceil(${size.signal}/10)`};break a}if(fieldOrDatumDef.timeUnit&&
contains(["month","hours","day","quarter"],normalizeTimeUnit(fieldOrDatumDef.timeUnit)?.unit)){_ref12=void 0;break a}}_ref12={signal:`ceil(${size.signal}/40)`}}}return _ref12},title:_ref13=>{let {axis,model,channel}=_ref13;if(void 0!==axis.title)return axis.title;_ref13=getFieldDefTitle(model,channel);if(void 0!==_ref13)return _ref13;_ref13=model.typedFieldDef(channel);const fieldDef2=model.fieldDef("x"===channel?"x2":"y2");return mergeTitleFieldDefs(_ref13?[toFieldDefBase(_ref13)]:[],isFieldDef(fieldDef2)?
[toFieldDefBase(fieldDef2)]:[])},values:_ref14=>{let {axis,fieldOrDatumDef}=_ref14;_ref14=axis.values;_ref14=vega.isArray(_ref14)?valueArray(fieldOrDatumDef,_ref14):isSignalRef(_ref14)?_ref14:void 0;return _ref14},zindex:_ref15=>{let {axis,fieldOrDatumDef,mark}=_ref15;null==(_ref15=axis.zindex)&&(_ref15="rect"===mark&&isDiscrete(fieldOrDatumDef)?1:0);return _ref15}};class CalculateNode extends DataFlowNode{clone(){return new CalculateNode(null,duplicate(this.transform))}constructor(parent,transform){super(parent);
this.transform=transform;_defineProperty(this,"_dependentFields",void 0);this._dependentFields=getDependentFields(this.transform.calculate)}static parseAllForSortIndex(parent,model){model.forEachFieldDef((fieldDef,channel)=>{if(isScaleFieldDef(fieldDef)&&isSortArray(fieldDef.sort)){const {field,timeUnit}=fieldDef;var sort=fieldDef.sort;sort=sort.map((sortValue,i)=>`${fieldFilterExpression({field,timeUnit,equal:sortValue})} ? ${i} : `).join("")+sort.length;parent=new CalculateNode(parent,{calculate:sort,
as:sortArrayIndexField(fieldDef,channel,{forAs:!0})})}});return parent}producedFields(){return new Set([this.transform.as])}dependentFields(){return this._dependentFields}assemble(){return{type:"formula",expr:this.transform.calculate,as:this.transform.as}}hash(){return`Calculate ${hash(this.transform)}`}}const HEADER_CHANNELS=["row","column"],HEADER_TYPES=["header","footer"],LAYOUT_TITLE_BAND={column:{start:0,end:1},row:{start:1,end:0}},LEGEND_COMPONENT_PROPERTIES=keys$jscomp$0({aria:1,clipHeight:1,
columnPadding:1,columns:1,cornerRadius:1,description:1,direction:1,fillColor:1,format:1,formatType:1,gradientLength:1,gradientOpacity:1,gradientStrokeColor:1,gradientStrokeWidth:1,gradientThickness:1,gridAlign:1,labelAlign:1,labelBaseline:1,labelColor:1,labelFont:1,labelFontSize:1,labelFontStyle:1,labelFontWeight:1,labelLimit:1,labelOffset:1,labelOpacity:1,labelOverlap:1,labelPadding:1,labelSeparation:1,legendX:1,legendY:1,offset:1,orient:1,padding:1,rowPadding:1,strokeColor:1,symbolDash:1,symbolDashOffset:1,
symbolFillColor:1,symbolLimit:1,symbolOffset:1,symbolOpacity:1,symbolSize:1,symbolStrokeColor:1,symbolStrokeWidth:1,symbolType:1,tickCount:1,tickMinStep:1,title:1,titleAlign:1,titleAnchor:1,titleBaseline:1,titleColor:1,titleFont:1,titleFontSize:1,titleFontStyle:1,titleFontWeight:1,titleLimit:1,titleLineHeight:1,titleOpacity:1,titleOrient:1,titlePadding:1,type:1,values:1,zindex:1,disable:1,labelExpr:1,selections:1,opacity:1,shape:1,stroke:1,fill:1,size:1,strokeWidth:1,strokeDash:1,encode:1});class LegendComponent extends Split{}
const legendEncodeRules={symbols:function(symbolsSpec,_ref){let {fieldOrDatumDef,model,channel,legendCmpt,legendType}=_ref;if("symbol"===legendType){var {markDef,encoding,config,mark}=model;_ref=markDef.filled&&"trail"!==mark;var e={};for(var property of FILL_STROKE_CONFIG){var value=getMarkConfig(property,model.markDef,model.config);void 0!==value&&(e[property]=signalOrValueRef(value))}property={...e,...color$jscomp$0(model,{filled:_ref})};e=legendCmpt.get("symbolOpacity")??config.legend.symbolOpacity;
var symbolFillColor=legendCmpt.get("symbolFillColor")??config.legend.symbolFillColor;value=legendCmpt.get("symbolStrokeColor")??config.legend.symbolStrokeColor;e=void 0===e?getMaxValue(encoding.opacity)??markDef.opacity:void 0;property.fill&&("fill"===channel||_ref&&"color"===channel?delete property.fill:property.fill.field?symbolFillColor?delete property.fill:(property.fill=signalOrValueRef(config.legend.symbolBaseFillColor??"black"),property.fillOpacity=signalOrValueRef(e??1)):vega.isArray(property.fill)&&
(symbolFillColor=getFirstConditionValue(encoding.fill??encoding.color)??markDef.fill??(_ref&&markDef.color))&&(property.fill=signalOrValueRef(symbolFillColor)));property.stroke&&("stroke"===channel||!_ref&&"color"===channel?delete property.stroke:property.stroke.field||value?delete property.stroke:vega.isArray(property.stroke)&&(_ref=getFirstDefined(getFirstConditionValue(encoding.stroke||encoding.color),markDef.stroke,_ref?markDef.color:void 0))&&(property.stroke={value:_ref}));"opacity"!==channel&&
((_ref=isFieldDef(fieldOrDatumDef)&&selectedCondition(model,legendCmpt,fieldOrDatumDef))?property.opacity=[{test:_ref,...signalOrValueRef(e??1)},signalOrValueRef(config.legend.unselectedOpacity)]:e&&(property.opacity=signalOrValueRef(e)));property={...property,...symbolsSpec};return isEmpty(property)?void 0:property}},gradient:function(gradientSpec,_ref2){let {model,legendType,legendCmpt}=_ref2;if("gradient"===legendType){var {config,markDef,encoding}=model;_ref2={};var opacity=void 0===(legendCmpt.get("gradientOpacity")??
config.legend.gradientOpacity)?getMaxValue(encoding.opacity)||markDef.opacity:void 0;opacity&&(_ref2.opacity=signalOrValueRef(opacity));_ref2={..._ref2,...gradientSpec};return isEmpty(_ref2)?void 0:_ref2}},labels:function(specifiedlabelsSpec,_ref3){let {fieldOrDatumDef,model,channel,legendCmpt}=_ref3;var legend=model.legend(channel)||{};_ref3=model.config;var condition=isFieldDef(fieldOrDatumDef)?selectedCondition(model,legendCmpt,fieldOrDatumDef):void 0;condition=condition?[{test:condition,value:1},
{value:_ref3.legend.unselectedOpacity}]:void 0;const {format,formatType}=legend;legend=void 0;isCustomFormatType(formatType)?legend=formatCustomType({fieldOrDatumDef,field:"datum.value",format,formatType,config:_ref3}):void 0===format&&void 0===formatType&&_ref3.customFormatTypes&&("quantitative"===fieldOrDatumDef.type&&_ref3.numberFormatType?legend=formatCustomType({fieldOrDatumDef,field:"datum.value",format:_ref3.numberFormat,formatType:_ref3.numberFormatType,config:_ref3}):"temporal"===fieldOrDatumDef.type&&
_ref3.timeFormatType&&isFieldDef(fieldOrDatumDef)&&void 0===fieldOrDatumDef.timeUnit&&(legend=formatCustomType({fieldOrDatumDef,field:"datum.value",format:_ref3.timeFormat,formatType:_ref3.timeFormatType,config:_ref3})));specifiedlabelsSpec={...(condition?{opacity:condition}:{}),...(legend?{text:legend}:{}),...specifiedlabelsSpec};return isEmpty(specifiedlabelsSpec)?void 0:specifiedlabelsSpec},entries:function(entriesSpec,_ref4){({legendCmpt:_ref4}=_ref4);return _ref4.get("selections")?.length?{...entriesSpec,
fill:{value:"transparent"}}:entriesSpec}},legendRules={direction:_ref=>{({direction:_ref}=_ref);return _ref},format:_ref2=>{let {fieldOrDatumDef,legend,config}=_ref2;const {format,formatType}=legend;return guideFormat(fieldOrDatumDef,fieldOrDatumDef.type,format,formatType,config,!1)},formatType:_ref3=>{let {legend,fieldOrDatumDef,scaleType}=_ref3;({formatType:_ref3}=legend);return guideFormatType(_ref3,fieldOrDatumDef,scaleType)},gradientLength:params=>{const {legend,legendConfig}=params;var JSCompiler_temp;
if(null!=(JSCompiler_temp=legend.gradientLength??legendConfig.gradientLength))params=JSCompiler_temp;else{{let {legendConfig,model,direction,orient,scaleType}=params;const {gradientHorizontalMaxLength,gradientHorizontalMinLength,gradientVerticalMaxLength,gradientVerticalMinLength}=legendConfig;params=CONTINUOUS_TO_CONTINUOUS_SCALES.has(scaleType)?"horizontal"===direction?"top"===orient||"bottom"===orient?gradientLengthSignal(model,"width",gradientHorizontalMinLength,gradientHorizontalMaxLength):gradientHorizontalMinLength:
gradientLengthSignal(model,"height",gradientVerticalMinLength,gradientVerticalMaxLength):void 0}}return params},labelOverlap:_ref4=>{let {legend,legendConfig,scaleType}=_ref4;null==(_ref4=legend.labelOverlap??legendConfig.labelOverlap)&&(_ref4=contains(["quantile","threshold","log","symlog"],scaleType)?"greedy":void 0);return _ref4},symbolType:_ref5=>{let {legend,markDef,channel,encoding}=_ref5;if(null==(_ref5=legend.symbolType))a:{_ref5=markDef.type;var markShape=markDef.shape;if("shape"!==channel&&
(markShape=getFirstConditionValue(encoding.shape)??markShape)){_ref5=markShape;break a}switch(_ref5){case "bar":case "rect":case "image":case "square":_ref5="square";break a;case "line":case "trail":case "rule":_ref5="stroke";break a;case "arc":case "point":case "circle":case "tick":case "geoshape":case "area":case "text":_ref5="circle";break a}_ref5=void 0}return _ref5},title:_ref6=>{let {fieldOrDatumDef,config}=_ref6;return title$jscomp$0(fieldOrDatumDef,config,{allowDisabling:!0})},type:_ref7=>
{let {legendType,scaleType,channel}=_ref7;if(isColorChannel(channel)&&CONTINUOUS_TO_CONTINUOUS_SCALES.has(scaleType)){if("gradient"===legendType)return}else if("symbol"===legendType)return;return legendType},values:_ref8=>{let {fieldOrDatumDef,legend}=_ref8;_ref8=legend.values;_ref8=vega.isArray(_ref8)?valueArray(fieldOrDatumDef,_ref8):isSignalRef(_ref8)?_ref8:void 0;return _ref8}},PROJECTION_PROPERTIES="type clipAngle clipExtent center rotate precision reflectX reflectY coefficient distance fraction lobes parallel radius ratio spacing tilt".split(" ");
class ProjectionComponent extends Split{constructor(name,specifiedProjection,size,data){super({...specifiedProjection},{name});this.specifiedProjection=specifiedProjection;this.size=size;this.data=data;_defineProperty(this,"merged",!1)}get isFit(){return!!this.data}}class BinNode extends DataFlowNode{clone(){return new BinNode(null,duplicate(this.bins))}constructor(parent,bins){super(parent);this.bins=bins}static makeFromEncoding(parent,model){const bins=model.reduceFieldDef((binComponentIndex,fieldDef,
channel)=>{if(isTypedFieldDef(fieldDef)&&isBinning(fieldDef.bin)){const {key,binComponent}=createBinComponent(fieldDef,fieldDef.bin,model);var JSCompiler_temp_const={...binComponentIndex[key]};var config=model.config;if(binRequiresRange(fieldDef,channel)){channel=isUnitModel(model)?model.axis(channel)??model.legend(channel)??{}:{};const startField=vgField(fieldDef,{expr:"datum"}),endField=vgField(fieldDef,{expr:"datum",binSuffix:"end"});fieldDef={formulaAs:vgField(fieldDef,{binSuffix:"range",forAs:!0}),
formula:binFormatExpression(startField,endField,channel.format,channel.formatType,config)}}else fieldDef={};binComponentIndex[key]={...binComponent,...JSCompiler_temp_const,...fieldDef}}return binComponentIndex},{});return isEmpty(bins)?null:new BinNode(parent,bins)}static makeFromTransform(parent,t,model){const {key,binComponent}=createBinComponent(t,t.bin,model);return new BinNode(parent,{[key]:binComponent})}merge(other,renameSignal){for(const key of keys$jscomp$0(other.bins))key in this.bins?
(renameSignal(other.bins[key].signal,this.bins[key].signal),this.bins[key].as=unique([...this.bins[key].as,...other.bins[key].as],hash)):this.bins[key]=other.bins[key];for(const child of other.children)other.removeChild(child),child.parent=this;other.remove()}producedFields(){return new Set(vals$jscomp$0(this.bins).map(c=>c.as).flat(2))}dependentFields(){return new Set(vals$jscomp$0(this.bins).map(c=>c.field))}hash(){return`Bin ${hash(this.bins)}`}assemble(){return vals$jscomp$0(this.bins).flatMap(bin=>
{const transform=[],[binAs,...remainingAs]=bin.as,{extent,...params}=bin.bin;var binTrans={type:"bin",field:replacePathInField(bin.field),as:binAs,signal:bin.signal,...(extent?.param?{extent:null}:{extent}),...(bin.span?{span:{signal:`span(${bin.span})`}}:{}),...params};!extent&&bin.extentSignal&&(transform.push({type:"extent",field:replacePathInField(bin.field),signal:bin.extentSignal}),binTrans.extent={signal:bin.extentSignal});transform.push(binTrans);for(const as of remainingAs)for(binTrans=0;2>
binTrans;binTrans++)transform.push({type:"formula",expr:vgField({field:binAs[binTrans]},{expr:"datum"}),as:as[binTrans]});bin.formula&&transform.push({type:"formula",expr:bin.formula,as:bin.formulaAs});return transform})}}class AggregateNode extends DataFlowNode{clone(){return new AggregateNode(null,new Set(this.dimensions),duplicate(this.measures))}constructor(parent,dimensions,measures){super(parent);this.dimensions=dimensions;this.measures=measures}get groupBy(){return this.dimensions}static makeFromEncoding(parent,
model){let isAggregate=!1;model.forEachFieldDef(fd=>{fd.aggregate&&(isAggregate=!0)});const meas={},dims=new Set;if(!isAggregate)return null;model.forEachFieldDef((fieldDef,channel)=>{const {aggregate,field}=fieldDef;if(aggregate)if("count"===aggregate)meas["*"]??(meas["*"]={}),meas["*"].count=new Set([vgField(fieldDef,{forAs:!0})]);else{if(isArgminDef(aggregate)||isArgmaxDef(aggregate)){fieldDef=isArgminDef(aggregate)?"argmin":"argmax";var argField=aggregate[fieldDef];meas[argField]??(meas[argField]=
{});meas[argField][fieldDef]=new Set([vgField({op:fieldDef,field:argField},{forAs:!0})])}else meas[field]??(meas[field]={}),meas[field][aggregate]=new Set([vgField(fieldDef,{forAs:!0})]);SCALE_CHANNEL_INDEX[channel]&&"unaggregated"===model.scaleDomain(channel)&&(meas[field]??(meas[field]={}),meas[field].min=new Set([vgField({field,aggregate:"min"},{forAs:!0})]),meas[field].max=new Set([vgField({field,aggregate:"max"},{forAs:!0})]))}else{argField=isUnitModel(model)?model.encoding[getSecondaryRangeChannel(channel)]:
void 0;isTypedFieldDef(fieldDef)&&isUnitModel(model)&&hasBandEnd(fieldDef,argField,model.markDef,model.config)?(dims.add(vgField(fieldDef,{})),dims.add(vgField(fieldDef,{suffix:"end"})),fieldDef.bin&&binRequiresRange(fieldDef,channel)&&dims.add(vgField(fieldDef,{binSuffix:"range"}))):channel in GEO_POSIITON_CHANNEL_INDEX?(channel=getPositionChannelFromLatLong(channel),dims.add(model.getName(channel))):dims.add(vgField(fieldDef));if(channel=isScaleFieldDef(fieldDef))channel=fieldDef.scale?.range,channel=
vega.isObject(channel)&&"field"in channel;channel&&dims.add(fieldDef.scale.range.field)}});return 0===dims.size+keys$jscomp$0(meas).length?null:new AggregateNode(parent,dims,meas)}static makeFromTransform(parent,t){const dims=new Set,meas={};for(const s of t.aggregate){const {op,field,as}=s;if(op)if("count"===op){let $jscomp$logical$assign$tmp730812712$16;($jscomp$logical$assign$tmp730812712$16=meas)["*"]??($jscomp$logical$assign$tmp730812712$16["*"]={});meas["*"].count=new Set([as?as:vgField(s,{forAs:!0})])}else{let $jscomp$logical$assign$tmp730812712$17,
$jscomp$logical$assign$tmpindex730812712$17;($jscomp$logical$assign$tmp730812712$17=meas)[$jscomp$logical$assign$tmpindex730812712$17=field]??($jscomp$logical$assign$tmp730812712$17[$jscomp$logical$assign$tmpindex730812712$17]={});meas[field][op]=new Set([as?as:vgField(s,{forAs:!0})])}}for(const s of t.groupby??[])dims.add(s);return 0===dims.size+keys$jscomp$0(meas).length?null:new AggregateNode(parent,dims,meas)}merge(other){if(setEqual(this.dimensions,other.dimensions)){var parentMeasures=this.measures;
other=other.measures;for(const field of keys$jscomp$0(other)){const ops=other[field];for(const op of keys$jscomp$0(ops))field in parentMeasures?parentMeasures[field][op]=new Set([...(parentMeasures[field][op]??[]),...ops[op]]):parentMeasures[field]={[op]:ops[op]}}return!0}debug("different dimensions, cannot merge");return!1}addDimensions(fields){fields.forEach(this.dimensions.add,this.dimensions)}dependentFields(){return new Set([...this.dimensions,...keys$jscomp$0(this.measures)])}producedFields(){const out=
new Set;for(const field of keys$jscomp$0(this.measures))for(const op of keys$jscomp$0(this.measures[field])){const m=this.measures[field][op];0===m.size?out.add(`${op}_${field}`):m.forEach(out.add,out)}return out}hash(){return`Aggregate ${hash({dimensions:this.dimensions,measures:this.measures})}`}assemble(){const ops=[],fields=[],as=[];for(const field of keys$jscomp$0(this.measures))for(const op of keys$jscomp$0(this.measures[field]))for(const alias of this.measures[field][op])as.push(alias),ops.push(op),
fields.push("*"===field?null:replacePathInField(field));return{type:"aggregate",groupby:[...this.dimensions].map(replacePathInField),ops,fields,as}}}class FacetNode extends DataFlowNode{constructor(parent,model,name,data){super(parent);this.model=model;this.name=name;this.data=data;_defineProperty(this,"column",void 0);_defineProperty(this,"row",void 0);_defineProperty(this,"facet",void 0);_defineProperty(this,"childModel",void 0);for(const channel of FACET_CHANNELS)if(parent=model.facet[channel]){const {bin,
sort}=parent;this[channel]={name:model.getName(`${channel}_domain`),fields:[vgField(parent),...(isBinning(bin)?[vgField(parent,{binSuffix:"end"})]:[])],...(isSortField(sort)?{sortField:sort}:vega.isArray(sort)?{sortIndexField:sortArrayIndexField(parent,channel)}:{})}}this.childModel=model.child}hash(){let out="Facet";for(const channel of FACET_CHANNELS)this[channel]&&(out+=` ${channel.charAt(0)}:${hash(this[channel])}`);return out}get fields(){const f=[];for(const channel of FACET_CHANNELS)this[channel]?.fields&&
f.push(...this[channel].fields);return f}dependentFields(){const depFields=new Set(this.fields);for(const channel of FACET_CHANNELS)this[channel]&&(this[channel].sortField&&depFields.add(this[channel].sortField.field),this[channel].sortIndexField&&depFields.add(this[channel].sortIndexField));return depFields}producedFields(){return new Set}getSource(){return this.name}getChildIndependentFieldsWithStep(){const childIndependentFieldsWithStep={};for(const channel of POSITION_SCALE_CHANNELS){var childScaleComponent=
this.childModel.component.scales[channel];if(childScaleComponent&&!childScaleComponent.merged){var type=childScaleComponent.get("type");childScaleComponent=childScaleComponent.get("range");hasDiscreteDomain(type)&&isVgRangeStep(childScaleComponent)&&(type=assembleDomain(this.childModel,channel),(type=getFieldFromDomain(type))?childIndependentFieldsWithStep[channel]=type:warn(unknownField(channel)))}}return childIndependentFieldsWithStep}assembleRowColumnHeaderData(channel,crossedDataName,childIndependentFieldsWithStep){const childChannel=
{row:"y",column:"x",facet:void 0}[channel],fields=[],ops=[],as=[];childChannel&&childIndependentFieldsWithStep&&childIndependentFieldsWithStep[childChannel]&&(crossedDataName?(fields.push(`distinct_${childIndependentFieldsWithStep[childChannel]}`),ops.push("max")):(fields.push(childIndependentFieldsWithStep[childChannel]),ops.push("distinct")),as.push(`distinct_${childIndependentFieldsWithStep[childChannel]}`));const {sortField,sortIndexField}=this[channel];if(sortField){const {op="min",field}=sortField;
fields.push(field);ops.push(op);as.push(vgField(sortField,{forAs:!0}))}else sortIndexField&&(fields.push(sortIndexField),ops.push("max"),as.push(sortIndexField));return{name:this[channel].name,source:crossedDataName??this.data,transform:[{type:"aggregate",groupby:this[channel].fields,...(fields.length?{fields,ops,as}:{})}]}}assembleFacetHeaderData(childIndependentFieldsWithStep){const {columns}=this.model.layout,{layoutHeaders}=this.model.component,data=[],hasSharedAxis={};for(const headerChannel of HEADER_CHANNELS){for(const headerType of HEADER_TYPES){var headers=
(layoutHeaders[headerChannel]&&layoutHeaders[headerChannel][headerType])??[];for(const header of headers)if(0<header.axes?.length){hasSharedAxis[headerChannel]=!0;break}}hasSharedAxis[headerChannel]&&(headers=`length(data("${this.facet.name}"))`,data.push({name:`${this.facet.name}_${headerChannel}`,transform:[{type:"sequence",start:0,stop:"row"===headerChannel?columns?{signal:`ceil(${headers} / ${columns})`}:1:columns?{signal:`min(${headers}, ${columns})`}:{signal:headers}}]}))}const {row,column}=
hasSharedAxis;(row||column)&&data.unshift(this.assembleRowColumnHeaderData("facet",null,childIndependentFieldsWithStep));return data}assemble(){const data=[];var crossedDataName=null;const childIndependentFieldsWithStep=this.getChildIndependentFieldsWithStep(),{column,row,facet}=this;if(column&&row&&(childIndependentFieldsWithStep.x||childIndependentFieldsWithStep.y)){crossedDataName=`cross_${this.column.name}_${this.row.name}`;const fields=[].concat(childIndependentFieldsWithStep.x??[],childIndependentFieldsWithStep.y??
[]),ops=fields.map(()=>"distinct");data.push({name:crossedDataName,source:this.data,transform:[{type:"aggregate",groupby:this.fields,fields,ops}]})}for(const channel of["column","row"])this[channel]&&data.push(this.assembleRowColumnHeaderData(channel,crossedDataName,childIndependentFieldsWithStep));facet&&(crossedDataName=this.assembleFacetHeaderData(childIndependentFieldsWithStep))&&data.push(...crossedDataName);return data}}class ParseNode extends DataFlowNode{clone(){return new ParseNode(null,
duplicate(this._parse))}constructor(parent,parse){super(parent);_defineProperty(this,"_parse",void 0);this._parse=parse}hash(){return`Parse ${hash(this._parse)}`}static makeExplicit(parent,model,ancestorParse){let explicit={};model=model.data;!isGenerator(model)&&model?.format?.parse&&(explicit=model.format.parse);return this.makeWithAncestors(parent,explicit,{},ancestorParse)}static makeWithAncestors(parent,explicit,implicit,ancestorParse){for(var field of keys$jscomp$0(implicit)){const parsedAs=
ancestorParse.getWithExplicit(field);void 0!==parsedAs.value&&(parsedAs.explicit||parsedAs.value===implicit[field]||"derived"===parsedAs.value||"flatten"===implicit[field]?delete implicit[field]:warn(differentParse(field,implicit[field],parsedAs.value)))}for(var field$jscomp$0 of keys$jscomp$0(explicit))field=ancestorParse.get(field$jscomp$0),void 0!==field&&(field===explicit[field$jscomp$0]?delete explicit[field$jscomp$0]:warn(differentParse(field$jscomp$0,explicit[field$jscomp$0],field)));explicit=
new Split(explicit,implicit);ancestorParse.copyAll(explicit);implicit={};for(const key of keys$jscomp$0(explicit.combine()))field$jscomp$0=explicit.get(key),null!==field$jscomp$0&&(implicit[key]=field$jscomp$0);return 0===keys$jscomp$0(implicit).length||ancestorParse.parseNothing?null:new ParseNode(parent,implicit)}get parse(){return this._parse}merge(other){this._parse={...this._parse,...other.parse};other.remove()}assembleFormatParse(){const formatParse={};for(const field of keys$jscomp$0(this._parse)){const p=
this._parse[field];1===accessPathDepth(field)&&(formatParse[field]=p)}return formatParse}producedFields(){return new Set(keys$jscomp$0(this._parse))}dependentFields(){return new Set(keys$jscomp$0(this._parse))}assembleTransforms(){let onlyNested=0<arguments.length&&void 0!==arguments[0]?arguments[0]:!1;return keys$jscomp$0(this._parse).filter(field=>onlyNested?1<accessPathDepth(field):!0).map(field=>{const expr=parseExpression(field,this._parse[field]);return expr?{type:"formula",expr,as:removePathFromField(field)}:
null}).filter(t=>null!==t)}}class IdentifierNode extends DataFlowNode{clone(){return new IdentifierNode(null)}constructor(parent){super(parent)}dependentFields(){return new Set}producedFields(){return new Set(["_vgsid_"])}hash(){return"Identifier"}assemble(){return{type:"identifier",as:"_vgsid_"}}}class GraticuleNode extends DataFlowNode{clone(){return new GraticuleNode(null,this.params)}constructor(parent,params){super(parent);this.params=params}dependentFields(){return new Set}producedFields(){}hash(){return`Graticule ${hash(this.params)}`}assemble(){return{type:"graticule",
...(!0===this.params?{}:this.params)}}}class SequenceNode extends DataFlowNode{clone(){return new SequenceNode(null,this.params)}constructor(parent,params){super(parent);this.params=params}dependentFields(){return new Set}producedFields(){return new Set([this.params.as??"data"])}hash(){return`Hash ${hash(this.params)}`}assemble(){return{type:"sequence",...this.params}}}class SourceNode extends DataFlowNode{constructor(data){super(null);_defineProperty(this,"_data",void 0);_defineProperty(this,"_name",
void 0);_defineProperty(this,"_generator",void 0);data??(data={name:"source"});let format;isGenerator(data)||(format=data.format?{...omit(data.format,["parse"])}:{});if("values"in data)this._data={values:data.values};else if("url"in data){if(this._data={url:data.url},!format.type){let defaultExtension=/(?:\.([^.]+))?$/.exec(data.url)[1];contains(["json","csv","tsv","dsv","topojson"],defaultExtension)||(defaultExtension="json");format.type=defaultExtension}}else if("sphere"in data)this._data={values:[{type:"Sphere"}]};
else if(isNamedData(data)||isGenerator(data))this._data={};this._generator=isGenerator(data);data.name&&(this._name=data.name);format&&!isEmpty(format)&&(this._data.format=format)}dependentFields(){return new Set}producedFields(){}get data(){return this._data}hasName(){return!!this._name}get isGenerator(){return this._generator}get dataName(){return this._name}set dataName(name){this._name=name}set parent(parent){throw Error("Source nodes have to be roots.");}remove(){throw Error("Source nodes are roots and cannot be removed.");
}hash(){throw Error("Cannot hash sources");}assemble(){return{name:this._name,...this._data,transform:[]}}}var _modified=new WeakMap;class Optimizer{constructor(){if(_modified.has(this))throw new TypeError("Cannot initialize the same private elements twice on an object");_modified.set(this,{writable:!0,value:void 0});_classPrivateFieldSet(this,_modified,!1)}setModified(){_classPrivateFieldSet(this,_modified,!0)}get modifiedFlag(){var descriptor=_classExtractFieldDescriptor(this,_modified,"get");return descriptor.get?
descriptor.get.call(this):descriptor.value}}class BottomUpOptimizer extends Optimizer{getNodeDepths(node,depth,depths){depths.set(node,depth);for(const child of node.children)this.getNodeDepths(child,depth+1,depths);return depths}optimize(node){node=[...this.getNodeDepths(node,0,new Map).entries()].sort((a,b)=>b[1]-a[1]);for(const tuple of node)this.run(tuple[0]);return this.modifiedFlag}}class TopDownOptimizer extends Optimizer{optimize(node){this.run(node);for(const child of node.children)this.optimize(child);
return this.modifiedFlag}}class MergeIdenticalNodes extends TopDownOptimizer{mergeNodes(parent,nodes){const mergedNode=nodes.shift();for(const node of nodes)parent.removeChild(node),node.parent=mergedNode,node.remove()}run(node){const hashes=node.children.map(x=>x.hash()),buckets={};for(let i=0;i<hashes.length;i++)void 0===buckets[hashes[i]]?buckets[hashes[i]]=[node.children[i]]:buckets[hashes[i]].push(node.children[i]);for(const k of keys$jscomp$0(buckets))1<buckets[k].length&&(this.setModified(),
this.mergeNodes(node,buckets[k]))}}class RemoveUnnecessaryIdentifierNodes extends TopDownOptimizer{constructor(model){super();_defineProperty(this,"requiresSelectionId",void 0);this.requiresSelectionId=model&&requiresSelectionId(model)}run(node){!(node instanceof IdentifierNode)||this.requiresSelectionId&&(isDataSourceNode(node.parent)||node.parent instanceof AggregateNode||node.parent instanceof ParseNode)||(this.setModified(),node.remove())}}class RemoveDuplicateTimeUnits extends Optimizer{optimize(node){this.run(node,
new Set);return this.modifiedFlag}run(node,timeUnitFields){let producedFields=new Set;node instanceof TimeUnitNode&&(producedFields=node.producedFields(),hasIntersection(producedFields,timeUnitFields)&&(this.setModified(),node.removeFormulas(timeUnitFields),0===node.producedFields.length&&node.remove()));for(const child of node.children)this.run(child,new Set([...timeUnitFields,...producedFields]))}}class RemoveUnnecessaryOutputNodes extends TopDownOptimizer{constructor(){super()}run(node){node instanceof
OutputNode&&!node.isRequired()&&(this.setModified(),node.remove())}}class MoveParseUp extends BottomUpOptimizer{run(node){if(!(isDataSourceNode(node)||1<node.numChildren()))for(const child of node.children)child instanceof ParseNode&&(node instanceof ParseNode?(this.setModified(),node.merge(child)):fieldIntersection(node.producedFields(),child.dependentFields())||(this.setModified(),child.swapWithParent()))}}class MergeParse extends BottomUpOptimizer{run(node){const originalChildren=[...node.children];
var parseChildren=node.children.filter(child=>child instanceof ParseNode);if(1<node.numChildren()&&1<=parseChildren.length){const commonParse={};var conflictingParse=new Set;for(const parseNode of parseChildren){parseChildren=parseNode.parse;for(const k of keys$jscomp$0(parseChildren))k in commonParse?commonParse[k]!==parseChildren[k]&&conflictingParse.add(k):commonParse[k]=parseChildren[k]}for(const field of conflictingParse)delete commonParse[field];if(!isEmpty(commonParse)){this.setModified();
conflictingParse=new ParseNode(node,commonParse);for(const childNode of originalChildren){if(childNode instanceof ParseNode)for(const key of keys$jscomp$0(commonParse))delete childNode.parse[key];node.removeChild(childNode);childNode.parent=conflictingParse;childNode instanceof ParseNode&&0===keys$jscomp$0(childNode.parse).length&&childNode.remove()}}}}}class RemoveUnusedSubtrees extends BottomUpOptimizer{run(node){node instanceof OutputNode||0<node.numChildren()||node instanceof FacetNode||node instanceof
SourceNode||(this.setModified(),node.remove())}}class MergeTimeUnits extends BottomUpOptimizer{run(node){node=node.children.filter(x=>x instanceof TimeUnitNode);const combination=node.pop();for(const timeUnit of node)this.setModified(),combination.merge(timeUnit)}}class MergeAggregates extends BottomUpOptimizer{run(node){var aggChildren=node.children.filter(child=>child instanceof AggregateNode);const groupedAggregates={};for(var agg$jscomp$0 of aggChildren)aggChildren=hash(agg$jscomp$0.groupBy),
aggChildren in groupedAggregates||(groupedAggregates[aggChildren]=[]),groupedAggregates[aggChildren].push(agg$jscomp$0);for(const group of keys$jscomp$0(groupedAggregates))if(agg$jscomp$0=groupedAggregates[group],1<agg$jscomp$0.length){aggChildren=agg$jscomp$0.pop();for(const agg of agg$jscomp$0)aggChildren.merge(agg)&&(node.removeChild(agg),agg.parent=aggChildren,agg.remove(),this.setModified())}}}class MergeBins extends BottomUpOptimizer{constructor(model){super();this.model=model}run(node){var moveBinsUp=
!(isDataSourceNode(node)||node instanceof FilterNode||node instanceof ParseNode||node instanceof IdentifierNode);const promotableBins=[],remainingBins=[];for(const child of node.children)child instanceof BinNode&&(moveBinsUp&&!fieldIntersection(node.producedFields(),child.dependentFields())?promotableBins.push(child):remainingBins.push(child));if(0<promotableBins.length){moveBinsUp=promotableBins.pop();for(const bin of promotableBins)moveBinsUp.merge(bin,this.model.renameSignal.bind(this.model));
this.setModified();node instanceof BinNode?node.merge(moveBinsUp,this.model.renameSignal.bind(this.model)):moveBinsUp.swapWithParent()}if(1<remainingBins.length){node=remainingBins.pop();for(const bin of remainingBins)node.merge(bin,this.model.renameSignal.bind(this.model));this.setModified()}}}class MergeOutputs extends BottomUpOptimizer{run(node){var children=[...node.children];if(some(children,child=>child instanceof OutputNode)&&!(1>=node.numChildren())){var otherChildren=[];for(const child of children)if(child instanceof
OutputNode){for(children=child;1===children.numChildren();){const [theChild]=children.children;if(theChild instanceof OutputNode)children=theChild;else break}otherChildren.push(...children.children);if(mainOutput)node.removeChild(child),child.parent=mainOutput.parent,mainOutput.parent.removeChild(mainOutput),mainOutput.parent=children,this.setModified();else var mainOutput=children}else otherChildren.push(child);if(otherChildren.length){this.setModified();for(const child of otherChildren)child.parent.removeChild(child),
child.parent=mainOutput}}}}class JoinAggregateTransformNode extends DataFlowNode{clone(){return new JoinAggregateTransformNode(null,duplicate(this.transform))}constructor(parent,transform){super(parent);this.transform=transform}addDimensions(fields){this.transform.groupby=unique(this.transform.groupby.concat(fields),d=>d)}dependentFields(){const out=new Set;this.transform.groupby&&this.transform.groupby.forEach(out.add,out);this.transform.joinaggregate.map(w=>w.field).filter(f=>void 0!==f).forEach(out.add,
out);return out}producedFields(){return new Set(this.transform.joinaggregate.map(this.getDefaultName))}getDefaultName(joinAggregateFieldDef){return joinAggregateFieldDef.as??vgField(joinAggregateFieldDef)}hash(){return`JoinAggregateTransform ${hash(this.transform)}`}assemble(){const fields=[],ops=[],as=[];for(var joinaggregate of this.transform.joinaggregate)ops.push(joinaggregate.op),as.push(this.getDefaultName(joinaggregate)),fields.push(void 0===joinaggregate.field?null:joinaggregate.field);joinaggregate=
this.transform.groupby;return{type:"joinaggregate",as,ops,fields,...(void 0!==joinaggregate?{groupby:joinaggregate}:{})}}}class StackNode extends DataFlowNode{clone(){return new StackNode(null,duplicate(this._stack))}constructor(parent,stack){super(parent);_defineProperty(this,"_stack",void 0);this._stack=stack}static makeFromTransform(parent,stackTransform){const {stack,groupby,as,offset="zero"}=stackTransform;var sortFields=[];const sortOrder=[];if(void 0!==stackTransform.sort)for(const sortField of stackTransform.sort)sortFields.push(sortField.field),
sortOrder.push(getFirstDefined(sortField.order,"ascending"));sortFields={field:sortFields,order:sortOrder};stackTransform=isValidAsArray(as)?as:vega.isString(as)?[as,`${as}_end`]:[`${stackTransform.stack}_start`,`${stackTransform.stack}_end`];return new StackNode(parent,{dimensionFieldDefs:[],stackField:stack,groupby,offset,sort:sortFields,facetby:[],as:stackTransform})}static makeFromEncoding(parent,model){var stackProperties=model.stack;const {encoding}=model;if(!stackProperties)return null;const {groupbyChannels,
fieldChannel,offset,impute}=stackProperties;stackProperties=groupbyChannels.map(groupbyChannel=>getFieldDef(encoding[groupbyChannel])).filter(def=>!!def);const stackby=getStackByFields(model);var orderDef=model.encoding.order;orderDef=vega.isArray(orderDef)||isFieldDef(orderDef)?sortParams(orderDef):stackby.reduce((s,field)=>{s.field.push(field);s.order.push("y"===fieldChannel?"descending":"ascending");return s},{field:[],order:[]});return new StackNode(parent,{dimensionFieldDefs:stackProperties,
stackField:model.vgField(fieldChannel),facetby:[],stackby,sort:orderDef,offset,impute,as:[model.vgField(fieldChannel,{suffix:"start",forAs:!0}),model.vgField(fieldChannel,{suffix:"end",forAs:!0})]})}get stack(){return this._stack}addDimensions(fields){this._stack.facetby.push(...fields)}dependentFields(){const out=new Set;out.add(this._stack.stackField);this.getGroupbyFields().forEach(out.add,out);this._stack.facetby.forEach(out.add,out);this._stack.sort.field.forEach(out.add,out);return out}producedFields(){return new Set(this._stack.as)}hash(){return`Stack ${hash(this._stack)}`}getGroupbyFields(){const {dimensionFieldDefs,
impute,groupby}=this._stack;return 0<dimensionFieldDefs.length?dimensionFieldDefs.map(dimensionFieldDef=>dimensionFieldDef.bin?impute?[vgField(dimensionFieldDef,{binSuffix:"mid"})]:[vgField(dimensionFieldDef,{}),vgField(dimensionFieldDef,{binSuffix:"end"})]:[vgField(dimensionFieldDef)]).flat():groupby??[]}assemble(){const transform=[],{facetby,dimensionFieldDefs,stackField:field,stackby,sort,offset,impute,as}=this._stack;if(impute)for(const dimensionFieldDef of dimensionFieldDefs){const {bandPosition=
.5,bin}=dimensionFieldDef;if(bin){const binStart=vgField(dimensionFieldDef,{expr:"datum"}),binEnd=vgField(dimensionFieldDef,{expr:"datum",binSuffix:"end"});transform.push({type:"formula",expr:`${bandPosition}*${binStart}+${1-bandPosition}*${binEnd}`,as:vgField(dimensionFieldDef,{binSuffix:"mid",forAs:!0})})}transform.push({type:"impute",field,groupby:[...stackby,...facetby],key:vgField(dimensionFieldDef,{binSuffix:"mid"}),method:"value",value:0})}transform.push({type:"stack",groupby:[...this.getGroupbyFields(),
...facetby],field,sort,as,offset});return transform}}class WindowTransformNode extends DataFlowNode{clone(){return new WindowTransformNode(null,duplicate(this.transform))}constructor(parent,transform){super(parent);this.transform=transform}addDimensions(fields){this.transform.groupby=unique(this.transform.groupby.concat(fields),d=>d)}dependentFields(){const out=new Set;(this.transform.groupby??[]).forEach(out.add,out);(this.transform.sort??[]).forEach(m=>out.add(m.field));this.transform.window.map(w=>
w.field).filter(f=>void 0!==f).forEach(out.add,out);return out}producedFields(){return new Set(this.transform.window.map(this.getDefaultName))}getDefaultName(windowFieldDef){return windowFieldDef.as??vgField(windowFieldDef)}hash(){return`WindowTransform ${hash(this.transform)}`}assemble(){const fields=[],ops=[],as=[],params=[];for(var window of this.transform.window)ops.push(window.op),as.push(this.getDefaultName(window)),params.push(void 0===window.param?null:window.param),fields.push(void 0===window.field?
null:window.field);window=this.transform.frame;const groupby=this.transform.groupby;if(window&&null===window[0]&&null===window[1]&&ops.every(o=>isAggregateOp(o)))return{type:"joinaggregate",as,ops,fields,...(void 0!==groupby?{groupby}:{})};const sortFields=[],sortOrder=[];if(void 0!==this.transform.sort)for(var sortField of this.transform.sort)sortFields.push(sortField.field),sortOrder.push(sortField.order??"ascending");sortField=this.transform.ignorePeers;return{type:"window",params,as,ops,fields,
sort:{field:sortFields,order:sortOrder},...(void 0!==sortField?{ignorePeers:sortField}:{}),...(void 0!==groupby?{groupby}:{}),...(void 0!==window?{frame:window}:{})}}}class SignalRefWrapper{constructor(exprGenerator){_defineProperty(this,"signal",void 0);Object.defineProperty(this,"signal",{enumerable:!0,get:exprGenerator})}static fromName(rename,signalName){return new SignalRefWrapper(()=>rename(signalName))}}class ScaleComponent extends Split{constructor(name,typeWithExplicit){super({},{name});
_defineProperty(this,"merged",!1);this.setWithExplicit("type",typeWithExplicit)}domainDefinitelyIncludesZero(){return!1!==this.get("zero")?!0:some(this.get("domains"),d=>vega.isArray(d)&&2===d.length&&0>=d[0]&&0<=d[1])}}const RANGE_PROPERTIES=["range","scheme"],scaleRules={bins:_ref=>{let {model,fieldOrDatumDef}=_ref;return isFieldDef(fieldOrDatumDef)?bins$jscomp$1(model,fieldOrDatumDef):void 0},interpolate:_ref2=>{let {channel,fieldOrDatumDef}=_ref2;_ref2=fieldOrDatumDef.type;_ref2=contains(["color",
"fill","stroke"],channel)&&"nominal"!==_ref2?"hcl":void 0;return _ref2},nice:_ref3=>{let {scaleType,channel,domain,domainMin,domainMax,fieldOrDatumDef}=_ref3;_ref3=getFieldDef(fieldOrDatumDef)?.bin||vega.isArray(domain)||null!=domainMax||null!=domainMin||contains([ScaleType.TIME,ScaleType.UTC],scaleType)?void 0:isXorY(channel)?!0:void 0;return _ref3},padding:_ref4=>{let {channel,scaleType,fieldOrDatumDef,markDef,config}=_ref4;a:{_ref4=config.scale;var barConfig=config.bar;if(isXorY(channel)){if(CONTINUOUS_TO_CONTINUOUS_SCALES.has(scaleType)){if(void 0!==
_ref4.continuousPadding){_ref4=_ref4.continuousPadding;break a}const {type,orient}=markDef;if("bar"===type&&(!isFieldDef(fieldOrDatumDef)||!fieldOrDatumDef.bin&&!fieldOrDatumDef.timeUnit)&&("vertical"===orient&&"x"===channel||"horizontal"===orient&&"y"===channel)){_ref4=barConfig.continuousBandSize;break a}}if(scaleType===ScaleType.POINT){_ref4=_ref4.pointPadding;break a}}_ref4=void 0}return _ref4},paddingInner:_ref5=>{let {scalePadding,channel,markDef,scaleType,config,hasNestedOffsetScale}=_ref5;
return paddingInner(scalePadding,channel,markDef.type,scaleType,config.scale,hasNestedOffsetScale)},paddingOuter:_ref6=>{let {scalePadding,channel,scaleType,scalePaddingInner,config,hasNestedOffsetScale}=_ref6;return paddingOuter$jscomp$0(scalePadding,channel,scaleType,scalePaddingInner,config.scale,hasNestedOffsetScale)},reverse:_ref7=>{let {fieldOrDatumDef,scaleType,channel,config}=_ref7;_ref7=isFieldDef(fieldOrDatumDef)?fieldOrDatumDef.sort:void 0;var scaleConfig=config.scale;_ref7="x"===channel&&
void 0!==scaleConfig.xReverse?hasContinuousDomain(scaleType)&&"descending"===_ref7?isSignalRef(scaleConfig.xReverse)?{signal:`!${scaleConfig.xReverse.signal}`}:!scaleConfig.xReverse:scaleConfig.xReverse:hasContinuousDomain(scaleType)&&"descending"===_ref7?!0:void 0;return _ref7},zero:_ref8=>{let {channel,fieldOrDatumDef,domain,markDef,scaleType,config,hasSecondaryRangeChannel}=_ref8;a:if(_ref8=config.scale,domain&&"unaggregated"!==domain&&hasContinuousDomain(scaleType)){if(vega.isArray(domain)&&(_ref8=
domain[domain.length-1],0>=domain[0]&&0<=_ref8)){_ref8=!0;break a}_ref8=!1}else if("size"!==channel||"quantitative"!==fieldOrDatumDef.type||CONTINUOUS_TO_DISCRETE_SCALES.has(scaleType))if(isFieldDef(fieldOrDatumDef)&&fieldOrDatumDef.bin||!contains([...POSITION_SCALE_CHANNELS,...POLAR_POSITION_SCALE_CHANNELS],channel))_ref8=!1;else{const {orient,type}=markDef;_ref8=contains(["bar","area","line","trail"],type)&&("horizontal"===orient&&"y"===channel||"vertical"===orient&&"x"===channel)?!1:contains(["bar",
"area"],type)&&!hasSecondaryRangeChannel?!0:_ref8?.zero}else _ref8=!0;return _ref8}},scaleTypeTieBreaker=tieBreakByComparing((st1,st2)=>SCALE_PRECEDENCE_INDEX[st1]-SCALE_PRECEDENCE_INDEX[st2]);class NameMap{constructor(){_defineProperty(this,"nameMap",void 0);this.nameMap={}}rename(oldName,newName){this.nameMap[oldName]=newName}has(name){return void 0!==this.nameMap[name]}get(name){for(;this.nameMap[name]&&name!==this.nameMap[name];)name=this.nameMap[name];return name}}class Model{constructor(spec,
type,parent,parentGivenName,config,resolve,view){this.type=type;this.parent=parent;this.config=config;_defineProperty(this,"name",void 0);_defineProperty(this,"size",void 0);_defineProperty(this,"title",void 0);_defineProperty(this,"description",void 0);_defineProperty(this,"data",void 0);_defineProperty(this,"transforms",void 0);_defineProperty(this,"layout",void 0);_defineProperty(this,"scaleNameMap",void 0);_defineProperty(this,"projectionNameMap",void 0);_defineProperty(this,"signalNameMap",void 0);
_defineProperty(this,"component",void 0);_defineProperty(this,"view",void 0);_defineProperty(this,"children",void 0);_defineProperty(this,"correctDataNames",mark=>{mark.from?.data&&(mark.from.data=this.lookupDataSource(mark.from.data));mark.from?.facet?.data&&(mark.from.facet.data=this.lookupDataSource(mark.from.facet.data));return mark});this.parent=parent;this.config=config;this.view=replaceExprRef(view);this.name=spec.name??parentGivenName;this.title=isText(spec.title)?{text:spec.title}:spec.title?
replaceExprRef(spec.title):void 0;this.scaleNameMap=parent?parent.scaleNameMap:new NameMap;this.projectionNameMap=parent?parent.projectionNameMap:new NameMap;this.signalNameMap=parent?parent.signalNameMap:new NameMap;this.data=spec.data;this.description=spec.description;this.transforms=normalizeTransform(spec.transform??[]);this.layout="layer"===type||"unit"===type?{}:extractCompositionLayout(spec,type,config);this.component={data:{sources:parent?parent.component.data.sources:[],outputNodes:parent?
parent.component.data.outputNodes:{},outputNodeRefCounts:parent?parent.component.data.outputNodeRefCounts:{},isFaceted:"facet"in spec||parent?.component.data.isFaceted&&void 0===spec.data},layoutSize:new Split,layoutHeaders:{row:{},column:{},facet:{}},mark:null,resolve:{scale:{},axis:{},legend:{},...(resolve?duplicate(resolve):{})},selection:null,scales:null,projection:null,axes:{},legends:{}}}get width(){return this.getSizeSignalRef("width")}get height(){return this.getSizeSignalRef("height")}parse(){this.parseScale();
this.parseLayoutSize();this.renameTopLevelLayoutSizeSignal();this.parseSelections();this.parseProjection();this.parseData();this.parseAxesAndHeaders();this.parseLegends();this.parseMarkGroup()}parseScale(){parseScales(this)}parseProjection(){parseProjection(this)}renameTopLevelLayoutSizeSignal(){"width"!==this.getName("width")&&this.renameSignal(this.getName("width"),"width");"height"!==this.getName("height")&&this.renameSignal(this.getName("height"),"height")}parseLegends(){parseLegend(this)}assembleEncodeFromView(view){const {style:_,
...baseView}=view;view={};for(const property of keys$jscomp$0(baseView)){const value=baseView[property];void 0!==value&&(view[property]=signalOrValueRef(value))}return view}assembleGroupEncodeEntry(isTopLevel){let encodeEntry={};this.view&&(encodeEntry=this.assembleEncodeFromView(this.view));return isTopLevel||(this.description&&(encodeEntry.description=signalOrValueRef(this.description)),"unit"!==this.type&&"layer"!==this.type)?isEmpty(encodeEntry)?void 0:encodeEntry:{width:this.getSizeSignalRef("width"),
height:this.getSizeSignalRef("height"),...(encodeEntry??{})}}assembleLayout(){if(this.layout){var {spacing,...layout}=this.layout,{component,config}=this;var JSCompiler_inline_result=component.layoutHeaders;var titleBand={};for(const channel of FACET_CHANNELS){var headerComponent=JSCompiler_inline_result[channel];if(headerComponent?.facetFieldDef){const {titleAnchor,titleOrient}=getHeaderProperties(["titleAnchor","titleOrient"],headerComponent.facetFieldDef.header,config,channel);headerComponent=
getHeaderChannel(channel,titleOrient);const band=LAYOUT_TITLE_BAND[headerComponent][titleAnchor];void 0!==band&&(titleBand[headerComponent]=band)}}JSCompiler_inline_result=isEmpty(titleBand)?void 0:titleBand;return{padding:spacing,...this.assembleDefaultLayout(),...layout,...(JSCompiler_inline_result?{titleBand:JSCompiler_inline_result}:{})}}}assembleDefaultLayout(){return{}}assembleHeaderMarks(){var {layoutHeaders}=this.component,headerMarks=[];for(var channel$jscomp$0 of FACET_CHANNELS)if(layoutHeaders[channel$jscomp$0].title){var JSCompiler_temp_const=
headerMarks,JSCompiler_temp_const$jscomp$0=JSCompiler_temp_const.push;var JSCompiler_inline_result=channel$jscomp$0;var title=this.component.layoutHeaders[JSCompiler_inline_result].title,config=this.config?this.config:void 0,facetFieldDef=this.component.layoutHeaders[JSCompiler_inline_result].facetFieldDef?this.component.layoutHeaders[JSCompiler_inline_result].facetFieldDef:void 0;const {titleAnchor,titleAngle:ta,titleOrient}=getHeaderProperties(["titleAnchor","titleAngle","titleOrient"],facetFieldDef.header,
config,JSCompiler_inline_result);var headerChannel=getHeaderChannel(JSCompiler_inline_result,titleOrient),titleAngle=normalizeAngle(ta);JSCompiler_inline_result={name:`${JSCompiler_inline_result}-title`,type:"group",role:`${headerChannel}-title`,title:{text:title,...("row"===JSCompiler_inline_result?{orient:"left"}:{}),style:"guide-title",...defaultHeaderGuideBaseline(titleAngle,headerChannel),...defaultHeaderGuideAlign(headerChannel,titleAngle,titleAnchor),...assembleHeaderProperties(config,facetFieldDef,
JSCompiler_inline_result,HEADER_TITLE_PROPERTIES,HEADER_TITLE_PROPERTIES_MAP)}};JSCompiler_temp_const$jscomp$0.call(JSCompiler_temp_const,JSCompiler_inline_result)}for(const channel of HEADER_CHANNELS){layoutHeaders=headerMarks;headerMarks=layoutHeaders.concat;JSCompiler_temp_const=channel;JSCompiler_temp_const$jscomp$0=this.component.layoutHeaders[JSCompiler_temp_const];channel$jscomp$0=[];for(const headerType of HEADER_TYPES)if(JSCompiler_temp_const$jscomp$0[headerType])for(const headerComponent of JSCompiler_temp_const$jscomp$0[headerType]){a:{JSCompiler_inline_result=
JSCompiler_temp_const;title=headerType;var JSCompiler_temp=JSCompiler_temp_const$jscomp$0;if(config=headerComponent){facetFieldDef=null;({facetFieldDef:JSCompiler_inline_result$jscomp$0}=JSCompiler_temp);headerChannel=this.config?this.config:void 0;JSCompiler_inline_result$jscomp$0&&config.labels&&({labelOrient:titleAngle}=getHeaderProperties(["labelOrient"],JSCompiler_inline_result$jscomp$0.header,headerChannel,JSCompiler_inline_result),"row"===JSCompiler_inline_result&&!contains(["top","bottom"],
titleAngle)||"column"===JSCompiler_inline_result&&!contains(["left","right"],titleAngle))&&(facetFieldDef=assembleLabelTitle(JSCompiler_inline_result$jscomp$0,JSCompiler_inline_result,headerChannel));titleAngle=isFacetModel(this)&&!isFacetMapping(this.facet);const axes=config.axes,hasAxes=0<axes?.length;if(facetFieldDef||hasAxes){const sizeChannel="row"===JSCompiler_inline_result?"height":"width";headerChannel=this.getName(`${JSCompiler_inline_result}_${title}`);if(JSCompiler_temp.facetFieldDef){JSCompiler_temp=
{data:this.getName(`${JSCompiler_inline_result}_domain`)};{const {sort}=JSCompiler_inline_result$jscomp$0;var JSCompiler_inline_result$jscomp$0=isSortField(sort)?{field:vgField(sort,{expr:"datum"}),order:sort.order??"ascending"}:vega.isArray(sort)?{field:sortArrayIndexField(JSCompiler_inline_result$jscomp$0,JSCompiler_inline_result,{expr:"datum"}),order:"ascending"}:{field:vgField(JSCompiler_inline_result$jscomp$0,{expr:"datum"}),order:sort??"ascending"}}JSCompiler_temp={from:JSCompiler_temp,sort:JSCompiler_inline_result$jscomp$0}}else JSCompiler_temp=
{};JSCompiler_inline_result={name:headerChannel,type:"group",role:`${JSCompiler_inline_result}-${title}`,...JSCompiler_temp,...(hasAxes&&titleAngle?{from:{data:this.getName(`facet_domain_${JSCompiler_inline_result}`)}}:{}),...(facetFieldDef?{title:facetFieldDef}:{}),...(config.sizeSignal?{encode:{update:{[sizeChannel]:config.sizeSignal}}}:{}),...(hasAxes?{axes}:{})};break a}}JSCompiler_inline_result=null}null!=JSCompiler_inline_result&&channel$jscomp$0.push(JSCompiler_inline_result)}headerMarks=headerMarks.call(layoutHeaders,
channel$jscomp$0)}return headerMarks}assembleAxes(){return assembleAxes(this.component.axes,this.config)}assembleLegends(){return assembleLegends(this)}assembleProjections(){var JSCompiler_inline_result=isLayerModel(this)||"concat"===this?.type?assembleProjectionsForModelAndChildren(this):assembleProjectionForModel(this);return JSCompiler_inline_result}assembleTitle(){const {encoding,...titleNoEncoding}=this.title??{},title={...extractTitleConfig(this.config.title).nonMarkTitleProperties,...titleNoEncoding,
...(encoding?{encode:{update:encoding}}:{})};if(title.text)return contains(["unit","layer"],this.type)?contains(["middle",void 0],title.anchor)&&(title.frame??(title.frame="group")):title.anchor??(title.anchor="start"),isEmpty(title)?void 0:title}assembleGroup(){var signals=0<arguments.length&&void 0!==arguments[0]?arguments[0]:[];const group={};signals=signals.concat(this.assembleSignals());0<signals.length&&(group.signals=signals);if(signals=this.assembleLayout())group.layout=signals;group.marks=
[].concat(this.assembleHeaderMarks(),this.assembleMarks());signals=!this.parent||isFacetModel(this.parent)?assembleScales(this):[];0<signals.length&&(group.scales=signals);signals=this.assembleAxes();0<signals.length&&(group.axes=signals);signals=this.assembleLegends();0<signals.length&&(group.legends=signals);return group}getName(text){return varName((this.name?`${this.name}_`:"")+text)}getDataName(type){return this.getName(DataSourceType[type].toLowerCase())}requestDataName(name){name=this.getDataName(name);
const refCounts=this.component.data.outputNodeRefCounts;refCounts[name]=(refCounts[name]||0)+1;return name}getSizeSignalRef(layoutSizeType){if(isFacetModel(this.parent)){var sizeType=getSizeTypeFromLayoutSizeType(layoutSizeType),channel=getPositionScaleChannel(sizeType);if((sizeType=this.component.scales[channel])&&!sizeType.merged){var type=sizeType.get("type");const range=sizeType.get("range");if(hasDiscreteDomain(type)&&isVgRangeStep(range)){layoutSizeType=sizeType.get("name");type=assembleDomain(this,
channel);if(type=getFieldFromDomain(type))return channel=vgField({aggregate:"distinct",field:type},{expr:"datum"}),{signal:sizeExpr(layoutSizeType,sizeType,channel)};warn(unknownField(channel));return null}}}return{signal:this.signalNameMap.get(this.getName(layoutSizeType))}}lookupDataSource(name){const node=this.component.data.outputNodes[name];return node?node.getSource():name}getSignalName(oldSignalName){return this.signalNameMap.get(oldSignalName)}renameSignal(oldName,newName){this.signalNameMap.rename(oldName,
newName)}renameScale(oldName,newName){this.scaleNameMap.rename(oldName,newName)}renameProjection(oldName,newName){this.projectionNameMap.rename(oldName,newName)}scaleName(originalScaleName,parse){if(parse)return this.getName(originalScaleName);if(CHANNEL_INDEX[originalScaleName]&&SCALE_CHANNEL_INDEX[originalScaleName]&&this.component.scales[originalScaleName]||this.scaleNameMap.has(this.getName(originalScaleName)))return this.scaleNameMap.get(this.getName(originalScaleName))}projectionName(parse){if(parse)return this.getName("projection");
if(this.component.projection&&!this.component.projection.merged||this.projectionNameMap.has(this.getName("projection")))return this.projectionNameMap.get(this.getName("projection"))}getScaleComponent(channel){if(!this.component.scales)throw Error("getScaleComponent cannot be called before parseScale(). Make sure you have called parseScale or use parseUnitModelWithScale().");const localScaleComponent=this.component.scales[channel];return localScaleComponent&&!localScaleComponent.merged?localScaleComponent:
this.parent?this.parent.getScaleComponent(channel):void 0}getSelectionComponent(variableName,origName){let sel=this.component.selection[variableName];!sel&&this.parent&&(sel=this.parent.getSelectionComponent(variableName,origName));if(!sel)throw Error(`Cannot find a selection named "${origName}".`);return sel}hasAxisOrientSignalRef(){return this.component.axes.x?.some(a=>a.hasOrientSignalRef())||this.component.axes.y?.some(a=>a.hasOrientSignalRef())}}class ModelWithField extends Model{vgField(channel){let opt=
1<arguments.length&&void 0!==arguments[1]?arguments[1]:{};const fieldDef=this.fieldDef(channel);if(fieldDef)return vgField(fieldDef,opt)}reduceFieldDef(f,init){return reduce(this.getMapping(),(acc,cd,c)=>(cd=getFieldDef(cd))?f(acc,cd,c):acc,init)}forEachFieldDef(f,t){forEach(this.getMapping(),(cd,c)=>{(cd=getFieldDef(cd))&&f(cd,c)},t)}}class DensityTransformNode extends DataFlowNode{clone(){return new DensityTransformNode(null,duplicate(this.transform))}constructor(parent,transform){super(parent);
this.transform=transform;this.transform=duplicate(transform);parent=this.transform.as??[void 0,void 0];this.transform.as=[parent[0]??"value",parent[1]??"density"];transform.groupby&&null==transform.minsteps&&null==transform.maxsteps&&null==transform.steps&&(this.transform.steps=200)}dependentFields(){return new Set([this.transform.density,...(this.transform.groupby??[])])}producedFields(){return new Set(this.transform.as)}hash(){return`DensityTransform ${hash(this.transform)}`}assemble(){const {density,
...rest}=this.transform;return{type:"kde",field:density,...rest}}}class FilterInvalidNode extends DataFlowNode{clone(){return new FilterInvalidNode(null,{...this.filter})}constructor(parent,filter){super(parent);this.filter=filter}static make(parent,model){const {config,mark,markDef}=model;if("filter"!==getMarkPropOrConfig("invalid",markDef,config))return null;const filter=model.reduceFieldDef((aggregator,fieldDef,channel)=>{if(channel=!!SCALE_CHANNEL_INDEX[channel]&&model.getScaleComponent(channel))channel=
channel.get("type"),hasContinuousDomain(channel)&&"count"!==fieldDef.aggregate&&!isPathMark(mark)&&(aggregator[fieldDef.field]=fieldDef);return aggregator},{});return keys$jscomp$0(filter).length?new FilterInvalidNode(parent,filter):null}dependentFields(){return new Set(keys$jscomp$0(this.filter))}producedFields(){return new Set}hash(){return`FilterInvalid ${hash(this.filter)}`}assemble(){const filters=keys$jscomp$0(this.filter).reduce((vegaFilters,field)=>{field=this.filter[field];const ref=vgField(field,
{expr:"datum"});null!==field&&("temporal"===field.type?vegaFilters.push(`(isDate(${ref}) || (isValid(${ref}) && isFinite(+${ref})))`):"quantitative"===field.type&&(vegaFilters.push(`isValid(${ref})`),vegaFilters.push(`isFinite(+${ref})`)));return vegaFilters},[]);return 0<filters.length?{type:"filter",expr:filters.join(" \x26\x26 ")}:null}}class FlattenTransformNode extends DataFlowNode{clone(){return new FlattenTransformNode(this.parent,duplicate(this.transform))}constructor(parent,transform){super(parent);
this.transform=transform;this.transform=duplicate(transform);const {flatten,as=[]}=this.transform;this.transform.as=flatten.map((f,i)=>as[i]??f)}dependentFields(){return new Set(this.transform.flatten)}producedFields(){return new Set(this.transform.as)}hash(){return`FlattenTransform ${hash(this.transform)}`}assemble(){const {flatten:fields,as}=this.transform;return{type:"flatten",fields,as}}}class FoldTransformNode extends DataFlowNode{clone(){return new FoldTransformNode(null,duplicate(this.transform))}constructor(parent,
transform){super(parent);this.transform=transform;this.transform=duplicate(transform);parent=this.transform.as??[void 0,void 0];this.transform.as=[parent[0]??"key",parent[1]??"value"]}dependentFields(){return new Set(this.transform.fold)}producedFields(){return new Set(this.transform.as)}hash(){return`FoldTransform ${hash(this.transform)}`}assemble(){const {fold,as}=this.transform;return{type:"fold",fields:fold,as}}}class GeoJSONNode extends DataFlowNode{clone(){return new GeoJSONNode(null,duplicate(this.fields),
this.geojson,this.signal)}static parseAll(parent,model){if(model.component.projection&&!model.component.projection.isFit)return parent;let geoJsonCounter=0;for(var coordinates of[["longitude","latitude"],["longitude2","latitude2"]]){const pair=coordinates.map(channel=>{channel=getFieldOrDatumDef(model.encoding[channel]);return isFieldDef(channel)?channel.field:isDatumDef(channel)?{expr:`${channel.datum}`}:isValueDef(channel)?{expr:`${channel.value}`}:void 0});if(pair[0]||pair[1])parent=new GeoJSONNode(parent,
pair,null,model.getName(`geojson_${geoJsonCounter++}`))}model.channelHasField("shape")&&(coordinates=model.typedFieldDef("shape"),"geojson"===coordinates.type&&(parent=new GeoJSONNode(parent,null,coordinates.field,model.getName(`geojson_${geoJsonCounter++}`))));return parent}constructor(parent,fields,geojson,signal){super(parent);this.fields=fields;this.geojson=geojson;this.signal=signal}dependentFields(){const fields=(this.fields??[]).filter(vega.isString);return new Set([...(this.geojson?[this.geojson]:
[]),...fields])}producedFields(){return new Set}hash(){return`GeoJSON ${this.geojson} ${this.signal} ${hash(this.fields)}`}assemble(){return[...(this.geojson?[{type:"filter",expr:`isValid(datum["${this.geojson}"])`}]:[]),{type:"geojson",...(this.fields?{fields:this.fields}:{}),...(this.geojson?{geojson:this.geojson}:{}),signal:this.signal}]}}class GeoPointNode extends DataFlowNode{clone(){return new GeoPointNode(null,this.projection,duplicate(this.fields),duplicate(this.as))}constructor(parent,projection,
fields,as){super(parent);this.projection=projection;this.fields=fields;this.as=as}static parseAll(parent,model){if(!model.projectionName())return parent;for(const coordinates of[["longitude","latitude"],["longitude2","latitude2"]]){const pair=coordinates.map(channel=>{channel=getFieldOrDatumDef(model.encoding[channel]);return isFieldDef(channel)?channel.field:isDatumDef(channel)?{expr:`${channel.datum}`}:isValueDef(channel)?{expr:`${channel.value}`}:void 0}),suffix="longitude2"===coordinates[0]?"2":
"";if(pair[0]||pair[1])parent=new GeoPointNode(parent,model.projectionName(),pair,[model.getName(`x${suffix}`),model.getName(`y${suffix}`)])}return parent}dependentFields(){return new Set(this.fields.filter(vega.isString))}producedFields(){return new Set(this.as)}hash(){return`Geopoint ${this.projection} ${hash(this.fields)} ${hash(this.as)}`}assemble(){return{type:"geopoint",projection:this.projection,fields:this.fields,as:this.as}}}class ImputeNode extends DataFlowNode{clone(){return new ImputeNode(null,
duplicate(this.transform))}constructor(parent,transform){super(parent);this.transform=transform}dependentFields(){return new Set([this.transform.impute,this.transform.key,...(this.transform.groupby??[])])}producedFields(){return new Set([this.transform.impute])}processSequence(keyvals){const {start=0,stop,step}=keyvals;return{signal:`sequence(${[start,stop,...(step?[step]:[])].join()})`}}static makeFromTransform(parent,imputeTransform){return new ImputeNode(parent,imputeTransform)}static makeFromEncoding(parent,
model){const encoding=model.encoding;var xDef=encoding.x;const yDef=encoding.y;if(isFieldDef(xDef)&&isFieldDef(yDef)){const imputedChannel=xDef.impute?xDef:yDef.impute?yDef:void 0;if(void 0===imputedChannel)return;xDef=xDef.impute?yDef:yDef.impute?xDef:void 0;const {method,value,frame,keyvals}=imputedChannel.impute;model=pathGroupingFields(model.mark,encoding);return new ImputeNode(parent,{impute:imputedChannel.field,key:xDef.field,...(method?{method}:{}),...(void 0!==value?{value}:{}),...(frame?
{frame}:{}),...(void 0!==keyvals?{keyvals}:{}),...(model.length?{groupby:model}:{})})}return null}hash(){return`Impute ${hash(this.transform)}`}assemble(){const {impute,key,keyvals,method,groupby,value,frame=[null,null]}=this.transform,imputeTransform={type:"impute",field:impute,key,...(keyvals?{keyvals:void 0!==keyvals?.stop?this.processSequence(keyvals):keyvals}:{}),method:"value",...(groupby?{groupby}:{}),value:method&&"value"!==method?null:value};return method&&"value"!==method?[imputeTransform,
{type:"window",as:[`imputed_${impute}_value`],ops:[method],fields:[impute],frame,ignorePeers:!1,...(groupby?{groupby}:{})},{type:"formula",expr:`datum.${impute} === null ? datum.imputed_${impute}_value : datum.${impute}`,as:impute}]:[imputeTransform]}}class LoessTransformNode extends DataFlowNode{clone(){return new LoessTransformNode(null,duplicate(this.transform))}constructor(parent,transform){super(parent);this.transform=transform;this.transform=duplicate(transform);parent=this.transform.as??[void 0,
void 0];this.transform.as=[parent[0]??transform.on,parent[1]??transform.loess]}dependentFields(){return new Set([this.transform.loess,this.transform.on,...(this.transform.groupby??[])])}producedFields(){return new Set(this.transform.as)}hash(){return`LoessTransform ${hash(this.transform)}`}assemble(){const {loess,on,...rest}=this.transform;return{type:"loess",x:on,y:loess,...rest}}}class LookupNode extends DataFlowNode{clone(){return new LookupNode(null,duplicate(this.transform),this.secondary)}constructor(parent,
transform,secondary){super(parent);this.transform=transform;this.secondary=secondary}static make(parent,model,transform,counter){const sources=model.component.data.sources,{from}=transform;var fromOutputNode=null;if("data"in from)fromOutputNode=findSource(from.data,sources),fromOutputNode||(fromOutputNode=new SourceNode(from.data),sources.push(fromOutputNode)),counter=model.getName(`lookup_${counter}`),fromOutputNode=new OutputNode(fromOutputNode,counter,DataSourceType.Lookup,model.component.data.outputNodeRefCounts),
model.component.data.outputNodes[counter]=fromOutputNode;else if("param"in from){counter=from.param;transform={as:counter,...transform};let selCmpt;try{selCmpt=model.getSelectionComponent(varName(counter),counter)}catch(e){throw Error(`Lookups can only be performed on selection parameters. "${counter}" is a variable parameter.`);}fromOutputNode=selCmpt.materialized;if(!fromOutputNode)throw Error(`Cannot define and lookup the "${counter}" selection in the same view. `+"Try moving the lookup into a second, layered view?");
}return new LookupNode(parent,transform,fromOutputNode.getSource())}dependentFields(){return new Set([this.transform.lookup])}producedFields(){return new Set(this.transform.as?vega.array(this.transform.as):this.transform.from.fields)}hash(){return`Lookup ${hash({transform:this.transform,secondary:this.secondary})}`}assemble(){if(this.transform.from.fields)var foreign={values:this.transform.from.fields,...(this.transform.as?{as:vega.array(this.transform.as)}:{})};else foreign=this.transform.as,vega.isString(foreign)||
(warn('If "from.fields" is not specified, "as" has to be a string that specifies the key to be used for the data from the secondary source.'),foreign="_lookup"),foreign={as:[foreign]};return{type:"lookup",from:this.secondary,key:this.transform.from.key,fields:[this.transform.lookup],...foreign,...(this.transform.default?{default:this.transform.default}:{})}}}class QuantileTransformNode extends DataFlowNode{clone(){return new QuantileTransformNode(null,duplicate(this.transform))}constructor(parent,
transform){super(parent);this.transform=transform;this.transform=duplicate(transform);parent=this.transform.as??[void 0,void 0];this.transform.as=[parent[0]??"prob",parent[1]??"value"]}dependentFields(){return new Set([this.transform.quantile,...(this.transform.groupby??[])])}producedFields(){return new Set(this.transform.as)}hash(){return`QuantileTransform ${hash(this.transform)}`}assemble(){const {quantile,...rest}=this.transform;return{type:"quantile",field:quantile,...rest}}}class RegressionTransformNode extends DataFlowNode{clone(){return new RegressionTransformNode(null,
duplicate(this.transform))}constructor(parent,transform){super(parent);this.transform=transform;this.transform=duplicate(transform);parent=this.transform.as??[void 0,void 0];this.transform.as=[parent[0]??transform.on,parent[1]??transform.regression]}dependentFields(){return new Set([this.transform.regression,this.transform.on,...(this.transform.groupby??[])])}producedFields(){return new Set(this.transform.as)}hash(){return`RegressionTransform ${hash(this.transform)}`}assemble(){const {regression,
on,...rest}=this.transform;return{type:"regression",x:on,y:regression,...rest}}}class PivotTransformNode extends DataFlowNode{clone(){return new PivotTransformNode(null,duplicate(this.transform))}constructor(parent,transform){super(parent);this.transform=transform}addDimensions(fields){this.transform.groupby=unique((this.transform.groupby??[]).concat(fields),d=>d)}producedFields(){}dependentFields(){return new Set([this.transform.pivot,this.transform.value,...(this.transform.groupby??[])])}hash(){return`PivotTransform ${hash(this.transform)}`}assemble(){const {pivot,
value,groupby,limit,op}=this.transform;return{type:"pivot",field:pivot,value,...(void 0!==limit?{limit}:{}),...(void 0!==op?{op}:{}),...(void 0!==groupby?{groupby}:{})}}}class SampleTransformNode extends DataFlowNode{clone(){return new SampleTransformNode(null,duplicate(this.transform))}constructor(parent,transform){super(parent);this.transform=transform}dependentFields(){return new Set}producedFields(){return new Set}hash(){return`SampleTransform ${hash(this.transform)}`}assemble(){return{type:"sample",
size:this.transform.sample}}}class FacetModel extends ModelWithField{constructor(spec,parent,parentGivenName,config){super(spec,"facet",parent,parentGivenName,config,spec.resolve);_defineProperty(this,"facet",void 0);_defineProperty(this,"child",void 0);_defineProperty(this,"children",void 0);this.child=buildModel(spec.spec,this,this.getName("child"),void 0,config);this.children=[this.child];this.facet=this.initFacet(spec.facet)}initFacet(facet){if(!isFacetMapping(facet))return{facet:this.initFacetFieldDef(facet,
"facet")};var channels=keys$jscomp$0(facet);const normalizedFacet={};for(const channel of channels){if(!["row","column"].includes(channel)){warn(incompatibleChannel(channel,"facet"));break}channels=facet[channel];if(void 0===channels.field){warn(emptyFieldDef(channels,channel));break}normalizedFacet[channel]=this.initFacetFieldDef(channels,channel)}return normalizedFacet}initFacetFieldDef(fieldDef,channel){fieldDef=initFieldDef(fieldDef,channel);fieldDef.header?fieldDef.header=replaceExprRef(fieldDef.header):
null===fieldDef.header&&(fieldDef.header=null);return fieldDef}channelHasField(channel){return!!this.facet[channel]}fieldDef(channel){return this.facet[channel]}parseData(){this.component.data=parseData(this);this.child.parseData()}parseLayoutSize(){parseChildrenLayoutSize(this)}parseSelections(){this.child.parseSelections();this.component.selection=this.child.component.selection}parseMarkGroup(){this.child.parseMarkGroup()}parseAxesAndHeaders(){this.child.parseAxesAndHeaders();for(const channel of FACET_CHANNELS){var channel$jscomp$0=
channel;const {facet,config,child,component}=this;if(this.channelHasField(channel$jscomp$0)){const fieldDef=facet[channel$jscomp$0];var titleConfig=getHeaderProperty("title",null,config,channel$jscomp$0);titleConfig=title$jscomp$0(fieldDef,config,{allowDisabling:!0,includeDefault:void 0===titleConfig||!!titleConfig});child.component.layoutHeaders[channel$jscomp$0].title&&(titleConfig=vega.isArray(titleConfig)?titleConfig.join(", "):titleConfig,titleConfig+=` / ${child.component.layoutHeaders[channel$jscomp$0].title}`,
child.component.layoutHeaders[channel$jscomp$0].title=null);var labelOrient=getHeaderProperty("labelOrient",fieldDef.header,config,channel$jscomp$0);const labels=null!==fieldDef.header?getFirstDefined(fieldDef.header?.labels,config.header.labels,!0):!1;labelOrient=contains(["bottom","right"],labelOrient)?"footer":"header";component.layoutHeaders[channel$jscomp$0]={title:null!==fieldDef.header?titleConfig:null,facetFieldDef:fieldDef,[labelOrient]:"facet"===channel$jscomp$0?[]:[makeHeaderComponent(this,
channel$jscomp$0,labels)]}}}mergeChildAxis(this,"x");mergeChildAxis(this,"y")}assembleSelectionTopLevelSignals(signals){return this.child.assembleSelectionTopLevelSignals(signals)}assembleSignals(){this.child.assembleSignals();return[]}assembleSelectionData(data){return this.child.assembleSelectionData(data)}getHeaderLayoutMixins(){const layoutMixins={};for(const channel of FACET_CHANNELS)for(const headerType of HEADER_TYPES){const layoutHeaderComponent=this.component.layoutHeaders[channel];var headerComponent=
layoutHeaderComponent[headerType],{facetFieldDef}=layoutHeaderComponent;if(facetFieldDef&&(facetFieldDef=getHeaderProperty("titleOrient",facetFieldDef.header,this.config,channel),["right","bottom"].includes(facetFieldDef))){facetFieldDef=getHeaderChannel(channel,facetFieldDef);let $jscomp$logical$assign$tmp730812712$22;($jscomp$logical$assign$tmp730812712$22=layoutMixins).titleAnchor??($jscomp$logical$assign$tmp730812712$22.titleAnchor={});layoutMixins.titleAnchor[facetFieldDef]="end"}if(headerComponent?.[0]){headerComponent=
"row"===channel?"height":"width";facetFieldDef="header"===headerType?"headerBand":"footerBand";if("facet"!==channel&&!this.child.component.layoutSize.get(headerComponent)){let $jscomp$logical$assign$tmp730812712$23,$jscomp$logical$assign$tmpindex730812712$23;($jscomp$logical$assign$tmp730812712$23=layoutMixins)[$jscomp$logical$assign$tmpindex730812712$23=facetFieldDef]??($jscomp$logical$assign$tmp730812712$23[$jscomp$logical$assign$tmpindex730812712$23]={});layoutMixins[facetFieldDef][channel]=.5}if(layoutHeaderComponent.title){let $jscomp$logical$assign$tmp730812712$24;
($jscomp$logical$assign$tmp730812712$24=layoutMixins).offset??($jscomp$logical$assign$tmp730812712$24.offset={});layoutMixins.offset["row"===channel?"rowTitle":"columnTitle"]=10}}}return layoutMixins}assembleDefaultLayout(){const {column,row}=this.facet,columns=column?this.columnDistinctSignal():row?1:void 0;let align="all";row||"independent"!==this.component.resolve.scale.x?column||"independent"!==this.component.resolve.scale.y||(align="none"):align="none";return{...this.getHeaderLayoutMixins(),
...(columns?{columns}:{}),bounds:"full",align}}assembleLayoutSignals(){return this.child.assembleLayoutSignals()}columnDistinctSignal(){if(!(this.parent&&this.parent instanceof FacetModel))return{signal:`length(data('${this.getName("column_domain")}'))`}}assembleGroupStyle(){}assembleGroup(signals){return this.parent&&this.parent instanceof FacetModel?{...(this.channelHasField("column")?{encode:{update:{columns:{field:vgField(this.facet.column,{prefix:"distinct"})}}}}:{}),...super.assembleGroup(signals)}:
super.assembleGroup(signals)}getCardinalityAggregateForChild(){const fields=[],ops=[],as=[];if(this.child instanceof FacetModel){if(this.child.channelHasField("column")){var field=vgField(this.child.facet.column);fields.push(field);ops.push("distinct");as.push(`distinct_${field}`)}}else for(field of POSITION_SCALE_CHANNELS){var childScaleComponent=this.child.component.scales[field];if(childScaleComponent&&!childScaleComponent.merged){var type=childScaleComponent.get("type");childScaleComponent=childScaleComponent.get("range");
hasDiscreteDomain(type)&&isVgRangeStep(childScaleComponent)&&(type=assembleDomain(this.child,field),(type=getFieldFromDomain(type))?(fields.push(type),ops.push("distinct"),as.push(`distinct_${type}`)):warn(unknownField(field)))}}return{fields,ops,as}}assembleFacet(){const {name,data}=this.component.data.facetRoot,{row,column}=this.facet,{fields,ops,as}=this.getCardinalityAggregateForChild(),groupby=[];for(var channel of FACET_CHANNELS){var fieldDef=this.facet[channel];if(fieldDef){groupby.push(vgField(fieldDef));
const {bin,sort}=fieldDef;isBinning(bin)&&groupby.push(vgField(fieldDef,{binSuffix:"end"}));if(isSortField(sort)){const {field,op="min"}=sort;fieldDef=facetSortFieldName(fieldDef,sort);row&&column?(fields.push(fieldDef),ops.push("max")):(fields.push(field),ops.push(op));as.push(fieldDef)}else vega.isArray(sort)&&(fieldDef=sortArrayIndexField(fieldDef,channel),fields.push(fieldDef),ops.push("max"),as.push(fieldDef))}}channel=!!row&&!!column;return{name,data,groupby,...(channel||0<fields.length?{aggregate:{...(channel?
{cross:channel}:{}),...(fields.length?{fields,ops,as}:{})}}:{})}}facetSortFields(channel){var {facet}=this;return(facet=facet[channel])?isSortField(facet.sort)?[facetSortFieldName(facet,facet.sort,{expr:"datum"})]:vega.isArray(facet.sort)?[sortArrayIndexField(facet,channel,{expr:"datum"})]:[vgField(facet,{expr:"datum"})]:[]}facetSortOrder(channel){const {facet}=this;return(channel=facet[channel])?({sort:channel}=channel,[(isSortField(channel)?channel.order:!vega.isArray(channel)&&channel)||"ascending"]):
[]}assembleLabelTitle(){const {facet,config}=this;if(facet.facet)return assembleLabelTitle(facet.facet,"facet",config);const ORTHOGONAL_ORIENT={row:["top","bottom"],column:["left","right"]};for(const channel of HEADER_CHANNELS)if(facet[channel]){const labelOrient=getHeaderProperty("labelOrient",facet[channel]?.header,config,channel);if(ORTHOGONAL_ORIENT[channel].includes(labelOrient))return assembleLabelTitle(facet[channel],channel,config)}}assembleMarks(){const {child}=this,data=assembleFacetData(this.component.data.facetRoot),
encodeEntry=child.assembleGroupEncodeEntry(!1),title=this.assembleLabelTitle()||child.assembleTitle(),style=child.assembleGroupStyle();return[{name:this.getName("cell"),type:"group",...(title?{title}:{}),...(style?{style}:{}),from:{facet:this.assembleFacet()},sort:{field:FACET_CHANNELS.map(c=>this.facetSortFields(c)).flat(),order:FACET_CHANNELS.map(c=>this.facetSortOrder(c)).flat()},...(0<data.length?{data}:{}),...(encodeEntry?{encode:{update:encodeEntry}}:{}),...child.assembleGroup(assembleFacetSignals(this,
[]))}]}getMapping(){return this.facet}}class ConcatModel extends Model{constructor(spec,parent,parentGivenName,config){super(spec,"concat",parent,parentGivenName,config,spec.resolve);_defineProperty(this,"children",void 0);"shared"!==spec.resolve?.axis?.x&&"shared"!==spec.resolve?.axis?.y||warn("Axes cannot be shared in concatenated or repeated views yet (https://github.com/vega/vega-lite/issues/2415).");this.children=this.getChildren(spec).map((child,i)=>buildModel(child,this,this.getName(`concat_${i}`),
void 0,config))}parseData(){this.component.data=parseData(this);for(const child of this.children)child.parseData()}parseSelections(){this.component.selection={};for(const child of this.children){child.parseSelections();for(const key of keys$jscomp$0(child.component.selection))this.component.selection[key]=child.component.selection[key]}}parseMarkGroup(){for(const child of this.children)child.parseMarkGroup()}parseAxesAndHeaders(){for(const child of this.children)child.parseAxesAndHeaders()}getChildren(spec){return"vconcat"in
spec?spec.vconcat:"hconcat"in spec?spec.hconcat:spec.concat}parseLayoutSize(){parseChildrenLayoutSize(this);const heightType=void 0===this.layout.columns?"height":"childHeight";parseNonUnitLayoutSizeForChannel(this,1===this.layout.columns?"width":"childWidth");parseNonUnitLayoutSizeForChannel(this,heightType)}parseAxisGroup(){return null}assembleSelectionTopLevelSignals(signals){return this.children.reduce((sg,child)=>child.assembleSelectionTopLevelSignals(sg),signals)}assembleSignals(){this.children.forEach(child=>
child.assembleSignals());return[]}assembleLayoutSignals(){const layoutSignals=assembleLayoutSignals(this);for(const child of this.children)layoutSignals.push(...child.assembleLayoutSignals());return layoutSignals}assembleSelectionData(data){return this.children.reduce((db,child)=>child.assembleSelectionData(db),data)}assembleMarks(){return this.children.map(child=>{const title=child.assembleTitle(),style=child.assembleGroupStyle(),encodeEntry=child.assembleGroupEncodeEntry(!1);return{type:"group",
name:child.getName("group"),...(title?{title}:{}),...(style?{style}:{}),...(encodeEntry?{encode:{update:encodeEntry}}:{}),...child.assembleGroup()}})}assembleGroupStyle(){}assembleDefaultLayout(){const columns=this.layout.columns;return{...(null!=columns?{columns}:{}),bounds:"full",align:"each"}}}const AXIS_COMPONENT_PROPERTIES=keys$jscomp$0({disable:1,gridScale:1,scale:1,...COMMON_AXIS_PROPERTIES_INDEX,labelExpr:1,encode:1});class AxisComponent extends Split{constructor(){let explicit=0<arguments.length&&
void 0!==arguments[0]?arguments[0]:{},implicit=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{},mainExtracted=2<arguments.length&&void 0!==arguments[2]?arguments[2]:!1;super();this.explicit=explicit;this.implicit=implicit;this.mainExtracted=mainExtracted}clone(){return new AxisComponent(duplicate(this.explicit),duplicate(this.implicit),this.mainExtracted)}hasAxisPart(part){if("axis"===part)return!0;if("grid"===part||"title"===part)return!!this.get(part);part=this.get(part);return!(!1===part||
null===part)}hasOrientSignalRef(){return isSignalRef(this.explicit.orient)}}const OPPOSITE_ORIENT={bottom:"top",top:"bottom",left:"right",right:"left"},propsToAlwaysIncludeConfig=new Set("grid translate format formatType orient labelExpr tickCount position tickMinStep".split(" ")),markCompiler={arc:{vgMark:"arc",encodeEntry:model=>({...baseEncodeEntry(model,{align:"ignore",baseline:"ignore",color:"include",size:"ignore",orient:"ignore",theta:"ignore"}),...pointPosition("x",model,{defaultPos:"mid"}),
...pointPosition("y",model,{defaultPos:"mid"}),...rectPosition(model,"radius"),...rectPosition(model,"theta")})},area:{vgMark:"area",encodeEntry:model=>({...baseEncodeEntry(model,{align:"ignore",baseline:"ignore",color:"include",orient:"include",size:"ignore",theta:"ignore"}),...pointOrRangePosition("x",model,{defaultPos:"zeroOrMin",defaultPos2:"zeroOrMin",range:"horizontal"===model.markDef.orient}),...pointOrRangePosition("y",model,{defaultPos:"zeroOrMin",defaultPos2:"zeroOrMin",range:"vertical"===
model.markDef.orient}),...defined(model)})},bar:{vgMark:"rect",encodeEntry:model=>({...baseEncodeEntry(model,{align:"ignore",baseline:"ignore",color:"include",orient:"ignore",size:"ignore",theta:"ignore"}),...rectPosition(model,"x"),...rectPosition(model,"y")})},circle:{vgMark:"symbol",encodeEntry:model=>encodeEntry(model,"circle")},geoshape:{vgMark:"shape",encodeEntry:model=>({...baseEncodeEntry(model,{align:"ignore",baseline:"ignore",color:"include",size:"ignore",orient:"ignore",theta:"ignore"})}),
postEncodingTransform:model=>{var {encoding}=model;encoding=encoding.shape;return[{type:"geoshape",projection:model.projectionName(),...(encoding&&isFieldDef(encoding)&&"geojson"===encoding.type?{field:vgField(encoding,{expr:"datum"})}:{})}]}},image:{vgMark:"image",encodeEntry:model=>({...baseEncodeEntry(model,{align:"ignore",baseline:"ignore",color:"ignore",orient:"ignore",size:"ignore",theta:"ignore"}),...rectPosition(model,"x"),...rectPosition(model,"y"),...text$1(model,"url")})},line:{vgMark:"line",
encodeEntry:model=>({...baseEncodeEntry(model,{align:"ignore",baseline:"ignore",color:"include",size:"ignore",orient:"ignore",theta:"ignore"}),...pointPosition("x",model,{defaultPos:"mid"}),...pointPosition("y",model,{defaultPos:"mid"}),...nonPosition("size",model,{vgChannel:"strokeWidth"}),...defined(model)})},point:{vgMark:"symbol",encodeEntry:model=>encodeEntry(model)},rect:{vgMark:"rect",encodeEntry:model=>({...baseEncodeEntry(model,{align:"ignore",baseline:"ignore",color:"include",orient:"ignore",
size:"ignore",theta:"ignore"}),...rectPosition(model,"x"),...rectPosition(model,"y")})},rule:{vgMark:"rule",encodeEntry:model=>{var {markDef}=model;markDef=markDef.orient;return model.encoding.x||model.encoding.y||model.encoding.latitude||model.encoding.longitude?{...baseEncodeEntry(model,{align:"ignore",baseline:"ignore",color:"include",orient:"ignore",size:"ignore",theta:"ignore"}),...pointOrRangePosition("x",model,{defaultPos:"horizontal"===markDef?"zeroOrMax":"mid",defaultPos2:"zeroOrMin",range:"vertical"!==
markDef}),...pointOrRangePosition("y",model,{defaultPos:"vertical"===markDef?"zeroOrMax":"mid",defaultPos2:"zeroOrMin",range:"horizontal"!==markDef}),...nonPosition("size",model,{vgChannel:"strokeWidth"})}:{}}},square:{vgMark:"symbol",encodeEntry:model=>encodeEntry(model,"square")},text:{vgMark:"text",encodeEntry:model=>{var {config}=model,JSCompiler_temp_const={...baseEncodeEntry(model,{align:"include",baseline:"include",color:"include",size:"ignore",orient:"ignore",theta:"include"})},JSCompiler_temp_const$jscomp$0=
{...pointPosition("x",model,{defaultPos:"mid"})},JSCompiler_temp_const$jscomp$1={...pointPosition("y",model,{defaultPos:"mid"})},JSCompiler_temp_const$jscomp$2={...text$1(model)},JSCompiler_temp_const$jscomp$3={...nonPosition("size",model,{vgChannel:"fontSize"})},JSCompiler_temp_const$jscomp$4={...nonPosition("angle",model)};var JSCompiler_inline_result=void 0===getMarkPropOrConfig("align",model.markDef,config)?"center":void 0;JSCompiler_inline_result={...valueIfDefined("align",JSCompiler_inline_result)};
config=void 0===getMarkPropOrConfig("baseline",model.markDef,config)?"middle":void 0;return{...JSCompiler_temp_const,...JSCompiler_temp_const$jscomp$0,...JSCompiler_temp_const$jscomp$1,...JSCompiler_temp_const$jscomp$2,...JSCompiler_temp_const$jscomp$3,...JSCompiler_temp_const$jscomp$4,...JSCompiler_inline_result,...valueIfDefined("baseline",config),...pointPosition("radius",model,{defaultPos:null}),...pointPosition("theta",model,{defaultPos:null})}}},tick:{vgMark:"rect",encodeEntry:model=>{const {config:config$jscomp$0,
markDef:markDef$jscomp$0}=model;var orient=markDef$jscomp$0.orient;const vgSizeChannel="horizontal"===orient?"width":"height";orient="horizontal"===orient?"height":"width";var JSCompiler_temp_const={...baseEncodeEntry(model,{align:"ignore",baseline:"ignore",color:"include",orient:"ignore",size:"ignore",theta:"ignore"})},JSCompiler_temp_const$jscomp$0={...pointPosition("x",model,{defaultPos:"mid",vgChannel:"xc"})},JSCompiler_temp_const$jscomp$1={...pointPosition("y",model,{defaultPos:"mid",vgChannel:"yc"})};
{const {config,markDef}=model;var {orient:orient$jscomp$0}=markDef;var JSCompiler_inline_result="horizontal"===orient$jscomp$0?"width":"height";orient$jscomp$0=model.getScaleComponent("horizontal"===orient$jscomp$0?"x":"y");const markPropOrConfig=getMarkPropOrConfig("size",markDef,config,{vgChannel:JSCompiler_inline_result})??config.tick.bandSize;JSCompiler_inline_result=void 0!==markPropOrConfig?markPropOrConfig:(orient$jscomp$0=orient$jscomp$0?orient$jscomp$0.get("range"):void 0)&&isVgRangeStep(orient$jscomp$0)&&
vega.isNumber(orient$jscomp$0.step)?3*orient$jscomp$0.step/4:3*getViewConfigDiscreteStep(config.view,JSCompiler_inline_result)/4}return{...JSCompiler_temp_const,...JSCompiler_temp_const$jscomp$0,...JSCompiler_temp_const$jscomp$1,...nonPosition("size",model,{defaultValue:JSCompiler_inline_result,vgChannel:vgSizeChannel}),[orient]:signalOrValueRef(getMarkPropOrConfig("thickness",markDef$jscomp$0,config$jscomp$0))}}},trail:{vgMark:"trail",encodeEntry:model=>({...baseEncodeEntry(model,{align:"ignore",
baseline:"ignore",color:"include",size:"include",orient:"ignore",theta:"ignore"}),...pointPosition("x",model,{defaultPos:"mid"}),...pointPosition("y",model,{defaultPos:"mid"}),...nonPosition("size",model),...defined(model)})}};class UnitModel extends ModelWithField{constructor(spec,parent,parentGivenName){let parentGivenSize=3<arguments.length&&void 0!==arguments[3]?arguments[3]:{},config=4<arguments.length?arguments[4]:void 0;super(spec,"unit",parent,parentGivenName,config,void 0,isFrameMixins(spec)?
spec.view:void 0);_defineProperty(this,"markDef",void 0);_defineProperty(this,"encoding",void 0);_defineProperty(this,"specifiedScales",{});_defineProperty(this,"stack",void 0);_defineProperty(this,"specifiedAxes",{});_defineProperty(this,"specifiedLegends",{});_defineProperty(this,"specifiedProjection",{});_defineProperty(this,"selection",[]);_defineProperty(this,"children",[]);const markDef=isMarkDef(spec.mark)?{...spec.mark}:{type:spec.mark},mark=markDef.type;void 0===markDef.filled&&(markDef.filled=
defaultFilled(markDef,config,{graticule:spec.data&&"graticule"in spec.data}));const encoding=this.encoding=initEncoding(spec.encoding||{},mark,markDef.filled,config);this.markDef=initMarkdef(markDef,encoding,config);this.size=initLayoutSize({encoding,size:isFrameMixins(spec)?{...parentGivenSize,...(spec.width?{width:spec.width}:{}),...(spec.height?{height:spec.height}:{})}:parentGivenSize});this.stack=stack$jscomp$1(mark,encoding);this.specifiedScales=this.initScales(mark,encoding);this.specifiedAxes=
this.initAxes(encoding);this.specifiedLegends=this.initLegends(encoding);this.specifiedProjection=spec.projection;this.selection=(spec.params??[]).filter(p=>!!p?.select)}get hasProjection(){const {encoding}=this,isGeoShapeMark=this.mark===GEOSHAPE,hasGeoPosition=encoding&&GEOPOSITION_CHANNELS.some(channel=>isFieldOrDatumDef(encoding[channel]));return isGeoShapeMark||hasGeoPosition}scaleDomain(channel){return(channel=this.specifiedScales[channel])?channel.domain:void 0}axis(channel){return this.specifiedAxes[channel]}legend(channel){return this.specifiedLegends[channel]}initScales(mark,
encoding){return SCALE_CHANNELS.reduce((scales,channel)=>{const fieldOrDatumDef=getFieldOrDatumDef(encoding[channel]);fieldOrDatumDef&&(scales[channel]=this.initScale(fieldOrDatumDef.scale??{}));return scales},{})}initScale(scale){const {domain,range}=scale;scale=replaceExprRef(scale);vega.isArray(domain)&&(scale.domain=domain.map(signalRefOrValue));vega.isArray(range)&&(scale.range=range.map(signalRefOrValue));return scale}initAxes(encoding){return POSITION_SCALE_CHANNELS.reduce((_axis,channel)=>
{var channelDef=encoding[channel];if(isFieldOrDatumDef(channelDef)||"x"===channel&&isFieldOrDatumDef(encoding.x2)||"y"===channel&&isFieldOrDatumDef(encoding.y2))channelDef=isFieldOrDatumDef(channelDef)?channelDef.axis:void 0,_axis[channel]=channelDef?this.initAxis({...channelDef}):channelDef;return _axis},{})}initAxis(axis){var props=keys$jscomp$0(axis);const axisInternal={};for(const prop of props)props=axis[prop],axisInternal[prop]=props?.condition?signalOrValueRefWithCondition(props):signalRefOrValue(props);
return axisInternal}initLegends(encoding){return NONPOSITION_SCALE_CHANNELS.reduce((_legend,channel)=>{var fieldOrDatumDef=getFieldOrDatumDef(encoding[channel]),JSCompiler_temp;if(JSCompiler_temp=fieldOrDatumDef)a:{switch(channel){case "color":case "fill":case "stroke":case "size":case "shape":case "opacity":case "strokeWidth":case "strokeDash":JSCompiler_temp=!0;break a;case "fillOpacity":case "strokeOpacity":case "angle":JSCompiler_temp=!1;break a}JSCompiler_temp=void 0}JSCompiler_temp&&(fieldOrDatumDef=
fieldOrDatumDef.legend,_legend[channel]=fieldOrDatumDef?replaceExprRef(fieldOrDatumDef):fieldOrDatumDef);return _legend},{})}parseData(){this.component.data=parseData(this)}parseLayoutSize(){const {size,component}=this;for(const channel of POSITION_SCALE_CHANNELS){const sizeType=getSizeChannel(channel);if(size[sizeType]){var specifiedSize=size[sizeType];component.layoutSize.set(sizeType,isStep(specifiedSize)?"step":specifiedSize,!0)}else specifiedSize=defaultUnitSize(this,sizeType),component.layoutSize.set(sizeType,
specifiedSize,!1)}}parseSelections(){var JSCompiler_temp_const=this.component;{var selDefs=this.selection;var JSCompiler_inline_result={};const selectionConfig=this.config.selection;if(selDefs&&selDefs.length)for(const def of selDefs){selDefs=varName(def.name);var selDef=def.select;const type=vega.isString(selDef)?selDef:selDef.type;selDef=vega.isObject(selDef)?duplicate(selDef):{type};const cfg=selectionConfig[type];for(const key in cfg)"fields"!==key&&"encodings"!==key&&("mark"===key&&(selDef[key]=
{...cfg[key],...selDef[key]}),void 0===selDef[key]||!0===selDef[key])&&(selDef[key]=cfg[key]??selDef[key]);selDefs=JSCompiler_inline_result[selDefs]={...selDef,name:selDefs,type,init:def.value,bind:def.bind,events:vega.isString(selDef.on)?vega.parseSelector(selDef.on,"scope"):vega.array(duplicate(selDef.on))};for(const c of selectionCompilers)c.defined(selDefs)&&c.parse&&c.parse(this,selDefs,def)}}JSCompiler_temp_const.selection=JSCompiler_inline_result}parseMarkGroup(){this.component.mark=parseMarkGroups(this)}parseAxesAndHeaders(){this.component.axes=
parseUnitAxes(this)}assembleSelectionTopLevelSignals(signals){return assembleTopLevelSignals(this,signals)}assembleSignals(){var JSCompiler_temp_const=[...assembleAxisSignals(this)];var JSCompiler_inline_result=[];for(const selCmpt of vals$jscomp$0(this.component.selection??{})){const name=selCmpt.name;let modifyExpr=`${name}${"_tuple"}, ${"global"===selCmpt.resolve?"true":`{unit: ${unitName(this)}}`}`;for(const c of selectionCompilers)c.defined(selCmpt)&&(c.signals&&(JSCompiler_inline_result=c.signals(this,
selCmpt,JSCompiler_inline_result)),c.modifyExpr&&(modifyExpr=c.modifyExpr(this,selCmpt,modifyExpr)));JSCompiler_inline_result.push({name:name+"_modify",on:[{events:{signal:selCmpt.name+"_tuple"},update:`modify(${vega.stringValue(selCmpt.name+"_store")}, ${modifyExpr})`}]})}JSCompiler_inline_result=cleanupEmptyOnArray(JSCompiler_inline_result);return[...JSCompiler_temp_const,...JSCompiler_inline_result]}assembleSelectionData(data){return assembleUnitSelectionData(this,data)}assembleLayout(){return null}assembleLayoutSignals(){return assembleLayoutSignals(this)}assembleMarks(){let marks=
this.component.mark??[];this.parent&&isLayerModel(this.parent)||(marks=assembleUnitSelectionMarks(this,marks));return marks.map(this.correctDataNames)}assembleGroupStyle(){const {style}=this.view||{};if(void 0!==style)return style;if(this.encoding.x||this.encoding.y)return"cell"}getMapping(){return this.encoding}get mark(){return this.markDef.type}channelHasField(channel){return channelHasField(this.encoding,channel)}fieldDef(channel){return getFieldDef(this.encoding[channel])}typedFieldDef(channel){channel=
this.fieldDef(channel);return isTypedFieldDef(channel)?channel:null}}class LayerModel extends Model{constructor(spec,parent,parentGivenName,parentGivenSize,config){super(spec,"layer",parent,parentGivenName,config,spec.resolve,spec.view);_defineProperty(this,"children",void 0);const layoutSize={...parentGivenSize,...(spec.width?{width:spec.width}:{}),...(spec.height?{height:spec.height}:{})};this.children=spec.layer.map((layer,i)=>{if("layer"in layer)return new LayerModel(layer,this,this.getName(`layer_${i}`),
layoutSize,config);if(isUnitSpec(layer))return new UnitModel(layer,this,this.getName(`layer_${i}`),layoutSize,config);throw Error(invalidSpec(layer));})}parseData(){this.component.data=parseData(this);for(const child of this.children)child.parseData()}parseLayoutSize(){parseChildrenLayoutSize(this);parseNonUnitLayoutSizeForChannel(this,"width");parseNonUnitLayoutSizeForChannel(this,"height")}parseSelections(){this.component.selection={};for(const child of this.children){child.parseSelections();for(const key of keys$jscomp$0(child.component.selection))this.component.selection[key]=
child.component.selection[key]}}parseMarkGroup(){for(const child of this.children)child.parseMarkGroup()}parseAxesAndHeaders(){const {axes,resolve}=this.component,axisCount={top:0,bottom:0,right:0,left:0};for(var child$jscomp$0 of this.children){child$jscomp$0.parseAxesAndHeaders();for(const channel of keys$jscomp$0(child$jscomp$0.component.axes))resolve.axis[channel]=parseGuideResolve(this.component.resolve,channel),"shared"===resolve.axis[channel]&&(axes[channel]=mergeAxisComponents(axes[channel],
child$jscomp$0.component.axes[channel]),axes[channel]||(resolve.axis[channel]="independent",delete axes[channel]))}for(const channel of POSITION_SCALE_CHANNELS){for(const child of this.children)if(child.component.axes[channel]){if("independent"===resolve.axis[channel]){axes[channel]=(axes[channel]??[]).concat(child.component.axes[channel]);for(const axisComponent of child.component.axes[channel]){const {value:orient,explicit}=axisComponent.getWithExplicit("orient");isSignalRef(orient)||(0<axisCount[orient]&&
!explicit&&(child$jscomp$0=OPPOSITE_ORIENT[orient],axisCount[orient]>axisCount[child$jscomp$0]&&axisComponent.set("orient",child$jscomp$0,!1)),axisCount[orient]++)}}delete child.component.axes[channel]}if("independent"===resolve.axis[channel]&&axes[channel]&&1<axes[channel].length)for(const axisCmpt of axes[channel])axisCmpt.get("grid")&&!axisCmpt.explicit.grid&&(axisCmpt.implicit.grid=!1)}}assembleSelectionTopLevelSignals(signals){return this.children.reduce((sg,child)=>child.assembleSelectionTopLevelSignals(sg),
signals)}assembleSignals(){return this.children.reduce((signals,child)=>signals.concat(child.assembleSignals()),assembleAxisSignals(this))}assembleLayoutSignals(){return this.children.reduce((signals,child)=>signals.concat(child.assembleLayoutSignals()),assembleLayoutSignals(this))}assembleSelectionData(data){return this.children.reduce((db,child)=>child.assembleSelectionData(db),data)}assembleGroupStyle(){var uniqueStyles=new Set;for(const child of this.children)for(const style of vega.array(child.assembleGroupStyle()))uniqueStyles.add(style);
uniqueStyles=Array.from(uniqueStyles);return 1<uniqueStyles.length?uniqueStyles:1===uniqueStyles.length?uniqueStyles[0]:void 0}assembleTitle(){let title=super.assembleTitle();if(title)return title;for(const child of this.children)if(title=child.assembleTitle())return title}assembleLayout(){return null}assembleMarks(){return assembleLayerSelectionMarks(this,this.children.flatMap(child=>child.assembleMarks()))}assembleLegends(){return this.children.reduce((legends,child)=>legends.concat(child.assembleLegends()),
assembleLegends(this))}}exports.accessPathDepth=accessPathDepth;exports.accessPathWithDatum=accessPathWithDatum;exports.compile=function(inputSpec){let opt=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{};opt.logger&&(current=opt.logger);opt.fieldTitle&&(titleFormatter=opt.fieldTitle);try{const config=initConfig(vega.mergeConfig(opt.config,inputSpec.config)),spec=normalize$jscomp$0(inputSpec,config),model=buildModel(spec,null,"",void 0,config);model.parse();var data=model.component.data,
model$jscomp$0=model;checkLinks(data.sources);let firstPassCounter=0,secondPassCounter=0;for(var i=0;5>i&&optimizationDataflowHelper(data,model$jscomp$0,!0);i++)firstPassCounter++;data.sources.map(moveFacetDown);for(i=0;5>i&&optimizationDataflowHelper(data,model$jscomp$0,!1);i++)secondPassCounter++;checkLinks(data.sources);5===Math.max(firstPassCounter,secondPassCounter)&&warn("Maximum optimization runs(5) reached.");var autosize=spec.autosize;data=config;model$jscomp$0=model;const width=model$jscomp$0.component.layoutSize.get("width"),
height=model$jscomp$0.component.layoutSize.get("height");void 0===autosize?(autosize={type:"pad"},model$jscomp$0.hasAxisOrientSignalRef()&&(autosize.resize=!0)):vega.isString(autosize)&&(autosize={type:autosize});var JSCompiler_temp;if(JSCompiler_temp=width&&height){var autoSizeType=autosize.type;JSCompiler_temp="fit"===autoSizeType||"fit-x"===autoSizeType||"fit-y"===autoSizeType}if(JSCompiler_temp)if("step"===width&&"step"===height)warn(droppingFit()),autosize.type="pad";else if("step"===width||
"step"===height){autoSizeType="step"===width?"width":"height";warn(droppingFit(getPositionScaleChannel(autoSizeType)));JSCompiler_temp=autosize;var JSCompiler_inline_result=(autoSizeType="width"===autoSizeType?"height":"width",`fit-${getPositionScaleChannel(autoSizeType)}`);JSCompiler_temp.type=JSCompiler_inline_result}var JSCompiler_inline_result$jscomp$0={...(1===keys$jscomp$0(autosize).length&&autosize.type?"pad"===autosize.type?{}:{autosize:autosize.type}:{autosize}),...extractTopLevelProperties(data,
!1),...extractTopLevelProperties(inputSpec,!0)};return{spec:assembleTopLevelModel(model,JSCompiler_inline_result$jscomp$0,inputSpec.datasets,inputSpec.usermeta),normalized:spec}}finally{opt.logger&&(current=main),opt.fieldTitle&&(titleFormatter=defaultTitleFormatter)}};exports.contains=contains;exports.deepEqual=deepEqual;exports.deleteNestedProperty=deleteNestedProperty;exports.duplicate=duplicate;exports.entries=entries$1;exports.every=every;exports.fieldIntersection=fieldIntersection;exports.flatAccessWithDatum=
flatAccessWithDatum;exports.getFirstDefined=getFirstDefined;exports.hasIntersection=hasIntersection;exports.hash=hash;exports.internalField=internalField;exports.isBoolean=isBoolean;exports.isEmpty=isEmpty;exports.isEqual=function(dict,other){const dictKeys=keys$jscomp$0(dict),otherKeys=keys$jscomp$0(other);if(dictKeys.length!==otherKeys.length)return!1;for(const key of dictKeys)if(dict[key]!==other[key])return!1;return!0};exports.isInternalField=isInternalField;exports.isNullOrFalse=isNullOrFalse;
exports.isNumeric=isNumeric;exports.keys=keys$jscomp$0;exports.logicalExpr=logicalExpr;exports.mergeDeep=mergeDeep;exports.never=never;exports.normalize=normalize$jscomp$0;exports.normalizeAngle=normalizeAngle;exports.omit=omit;exports.pick=pick;exports.prefixGenerator=prefixGenerator;exports.removePathFromField=removePathFromField;exports.replaceAll=replaceAll;exports.replacePathInField=replacePathInField;exports.resetIdCounter=function(){idCounter=42};exports.setEqual=setEqual;exports.some=some;
exports.stringify=stringify;exports.titleCase=titleCase;exports.unique=unique;exports.uniqueId=uniqueId;exports.vals=vals$jscomp$0;exports.varName=varName;exports.version="5.6.1"})}
//# sourceMappingURL=module$node_modules$vega_lite$build$vega_lite.js.map
